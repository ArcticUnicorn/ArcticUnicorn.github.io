<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构与算法一-排序算法</title>
      <link href="/2023/11/16/shu-ju-jie-gou-yu-suan-fa-yi-pai-xu-suan-fa/"/>
      <url>/2023/11/16/shu-ju-jie-gou-yu-suan-fa-yi-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法说明"><a href="#排序算法说明" class="headerlink" title="排序算法说明"></a>排序算法说明</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li></ul><h2 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126165917.png"></p><ul><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li></ul><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126170135.png"></p><h2 id="比较排序和非比较排序的区别"><a href="#比较排序和非比较排序的区别" class="headerlink" title="比较排序和非比较排序的区别"></a>比较排序和非比较排序的区别</h2><h3 id="比较排序"><a href="#比较排序" class="headerlink" title="比较排序"></a>比较排序</h3><p>常见的<code>快速排序</code>、<code>归并排序</code>、<code>堆排序</code>、<code>冒泡排序</code>等属于<code>比较排序</code>。<strong>在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</strong></p><p>在<code>冒泡排序</code>之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在<code>归并排序</code>、<code>快速排序</code>之类的排序中，问题规模通过<strong>分治法</strong>消减为 logN 次，所以时间复杂度平均为 O(nlogn)。</p><p>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p><h3 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h3><p><code>计数排序</code>、<code>基数排序</code>、<code>桶排序</code>则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</p><p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。</p><p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p><h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/849589-20171015223238449-2146169197.gif"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] bubbleSort(<span class="hljs-type">int</span>[] array) {<br>    <span class="hljs-keyword">if</span>(array.length == <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">return</span> array;<br>    }<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; array.length;i++) {<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; array.length - <span class="hljs-number">1</span> - i; j++) {<br>            <span class="hljs-keyword">if</span>(array[j + <span class="hljs-number">1</span>] &lt; array[j]) {<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> array[j + <span class="hljs-number">1</span>];<br>                array[j + <span class="hljs-number">1</span>] = array[j];<br>                array[j] = tmp;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] bubbleSort(<span class="hljs-type">int</span>[] array) {<br>    <span class="hljs-keyword">if</span>(array.length == <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">return</span> array;<br>    }<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; array.length;i++) {<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; array.length - <span class="hljs-number">1</span> - i; j++) {<br>            <span class="hljs-keyword">if</span>(array[j + <span class="hljs-number">1</span>] &lt; array[j]) {<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> array[j + <span class="hljs-number">1</span>];<br>                array[j + <span class="hljs-number">1</span>] = array[j];<br>                array[j] = tmp;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> array;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li>最佳情况：T(n) = O(n)   </li><li>最差情况：T(n) = O(n2)   </li><li>平均情况：T(n) = O(n2)</li></ul><h1 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h1><p><strong>表现最稳定</strong>的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h2 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/849589-20171015224719590-1433219824.gif"></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] selectSort(<span class="hljs-type">int</span>[] array) {<br>    <span class="hljs-keyword">if</span>(array.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; array.length;i++) {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;j &lt; array.length;j++) {<br>            <span class="hljs-keyword">if</span>(array[j] &lt; array[minIndex]) {<br>                minIndex = j;<br>            }<br>        }<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> array[i];<br>        array[i] = array[minIndex];<br>        array[minIndex] = tmp;<br>    }<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] selectSort(<span class="hljs-type">int</span>[] array) {<br>    <span class="hljs-keyword">if</span>(array.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; array.length;i++) {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;j &lt; array.length;j++) {<br>            <span class="hljs-keyword">if</span>(array[j] &lt; array[minIndex]) {<br>                minIndex = j;<br>            }<br>        }<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> array[i];<br>        array[i] = array[minIndex];<br>        array[minIndex] = tmp;<br>    }<br>    <span class="hljs-keyword">return</span> array;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h2><p>O(n2)</p><h1 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h1><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h2 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/849589-20171015225645277-1151100000.gif"></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] insertionSort(<span class="hljs-type">int</span>[] array) {<br>    <span class="hljs-keyword">if</span>(array.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-type">int</span> cur;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; array.length - <span class="hljs-number">1</span>;i++) {<br>        cur = array[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span>(pre &gt;= <span class="hljs-number">0</span> &amp;&amp; cur &lt; array[pre]) {<br>            array[pre + <span class="hljs-number">1</span>] = array[pre];<br>            pre--;<br>        }<br>        array[pre + <span class="hljs-number">1</span>] = cur;<br>    }<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] insertionSort(<span class="hljs-type">int</span>[] array) {<br>    <span class="hljs-keyword">if</span>(array.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-type">int</span> cur;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; array.length - <span class="hljs-number">1</span>;i++) {<br>        cur = array[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span>(pre &gt;= <span class="hljs-number">0</span> &amp;&amp; cur &lt; array[pre]) {<br>            array[pre + <span class="hljs-number">1</span>] = array[pre];<br>            pre--;<br>        }<br>        array[pre + <span class="hljs-number">1</span>] = cur;<br>    }<br>    <span class="hljs-keyword">return</span> array;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li>最佳情况：T(n) = O(n)   </li><li>最坏情况：T(n) = O(n2)   </li><li>平均情况：T(n) = O(n2)</li></ul><h1 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h1><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h2 id="过程演示"><a href="#过程演示" class="headerlink" title="过程演示"></a>过程演示</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126212252.png"></p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] shellSort(<span class="hljs-type">int</span>[] array) {<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> array.length;<br>    <span class="hljs-type">int</span> tmp, gap = len / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(gap &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap;i &lt; len;i++) {<br>            tmp = array[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>            <span class="hljs-keyword">while</span>(preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; array[preIndex] &gt; tmp) {<br>                array[preIndex + gap] = array[preIndex];<br>                preIndex -= gap;<br>            }<br>            array[preIndex + gap] = temp;<br>        }<br>        gap /= <span class="hljs-number">2</span>;<br>    }<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] shellSort(<span class="hljs-type">int</span>[] array) {<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> array.length;<br>    <span class="hljs-type">int</span> tmp, gap = len / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(gap &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap;i &lt; len;i++) {<br>            tmp = array[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>            <span class="hljs-keyword">while</span>(preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; array[preIndex] &gt; tmp) {<br>                array[preIndex + gap] = array[preIndex];<br>                preIndex -= gap;<br>            }<br>            array[preIndex + gap] = temp;<br>        }<br>        gap /= <span class="hljs-number">2</span>;<br>    }<br>    <span class="hljs-keyword">return</span> array;<br>}                <br></code></pre></td></tr></tbody></table></figure><h2 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li>最佳情况：T(n) = O(n log n) </li><li>最坏情况：T(n) = O(n log n)  </li><li>平均情况：T(n) =O(n log n)</li></ul><h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h2 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h2 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/849589-20171015230557043-37375010.gif"></p><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] mergeSort(<span class="hljs-type">int</span>[] array) {<br>    <span class="hljs-keyword">if</span>(array.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> array.length / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span>[] left = Arrays.copyOfRange(array, <span class="hljs-number">0</span>, mid);<br>    <span class="hljs-type">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);<br>    <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right));<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] merge(<span class="hljs-type">int</span>[] left, <span class="hljs-type">int</span>[] right) {<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[left.length + right.length];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;index &lt; res.length;index++) {<br>        <span class="hljs-keyword">if</span>(i &gt;= left.length) {<br>            res[index] = right[j++];<br>        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt;= right.length) {<br>            res[index] = left[i++];<br>        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left[i] &gt;= right[j]) {<br>            res[index] = right[j++];<br>        }<span class="hljs-keyword">else</span> {<br>            res[index] = left[i++];<br>        }<br>    }<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] mergeSort(<span class="hljs-type">int</span>[] array) {<br>    <span class="hljs-keyword">if</span>(array.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> array.length / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span>[] left = Arrays.copyOfRange(array, <span class="hljs-number">0</span>, mid);<br>    <span class="hljs-type">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);<br>    <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right));<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] merge(<span class="hljs-type">int</span>[] left, <span class="hljs-type">int</span>[] right) {<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[left.length + right.length];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;index &lt; res.length;index++) {<br>        <span class="hljs-keyword">if</span>(i &gt;= left.length) {<br>            res[index] = right[j++];<br>        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt;= right.length) {<br>            res[index] = left[i++];<br>        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left[i] &gt;= right[j]) {<br>            res[index] = right[j++];<br>        }<span class="hljs-keyword">else</span> {<br>            res[index] = left[i++];<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h2><ul><li>最佳情况：T(n) = O(n)  </li><li>最差情况：T(n) = O(nlogn)  </li><li>平均情况：T(n) = O(nlogn)</li></ul><h1 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h1><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h2 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h2><p>快速排序是一种基于分而治之的排序算法，其中：</p><ul><li>通过从数组中选择一个中心元素将数组划分成两个子数组，在划分数组时，将比中心元素小的元素放在左子数组，将比中心元素大的元素放在右子数组。</li><li>左子数组和右子数组也使用相同的方法进行划分，这个过程一直持续到每个子数组都包含一个元素为止。</li><li>最后，将元素组合在一起以形成排序的数组。</li></ul><h2 id="快速排序算法的工作原理"><a href="#快速排序算法的工作原理" class="headerlink" title="快速排序算法的工作原理"></a>快速排序算法的工作原理</h2><h3 id="选择中心元素"><a href="#选择中心元素" class="headerlink" title="选择中心元素"></a>选择中心元素</h3><p>选择不同位置的中心元素，快速排序就有不同的变体，比如可以选择：第一个元素、最后一个元素以及左端、右端和中心位置上的三个元素的中值作为中心元素，在这里，我们将选择数组的最后一个元素作为中心元素。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126223642.png"></p><h3 id="重新排列数组"><a href="#重新排列数组" class="headerlink" title="重新排列数组"></a>重新排列数组</h3><p>现在重新排列数组，将比中心元素小的放在左边，比中心元素大的放在右边。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126223712.png"></p><p>重新排列数组的方法如下：</p><p>1、指针固定在中心元素上，将中心元素与从第一个索引开始的元素进行比较。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126223822.png"></p><p>2、如果该元素大于中心元素，则为该元素设置第二指针。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126223844.png"></p><p>3、现在将中心元素与其他元素进行比较，如果到达的元素小于中心元素，则将较小的元素和上次找到的较大元素交换位置。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126223935.png"></p><p>4、同样，重复该过程以将下一个更大的元素设置为第二指针，并且将其和另一个较小的元素交换位置。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126224021.png"></p><p>5、该过程一直进行到到达倒数第二个元素为止。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126224247.png"></p><p>6、最后将中心元素与第二个指针指向的元素交换位置。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126224331.png"></p><h3 id="划分子数组"><a href="#划分子数组" class="headerlink" title="划分子数组"></a>划分子数组</h3><p>再次分别为左子部分和右子部分选择中心元素，并且重复上一步，子数组被分割，直到每个子数组只有一个元素，至此，该数组已经通过快速排序算法升序排好序了。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126224625.png"></p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126224639.png"></p><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) {<br>        quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {<br>        <span class="hljs-keyword">if</span>(start &gt;= end) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> nums[start];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> end;<br>        <span class="hljs-keyword">while</span>(left &lt; right) {<br>            <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right] &gt; mid) {<br>                right--;<br>            }<br><br>            <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[left] &lt;= mid) {<br>                left++;<br>            }<br><br>            <span class="hljs-keyword">if</span>(left &lt; right) {<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[left];<br>                nums[left] = nums[right];<br>                nums[right] = tmp;<br>            }<br>        }<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[left];<br>        nums[left] = nums[start];<br>        nums[start] = tmp;<br>        quickSort(nums, start, left - <span class="hljs-number">1</span>);<br>        quickSort(nums, left + <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) {<br>        quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {<br>        <span class="hljs-keyword">if</span>(start &gt;= end) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> nums[start];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> end;<br>        <span class="hljs-keyword">while</span>(left &lt; right) {<br>            <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right] &gt; mid) {<br>                right--;<br>            }<br><br>            <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[left] &lt;= mid) {<br>                left++;<br>            }<br><br>            <span class="hljs-keyword">if</span>(left &lt; right) {<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[left];<br>                nums[left] = nums[right];<br>                nums[right] = tmp;<br>            }<br>        }<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[left];<br>        nums[left] = nums[start];<br>        nums[start] = tmp;<br>        quickSort(nums, start, left - <span class="hljs-number">1</span>);<br>        quickSort(nums, left + <span class="hljs-number">1</span>, end);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220126230107.png"></p><ul><li><p>最坏的时间复杂度：</p><p>当选择的中心元素是最大或最小的元素时发生，这种情况导致中心元素位于已排序数组的最末端，一个子数组始终为空，而另一个子数组包含元素，因此，仅在此子数组上调用quicksort，快速排序算法对于分散的数据具有更好的性能。</p></li><li><p>最好的时间复杂度：</p><p>当中心元素始终是中间元素或靠近中间元素时，会发生这种情况。</p></li></ul><h1 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><p>完全二叉树</p><p>除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。</p></li><li><p>满二叉树</p><p>除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充。</p></li><li><p>完满二叉树</p><p>除了叶子结点之外的每一个结点都有两个孩子结点。</p></li></ol><h2 id="二叉堆介绍"><a href="#二叉堆介绍" class="headerlink" title="二叉堆介绍"></a>二叉堆介绍</h2><p>简单来说：堆排序是将数据看成是完全二叉树、根据完全二叉树的特性来进行排序的一种算法</p><ul><li>最大堆要求节点的元素都要不小于其孩子，最小堆要求节点元素都不大于其左右孩子</li><li>那么处于最大堆的根节点的元素一定是这个堆中的最大值</li></ul><p>在此以最大堆排序为例，如下图就是一个最大堆，其中的每个父节点都大于子节点。但是大顶堆只保证父节点大于左右孩子节点的值，不需要保证左右孩子节点之间的大小顺序。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220127204046.png"></p><h2 id="构建二叉堆"><a href="#构建二叉堆" class="headerlink" title="构建二叉堆"></a>构建二叉堆</h2><p>二叉堆的定义已经知道了，那么当给出一个无序的完全二叉树时，怎么把它构建成二叉堆呢？在此以大顶堆为例，给定以下的一个数组，画出其初始的树状态，如下图所示。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">{4, 1, 9, 3, 7, 8, 5, 6, 2}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220127205151.png"></p><p>由于大顶堆中父节点的值都大于左右孩子节点，所以树的根节点肯定是所有节点中值最大的。因此，我们需要从树的最后一层开始，逐渐的把大值向上调整（左右孩子节点中较大的节点和父节点交换），直到第一层。</p><p>之所以选择从最后一层开始，是因为如果从第一层开始的话，不能保证被换到根节点的值就是所有节点的最大值。例如图中就是 4 和 9 交换位置之后，你不能保证 9 就是所有节点的最大值。（虽然此时9确实是最大）。如果下边还有比 9 大的数字，最终还是需要从下面向上遍历调整。而为什么从最下面的非叶子节点（图中节点 3 ）开始。是因为叶子节点的下面已经没有子节点了，它只能和父节点比较，从叶子节点开始没有意义。</p><p>第一步，以 3 为父节点开始，比较他们的子节点 6 和 2 ，6 最大，然后和 3 交换位置。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220127210440.png"></p><p>第二步，6 和 7 比较，7 最大，7 和 1 交换位置。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220127210458.png"></p><p>第三步，7 和 9 比较，9 最大，9 和 4 交换位置。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220127210838.png"></p><p>第四步，我们发现交换位置之后，4 下边还有比它大的，因此还需要以 4 为父节点和它的左右子节点进行比较。发现 8 最大，然后 8 和 4 交换位置。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220127210906.png"></p><p>以下是构建大顶堆的代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调整为大顶堆</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr   待调整的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> parent   当前父节点的下标</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> length   需要对多少个元素进行调整</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> parent, <span class="hljs-type">int</span> length)</span> {<br>    <span class="hljs-comment">// 临时保存父节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[parent];<br>    <span class="hljs-comment">// 左子节点的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(child &lt; length) {<br>        <span class="hljs-comment">// 判断左子节点和右子节点的大小，若右边大，则把 child 定位到右边</span><br>        <span class="hljs-keyword">if</span>(child + <span class="hljs-number">1</span> &lt; length &amp;&amp; arr[child] &lt; arr[child + <span class="hljs-number">1</span>]) {<br>            child++;<br>        }<br>        <span class="hljs-comment">// 若 child 大于父节点，则交换位置，否则跳出循环</span><br>        <span class="hljs-keyword">if</span>(arr[child] &gt; tmp) {<br>            <span class="hljs-comment">// 父子节点交换位置</span><br>            arr[parent] = arr[child];<br>            <span class="hljs-comment">// 因为交换位置之后，不能保证当前的子节点是它所在的子树的最大值，所以需要继续向下比较</span><br>            <span class="hljs-comment">// 把当前子节点设置为下次循环的父节点，同时找到它的左子节点，继续下次循环</span><br>            parent = child;<br>            child = <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// 如果当前子节点小于等于父节点，则无需改变父节点</span><br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 把当前节点值替换为最开始暂存的父节点值</span><br>    arr[parent] = tmp;<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number"><code class="language-hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调整为大顶堆</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr   待调整的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> parent   当前父节点的下标</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> length   需要对多少个元素进行调整</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> parent, <span class="hljs-type">int</span> length)</span> {<br>    <span class="hljs-comment">// 临时保存父节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[parent];<br>    <span class="hljs-comment">// 左子节点的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(child &lt; length) {<br>        <span class="hljs-comment">// 判断左子节点和右子节点的大小，若右边大，则把 child 定位到右边</span><br>        <span class="hljs-keyword">if</span>(child + <span class="hljs-number">1</span> &lt; length &amp;&amp; arr[child] &lt; arr[child + <span class="hljs-number">1</span>]) {<br>            child++;<br>        }<br>        <span class="hljs-comment">// 若 child 大于父节点，则交换位置，否则跳出循环</span><br>        <span class="hljs-keyword">if</span>(arr[child] &gt; tmp) {<br>            <span class="hljs-comment">// 父子节点交换位置</span><br>            arr[parent] = arr[child];<br>            <span class="hljs-comment">// 因为交换位置之后，不能保证当前的子节点是它所在的子树的最大值，所以需要继续向下比较</span><br>            <span class="hljs-comment">// 把当前子节点设置为下次循环的父节点，同时找到它的左子节点，继续下次循环</span><br>            parent = child;<br>            child = <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-comment">// 如果当前子节点小于等于父节点，则无需改变父节点</span><br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 把当前节点值替换为最开始暂存的父节点值</span><br>    arr[parent] = tmp;<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) {<br>        adjustHeap(arr, i, arr.length);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ol><li>把当前数组构建成一个大顶堆。</li><li>此时，根节点肯定是所有节点中最大的值，让它和末尾元素交换位置，则最后一个元素就是最大值。</li><li>把剩余的 n - 1个元素重新构建成一个大顶堆，就会得到 n-1 个元素中的最大值。重复执行此动作，就会把所有的元素调整为有序了。</li></ol><p>还是以上边的数组为例，看一下堆排序的过程。</p><p>一共有九个元素，把它调整为大顶堆，然后把堆顶元素 9 和末尾元素 2 交换位置。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220127215113.png"></p><p>此时，9已经有序了，不需要调整。然后把剩余八个元素调整为大顶堆，再把这八个元素的堆顶元素和末尾元素交换位置，如下，8 和 3 交换位置。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220127215135.png"></p><p>此时，8和 9 已经有序了，不需要调整。然后把剩余七个元素调整为大顶堆，再把这七个元素的堆顶元素和末尾元素交换位置。如下， 7 和 2 交换位置。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220127215154.png"></p><p>以此类推，经过 n - 1 次循环调整，到了最后只剩下一个元素的时候，就不需要再比较了，因为它已经是最小值了。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220127215216.png"></p><p>代码实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">// 堆排序，大顶堆，升序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {<br>    <span class="hljs-comment">// 构建一个大顶堆，从最下面的非叶子节点向上遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) {<br>        adjustHeap(arr, i, arr.length);<br>    }<br>    <span class="hljs-comment">// 循环执行以下操作：1. 交换堆顶元素和末尾元素，2.重新调整为大顶堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;i &gt; <span class="hljs-number">0</span>;i--) {<br>        <span class="hljs-comment">// 将堆顶最大元素和末尾元素交换</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[<span class="hljs-number">0</span>];<br>        arr[<span class="hljs-number">0</span>] = tmp;<br>        <span class="hljs-comment">// 从堆顶开始重新调整结构</span><br>        adjustHeap(arr, i, <span class="hljs-number"><code class="language-hljs java"><span class="hljs-comment">// 堆排序，大顶堆，升序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {<br>    <span class="hljs-comment">// 构建一个大顶堆，从最下面的非叶子节点向上遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--) {<br>        adjustHeap(arr, i, arr.length);<br>    }<br>    <span class="hljs-comment">// 循环执行以下操作：1. 交换堆顶元素和末尾元素，2.重新调整为大顶堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;i &gt; <span class="hljs-number">0</span>;i--) {<br>        <span class="hljs-comment">// 将堆顶最大元素和末尾元素交换</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[<span class="hljs-number">0</span>];<br>        arr[<span class="hljs-number">0</span>] = tmp;<br>        <span class="hljs-comment">// 从堆顶开始重新调整结构</span><br>        adjustHeap(arr, i, <span class="hljs-number">0</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>堆排序，每次调整为大顶堆的时间复杂度为 O(logn)，而 n 个元素，总共需要循环调整 n-1 次 ，所以堆排序的时间复杂度就是 O(nlogn)。</p><p>由于没有占用额外的内存空间，因此，堆排序的空间复杂度为 O(1)。</p><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220127222456.png"></p><p>桶排序 (Bucket sort)的工作原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ol><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ol><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketSort</span>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; arr.length;i++) {<br>            max = Math.max(max, arr[i]);<br>            min = Math.max(min, arr[i]);<br>        }<br><br>        <span class="hljs-comment">// 桶数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bucketNum</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-comment">// 这里的处理很巧妙</span><br>        <span class="hljs-comment">// 声明并初始化一个ArrayList，用来存放桶的个数以及桶中的数据</span><br>        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; bucketNum;i++) {<br>            bucketArr.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        }<br><br>        <span class="hljs-comment">//将每个元素放入桶中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; arr.length;i++) {<br>            <span class="hljs-comment">// 判断 arr[i] 是属于哪个桶的</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)((arr[i] - min) / (max - min + <span class="hljs-number">1</span>) * arr.length);<br>            bucketArr.get(num).add(a[i]);<br>        }<br><br>        <span class="hljs-comment">// 对每个桶进行排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; bucketArr.size();j++) {<br>            Collections.sort(bucketArr.get(j));<br>        }<br><br>        <span class="hljs-comment">// 合并数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(ArrayList&lt;Integer&gt; array : bucketArr) {<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketSort</span>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; arr.length;i++) {<br>            max = Math.max(max, arr[i]);<br>            min = Math.max(min, arr[i]);<br>        }<br><br>        <span class="hljs-comment">// 桶数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bucketNum</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-comment">// 这里的处理很巧妙</span><br>        <span class="hljs-comment">// 声明并初始化一个ArrayList，用来存放桶的个数以及桶中的数据</span><br>        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; bucketNum;i++) {<br>            bucketArr.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        }<br><br>        <span class="hljs-comment">//将每个元素放入桶中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; arr.length;i++) {<br>            <span class="hljs-comment">// 判断 arr[i] 是属于哪个桶的</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)((arr[i] - min) / (max - min + <span class="hljs-number">1</span>) * arr.length);<br>            bucketArr.get(num).add(a[i]);<br>        }<br><br>        <span class="hljs-comment">// 对每个桶进行排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; bucketArr.size();j++) {<br>            Collections.sort(bucketArr.get(j));<br>        }<br><br>        <span class="hljs-comment">// 合并数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(ArrayList&lt;Integer&gt; array : bucketArr) {<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : array) {<br>                arr[k++] = i;<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="算法性能分析"><a href="#算法性能分析" class="headerlink" title="算法性能分析"></a>算法性能分析</h2><p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候**桶排序的时间复杂度接近 O(n)**。</p><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><h1 id="典型排序算法问题"><a href="#典型排序算法问题" class="headerlink" title="典型排序算法问题"></a>典型排序算法问题</h1><h2 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre class=" language-hljs java">逆序对问题借用归并排序思想<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeProcess</span><span class="hljs-params">(<span class="hljs-type">int</span> [] arr)</span> {<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">return</span> mergeSort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>);<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> [] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>{<br>    <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> L + ((R-L)&gt;&gt;<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> mergeSort(arr,left,mid) + mergeSort(arr,mid+<span class="hljs-number">1</span>,right) + merger(arr,left,mid,right);<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> [] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> {<br>    <span class="hljs-type">int</span> [] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [right-left+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> left;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) {<br>        res += arr[p1] &lt; arr[p2] ? (right - p2 + <span class="hljs-number">1</span>) * arr[p1] : <span class="hljs-number">0</span>;<br>        help [i++] = arrp[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];<br>    }<br>    <span class="hljs-keyword">while</span> (p1 &lt;= mid) {<br>        help[i++] = arr[p1++];<br>    }<br>    <span class="hljs-keyword">while</span> (p2 &lt;= right) {<br>        help[i++] = arr[p2++];<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;help.length; i++) {<br>        arr[L+i] = help[i];<br>    }<br>    <span class="hljs-keyword"><code class="language-hljs java">逆序对问题借用归并排序思想<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeProcess</span><span class="hljs-params">(<span class="hljs-type">int</span> [] arr)</span> {<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">return</span> mergeSort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>);<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> [] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>{<br>    <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> L + ((R-L)&gt;&gt;<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> mergeSort(arr,left,mid) + mergeSort(arr,mid+<span class="hljs-number">1</span>,right) + merger(arr,left,mid,right);<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> [] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> {<br>    <span class="hljs-type">int</span> [] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [right-left+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> left;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) {<br>        res += arr[p1] &lt; arr[p2] ? (right - p2 + <span class="hljs-number">1</span>) * arr[p1] : <span class="hljs-number">0</span>;<br>        help [i++] = arrp[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];<br>    }<br>    <span class="hljs-keyword">while</span> (p1 &lt;= mid) {<br>        help[i++] = arr[p1++];<br>    }<br>    <span class="hljs-keyword">while</span> (p2 &lt;= right) {<br>        help[i++] = arr[p2++];<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;help.length; i++) {<br>        arr[L+i] = help[i];<br>    }<br>    <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h2><p>问题描述：给定一个数组和一个 num,将小于 num 的数放在左边，等于 num的放中间， 大于等于 numd的放在右边。(正好类似于荷兰国旗🇳🇱，因此该问题叫荷兰国旗问题)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> [] partition(<span class="hljs-type">int</span> [] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> num) {<br>    <span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> L - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">more</span> <span class="hljs-operator">=</span> R + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> L;<br>    <span class="hljs-keyword">while</span> (cur &lt; more) {<br>        <span class="hljs-keyword">if</span> (arr [cur] &lt; num) {<br>            swap(arr, ++less,cur++);<br>        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[cur] &gt; num) {<br>            swap(arr, --more, cur);<br>        }<span class="hljs-keyword">else</span> {<br>            cur++;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> []{less+<span class="hljs-number">1</span>, more-<span class="hljs-number">1</span>};<span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> [] partition(<span class="hljs-type">int</span> [] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> num) {<br>    <span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> L - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">more</span> <span class="hljs-operator">=</span> R + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> L;<br>    <span class="hljs-keyword">while</span> (cur &lt; more) {<br>        <span class="hljs-keyword">if</span> (arr [cur] &lt; num) {<br>            swap(arr, ++less,cur++);<br>        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[cur] &gt; num) {<br>            swap(arr, --more, cur);<br>        }<span class="hljs-keyword">else</span> {<br>            cur++;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> []{less+<span class="hljs-number">1</span>, more-<span class="hljs-number">1</span>};<span class="hljs-comment">//返回的是等于区域的开始下标和结束下标</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="中位流问题"><a href="#中位流问题" class="headerlink" title="中位流问题"></a>中位流问题</h2><p>思路：建立两个堆, 一个大根堆 一个小根堆, 较小的n/2在大根堆里,较大的n/2在小根堆里。一开始,来一个数加入到大根堆,后边来一个数若比大根堆堆顶元素小，则放入大根堆，否则放入小根堆，每次加完如果两个堆不平，也就是两个堆的大小超过2，则将元素多的那个堆弹出一个元素，放入元素少的那个堆。求中位数时，如果两个堆相等，则中位数为两个堆顶的平均数；如果两个堆顶相差1，则中位数为数字多的堆的堆顶元素。</p><h1 id="工程中实际用的排序"><a href="#工程中实际用的排序" class="headerlink" title="工程中实际用的排序"></a>工程中实际用的排序</h1><p>实际工程中, 小样本情况下(样本大小通常小于六十的时候)， 不管数据类型是什么，一般直接使用插入排序; 大样本情况下， 考虑快速排序和归并排序，从稳定性角度考虑， 归并排序是稳定的，开酥排序是不稳定的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础二-图解HTTP</title>
      <link href="/2023/11/16/ji-suan-ji-wang-luo-ji-chu-er-tu-jie-http/"/>
      <url>/2023/11/16/ji-suan-ji-wang-luo-ji-chu-er-tu-jie-http/</url>
      
        <content type="html"><![CDATA[<h1 id="Web-及网络基础"><a href="#Web-及网络基础" class="headerlink" title="Web 及网络基础"></a>Web 及网络基础</h1><h2 id="网络基础TCP-IP"><a href="#网络基础TCP-IP" class="headerlink" title="网络基础TCP/IP"></a>网络基础TCP/IP</h2><h3 id="分层管理"><a href="#分层管理" class="headerlink" title="分层管理"></a>分层管理</h3><p><img src="https://s2.loli.net/2021/12/15/obvYpXhK3Ndqa96.png"></p><p>好处： 分层后，每个层次内部的设计能够自由改动、设计也变得更加简单，每个层次可以只考虑自己的任务，不必了解全局信息。</p><p>各层作用：</p><ul><li>应用层：决定了向用户提供应用服务时通信的活动，协议：FTP、DNS、HTTP 等</li><li>传输层：对上层应用层，提供处于网络连接中的两台计算机之间的数据传输，协议：TCP、UDP</li><li>网络层：处理网络上流动的数据包，该层规定了通过怎样的路径到达对方计算机，并将数据包传送给对方</li><li>链路层：处理连接网络的硬件部分</li></ul><h3 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP/IP 通信传输流"></a>TCP/IP 通信传输流</h3><p><img src="https://s2.loli.net/2021/12/15/eyXPRJAtSs32iuZ.png"></p><h2 id="与-HTTP-关系密切的协议：IP、TCP-和-DNS"><a href="#与-HTTP-关系密切的协议：IP、TCP-和-DNS" class="headerlink" title="与 HTTP 关系密切的协议：IP、TCP 和 DNS"></a>与 HTTP 关系密切的协议：IP、TCP 和 DNS</h2><ol><li><p>IP 协议</p><p>位于网络层，作用为将各种数据包传送给对方，需要确保得知对方的 IP 地址和 MAC 地址：IP 地址指明了节点被分配到的地址，MAC 地址则是指网卡所属的固定地址。IP 地址能够和 MAC 地址进行配对，IP 地址可变换，而 MAC 地址基本不会更改。</p><p>IP 间的通信往往需要多个中转设备，因此采用 ARP 协议进行地址解析，能够通过 IP 地址反查出 MAC 地址。</p></li><li><p>TCP 协议</p><p>位于传输层，提供可靠的字节流服务。</p><p>采用三次握手策略，握手过程中使用 TCP 的标志：SYN 和 ACK</p><p><img src="https://s2.loli.net/2021/12/15/A8UtIg4MVanFCvL.png"></p></li><li><p>DNS 服务</p><p>位于应用层，提供域名到 IP 地址之间的解析服务。</p></li><li><p>各协议和 HTTP 的关系</p><p>使用 HTTP 协议通信时：</p><p><img src="https://s2.loli.net/2021/12/15/nKH1iGl4zNJPLTI.png"></p></li></ol><h2 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h2><h3 id="统一资源标识符-URI"><a href="#统一资源标识符-URI" class="headerlink" title="统一资源标识符 URI"></a>统一资源标识符 URI</h3><p>Uniform Resource Identifier ：由某个协议方案表示的资源的定位标识符，协议方案是指访问资源所使用的协议类型名称。</p><p>URI 用字符串标识某一互联网资源，而 URL 则表示资源所处的地点。</p><h3 id="URI-格式"><a href="#URI-格式" class="headerlink" title="URI 格式"></a>URI 格式</h3><p>绝对 URI 格式:</p><p><img src="https://s2.loli.net/2021/12/15/Ayn9ePDNmgqsj71.png"></p><h1 id="简单-HTTP-协议"><a href="#简单-HTTP-协议" class="headerlink" title="简单 HTTP 协议"></a>简单 HTTP 协议</h1><h2 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h2><p>请求必定由客户端发出, 而服务器回复响应。</p><p><img src="https://s2.loli.net/2021/12/15/3iDvHGoTUaOrdWu.png"></p><p><strong>请求报文中的内容:</strong></p><p><img src="https://s2.loli.net/2021/12/15/gxT5iSwv1XRNKfd.png"></p><p>GET: 表示请求访问服务器的类型, 称为方法。 随后的字符串 /index.htm 指明了请求访问的资源对象, 也叫做请求 URI 。最后的 HTTP/1.1, 即 HTTP 的版本号, 用于提示客户端使用的 HTTP 协议功能。该报文的内容为: 请求访问某台 HTTP 服务器上的 /index.htm 页面资源</p><p><strong>请求报文的构成:</strong></p><p><img src="https://s2.loli.net/2021/12/15/u2ZFBodc85ih6ns.png"></p><p><strong>响应报文中的内容:</strong></p><p><img src="https://s2.loli.net/2021/12/15/6yFid2HWQOmEs3x.png"></p><p>HTTP/1.1 表示服务器对应的 HTTP 版本，200 OK 表示请求处理结果的状态码和原因短语。下一行显示创建响应的日期时间，是首部字段内的一个属性。空行分隔后的内容为资源实体的主体。</p><p><strong>响应报文的构成:</strong></p><p><img src="https://s2.loli.net/2021/12/15/Y8RHNz2xADjMJX3.png"></p><h2 id="HTTP-是不保存状态的协议"><a href="#HTTP-是不保存状态的协议" class="headerlink" title="HTTP 是不保存状态的协议"></a>HTTP 是不保存状态的协议</h2><p>HTTP 协议自身不对请求和响应之间的通信状态进行保存，目的是为了更快地处理大量事务、确保协议的可伸缩性。</p><p>为了实现期望的保存状态功能，引入了 Cookie 技术。</p><h2 id="请求-URI-定位资源"><a href="#请求-URI-定位资源" class="headerlink" title="请求 URI 定位资源"></a>请求 URI 定位资源</h2><p>指定客户端所请求的 URI 的几种方式：</p><p><img src="https://s2.loli.net/2021/12/15/YDaTRS5nOgkbL1i.png"></p><p>除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用 * 代替请求 URI，如：</p><p><code>OPTIONS * HTTP/1.1</code></p><p>该例子是查询 HTTP 服务器端支持的 HTTP 方法种类</p><h2 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h2><h3 id="GET：获取资源"><a href="#GET：获取资源" class="headerlink" title="GET：获取资源"></a>GET：获取资源</h3><p>用于请求访问已被 URI 标识的资源，指定的资源经服务器端解析后返回响应内容。</p><h3 id="POST：传输实体主体"><a href="#POST：传输实体主体" class="headerlink" title="POST：传输实体主体"></a>POST：传输实体主体</h3><p>功能与 GET 很相似，但主要目的不是获取响应的主体内容，而是传输实体的主体</p><h3 id="PUT：传输文件"><a href="#PUT：传输文件" class="headerlink" title="PUT：传输文件"></a>PUT：传输文件</h3><p>要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。由于安全性问题，一般的 web 网站不采用该种方法。</p><h3 id="HEAD：获取报文首部"><a href="#HEAD：获取报文首部" class="headerlink" title="HEAD：获取报文首部"></a>HEAD：获取报文首部</h3><p>确认 URI 有效性以及资源更新的日期时间</p><h3 id="DELETE：删除文件"><a href="#DELETE：删除文件" class="headerlink" title="DELETE：删除文件"></a>DELETE：删除文件</h3><p>一般网站不使用</p><h3 id="OPTIONS：询问支持的方法"><a href="#OPTIONS：询问支持的方法" class="headerlink" title="OPTIONS：询问支持的方法"></a>OPTIONS：询问支持的方法</h3><h3 id="TRACE：追踪路径"><a href="#TRACE：追踪路径" class="headerlink" title="TRACE：追踪路径"></a>TRACE：追踪路径</h3><p>用于让 Web 服务器端将之前的请求通信环回给客户端：发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。</p><p>客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的。</p><h3 id="CONNECT：要求用隧道协议建立连接"><a href="#CONNECT：要求用隧道协议建立连接" class="headerlink" title="CONNECT：要求用隧道协议建立连接"></a>CONNECT：要求用隧道协议建立连接</h3><p>要求使用隧道协议进行 TCP 通信，主要使用 SSL 和 TLS 协议将通信内容加密后经网络隧道传输</p><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p>原始版本的 HTTP 每进行一次通信就断开一次 TCP 连接，增加通信开销。</p><p>为解决这一问题，提出持久连接概念：只要任意一端没有断开连接，就保持 TCP 连接状态。</p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>持久连接使得多数请求以管线化方式发送成为可能：从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p><h2 id="使用-Cookie-的状态管理"><a href="#使用-Cookie-的状态管理" class="headerlink" title="使用 Cookie 的状态管理"></a>使用 Cookie 的状态管理</h2><p>HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。</p><p>为解决这一问题，引入 Cookie 技术，其通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><p>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p><img src="https://s2.loli.net/2021/12/15/YtkPxg9JSZ31R8H.png"></p><p><img src="https://s2.loli.net/2021/12/15/Cz9DGFfMOacgxTp.png"></p><h1 id="HTTP-报文内的-HTTP-信息"><a href="#HTTP-报文内的-HTTP-信息" class="headerlink" title="HTTP 报文内的 HTTP 信息"></a>HTTP 报文内的 HTTP 信息</h1><h2 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h2><p>HTTP 报文结构：</p><p><img src="https://s2.loli.net/2021/12/16/tqIHo8AYBcSEZwd.png"></p><p>请求报文与响应报文的结构：</p><p><img src="https://s2.loli.net/2021/12/16/51c9ZP2sHVdW7qi.png"></p><ul><li><p>请求行</p><p> 包含用于请求的方法，请求 URI 和 HTTP 版本</p></li><li><p>状态行</p><p> 包含表明响应结果的状态码，原因短语和 HTTP 版本</p></li><li><p>首部字段</p><p> 包含表示请求和响应的各种条件和属性的各类首部，共有四种：通用首部、请求首部、响应首部和实体首部。</p></li><li><p>其他<br> 可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。</p></li></ul><h2 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h2><ul><li><p>报文</p><p> HTTP 通信中的基本单位，由8位组字节流组成，通过 HTTP 通信传输</p></li><li><p>实体</p><p> 作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成</p></li></ul><h3 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h3><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。</p><h3 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h3><p>在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked TransferCoding）。</p><p>分块传输编码将实体主体分为多个块，每块用十六进制标记大小，最后一块用 <code>0(CR+LF)</code> 标记</p><h2 id="多部分对象集合"><a href="#多部分对象集合" class="headerlink" title="多部分对象集合"></a>多部分对象集合</h2><p>HTTP 协议中采纳了MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制中的多部分对象集合，用于发送多种数据，其发送的一份报文主体内可含有多类型实体</p><p>在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上 <code>Content-type</code></p><h2 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h2><p>指定所下载的实体范围，如对一份 10000 字节大小的资源，如果使用范围请求，可以只请求5001~10000 字节内的资源。</p><p>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。</p><h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p>当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商（Content Negotiation）。</p><p>有三种类型：</p><ul><li><p>服务器驱动协商</p><p> 由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。</p></li><li><p>客户端驱动协商</p><p>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。</p></li><li><p>透明协商</p><p>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</p></li></ul><h1 id="返回结果的-HTTP-状态码"><a href="#返回结果的-HTTP-状态码" class="headerlink" title="返回结果的 HTTP 状态码"></a>返回结果的 HTTP 状态码</h1><p>HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。</p><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><p>状态码的类别：</p><p><img src="https://s2.loli.net/2021/12/16/1lQ4cefb7WrOuCS.png"></p><h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul><li><p>200 OK</p><p> 表示从客户端发来的请求在服务器端被正常处理了。</p></li><li><p>204 No Content</p><p>服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。</p><p>一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p></li><li><p>206 Partial Content</p><p>表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。</p></li></ul><h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p><ul><li><p>301 Moved Permanently</p><p> 该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。</p></li><li><p>302 Found</p><p>临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。</p><p>和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。</p></li><li><p>303 See Other</p><p>表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</p></li><li><p>304 Not Modified</p><p>表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。</p></li><li><p>307 Temporary Redirect</p><p>临时重定向。该状态码与 302 Found 有着相同的含义。</p></li></ul><h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><p>响应结果表明客户端是发生错误的原因所在。</p><ul><li><p>400 Bad Request</p><p>表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。</p></li><li><p>401 Unauthorized</p><p>表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。</p></li><li><p>403 Forbidden</p><p>表明对请求资源的访问被服务器拒绝了。</p></li><li><p>404 Not Found</p><p>表明服务器上无法找到请求的资源。</p></li></ul><h2 id="5XX-Service-Unavailable"><a href="#5XX-Service-Unavailable" class="headerlink" title="5XX Service Unavailable"></a>5XX Service Unavailable</h2><p>表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p><h1 id="与-HTTP-协作的-Web-服务器"><a href="#与-HTTP-协作的-Web-服务器" class="headerlink" title="与 HTTP 协作的 Web 服务器"></a>与 HTTP 协作的 Web 服务器</h1><h2 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h2><p>允许一台 HTTP 服务器搭建多个 Web 站点。但是域名需经过 DNS 服务映射到 IP 地址，如果一台服务器内托管了两个域名，其 IP 地址会相同。</p><p><img src="https://s2.loli.net/2021/12/16/pEtCnQYyvfWDgUj.png"></p><p>在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。</p><h2 id="通信数据转发程序：代理、网关、隧道"><a href="#通信数据转发程序：代理、网关、隧道" class="headerlink" title="通信数据转发程序：代理、网关、隧道"></a>通信数据转发程序：代理、网关、隧道</h2><p>HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI ，会直接发送给前方持有资源的目标服务器。</p><p>持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。</p><p>每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息：</p><p><img src="https://s2.loli.net/2021/12/16/exRc15jy9EMz2KF.png"></p><p><strong>使用代理服务器的目的：</strong><br>利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。</p><p>代理有多种使用方法，按两种基准分类：是否使用缓存和是否会修改报文：</p><ul><li><p>缓存代理</p><p>代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。</p><p>当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。 </p></li><li><p>透明代理</p><p>转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。</p></li></ul><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务：</p><p><img src="https://s2.loli.net/2021/12/16/d1IwOZFy2XCrWzT.png"></p><p>利用网关能够提高通信的安全性，因为可以在客户端和网关之间的通信链路上加密以确保连接的安全。</p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>隧道可按要求建立起一条与其他服务器的通信链路，届时适用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</p><p>隧道本身不会去解析 HTTP 请求，也就是说请求原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p><h2 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h2><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可以减少对源服务器的访问，因此也就节省了通信流量和通信时间。</p><p>缓存服务器是代理服务器的一种，并归类在缓存代理类型中。也就是说，当代理转发从服务器返回的响应时，代理服务器会保存一份资源的副本。</p><p><img src="https://s2.loli.net/2021/12/19/5PnSaDpiNk1F8so.png"></p><p>优势：利用缓存能够避免多次从源服务器转发资源，因此客户端能够就近从缓存服务器上获取资源，源服务器也不必再处理相同请求</p><h3 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a>缓存的有效期限</h3><p>即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。</p><p>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，则缓存服务器会在源服务器上获取资源。</p><h3 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h3><p>缓存还可以存在客户端浏览器中，如 IE 将客户端缓存称为临时网络文件。浏览器缓存若有效，就不必向服务器请求相同资源了，而是直接从本地磁盘读取。</p><p>和缓存服务器相同的一点是当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。</p><h1 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h1><p>HTTP 协议的请求和响应报文中必定包含 HTTP 首部</p><h2 id="HTTP-报文首部"><a href="#HTTP-报文首部" class="headerlink" title="HTTP 报文首部"></a>HTTP 报文首部</h2><p>首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。报文首部由几个字段构成：</p><p><strong>请求报文</strong><br>在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。</p><p><img src="https://s2.loli.net/2021/12/19/tZ1VJBAGyqo9rQi.png"></p><p><strong>响应报文</strong><br>在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段 3 部分构成。</p><p><img src="https://s2.loli.net/2021/12/19/gj4KPRHTimE8qJN.png"></p><h2 id="HTTP-首部字段"><a href="#HTTP-首部字段" class="headerlink" title="HTTP 首部字段"></a>HTTP 首部字段</h2><p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p><h3 id="首部字段结构"><a href="#首部字段结构" class="headerlink" title="首部字段结构"></a>首部字段结构</h3><p>HTTP 首部字段是由首部字段名和字段值构成的：<code>首部字段名：字段值</code></p><p>如：<code>Content-Type: text/html</code></p><ul><li><p>若 HTTP 首部字段重复了会如何</p><p>这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。</p></li></ul><h3 id="4-种首部字段类型"><a href="#4-种首部字段类型" class="headerlink" title="4 种首部字段类型"></a>4 种首部字段类型</h3><ul><li><p>通用首部字段</p><p>请求与响应都会适用的首部</p></li><li><p>请求首部字段</p><p>从客户端向服务器端发送请求报文时使用的首部。</p></li><li><p>响应首部字段</p><p>从服务器端向客户端返回响应报文时使用的首部。</p></li><li><p>实体首部字段</p><p>针对请求报文和响应报文的实体部分使用的首部。</p></li></ul><h2 id="HTTP-1-1-通用首部字段"><a href="#HTTP-1-1-通用首部字段" class="headerlink" title="HTTP/1.1 通用首部字段"></a>HTTP/1.1 通用首部字段</h2><p>通用首部字段是指，请求报文和响应报文双方都会使用的首部。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>通过指定 Cache-Control 的指令，能够操作缓存的工作机制。</p><p>表示是否能执行缓存：public/private/no-cache</p><p>控制可执行缓存的对象的指令: no-store (指定机密信息)</p><p>指定缓存期限和认证的指令：s-maxage、max-age</p><ul><li>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。</li><li>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。</li></ul><p>以及<code>min-fresh</code>、<code>max-stale</code>、<code>only-if-cache</code>、<code>must-revalidate</code>、<code>proxy-revalidate</code>、<code>no-transform</code></p><h3 id="Connetion"><a href="#Connetion" class="headerlink" title="Connetion"></a>Connetion</h3><p>具备两个功能：</p><ul><li>控制不再转发给代理的首部字段</li><li>管理持久连接</li></ul><h1 id="确保-Web-安全的-HTTPS"><a href="#确保-Web-安全的-HTTPS" class="headerlink" title="确保 Web 安全的 HTTPS"></a>确保 Web 安全的 HTTPS</h1><p>在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用HTTPS 通信机制可以有效地防止这些问题。</p><h2 id="HTTP-的缺点"><a href="#HTTP-的缺点" class="headerlink" title="HTTP 的缺点"></a>HTTP 的缺点</h2><ul><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ul><h2 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+加密+认证+完整性保护=HTTPS"></a>HTTP+加密+认证+完整性保护=HTTPS</h2><h3 id="HTTPS-是身披-SSL-外壳的-HTTP"><a href="#HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="HTTPS 是身披 SSL 外壳的 HTTP"></a>HTTPS 是身披 SSL 外壳的 HTTP</h3><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p><p>通常，HTTP 直接和 TCP 通信。当使用 SSL时，则演变成先和 SSL通信，再由 SSL和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披SSL协议这层外壳的 HTTP。</p><p><img src="https://s2.loli.net/2021/12/19/W6xKerZO7HENL4g.png"></p><p>SSL是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL协议使用。可以说 SSL是当今世界上应用最为广泛的网络安全技术。</p><h3 id="相互交换密钥的公开密钥加密技术"><a href="#相互交换密钥的公开密钥加密技术" class="headerlink" title="相互交换密钥的公开密钥加密技术"></a>相互交换密钥的公开密钥加密技术</h3><p>SSL采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。</p><ul><li><p>共享密钥加密</p><p>加密和解密同用一个密钥的方式称为共享密钥加密（Common keycrypto system），也被叫做对称密钥加密。</p></li><li><p>公开密钥加密</p><p>使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</p><p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p><p>要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。</p></li><li><p>HTTPS 采用混合加密机制</p><p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。</p><p>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p></li></ul><p><img src="https://s2.loli.net/2021/12/19/IVdhB8jswnoflAg.png"></p><h3 id="证明公开密钥正确性的证书"><a href="#证明公开密钥正确性的证书" class="headerlink" title="证明公开密钥正确性的证书"></a>证明公开密钥正确性的证书</h3><p>遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。</p><p>为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。</p><p>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。</p><p>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p><h3 id="HTTPS-的安全通信机制"><a href="#HTTPS-的安全通信机制" class="headerlink" title="HTTPS 的安全通信机制"></a>HTTPS 的安全通信机制</h3><p>应用层发送数据时会附加一种叫做 MAC（MessageAuthentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p><ul><li><p>SSL 和 TLS</p><p>HTTPS 使用 SSL 和 TLS 两个协议。当使用 SSL时，HTTPS 的处理速度会变慢。</p><p>SSL的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢。</p></li><li><p>为什么不一直使用 HTTPS</p><p>与纯文本通信相比，加密通信会消耗更多的CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。</p><p>想要节约购买证书的开销也是原因之一。</p></li></ul><h1 id="确认访问用户身份的认证"><a href="#确认访问用户身份的认证" class="headerlink" title="确认访问用户身份的认证"></a>确认访问用户身份的认证</h1><h2 id="何为认证"><a href="#何为认证" class="headerlink" title="何为认证"></a>何为认证</h2><p>计算机本身无法判断坐在显示器前的使用者的身份。进一步说，也无法确认网络的那头究竟有谁。可见，为了弄清究竟是谁在访问服务器，就得让对方的客户端自报家门、需要核对“登录者本人才知道的信息”、“登录者本人才会有的信息”。</p><p>如：密码、动态令牌、数字证书、生物认证、IC 卡等</p><p>HTTP 采用的认证方式包括：</p><ul><li>BASIC 认证（基本认证）</li><li>DIGEST 认证（摘要认证）</li><li>SSL 客户端认证</li><li>FormBase 认证（基于表单认证）</li></ul><h2 id="BASIC-认证"><a href="#BASIC-认证" class="headerlink" title="BASIC 认证"></a>BASIC 认证</h2><p>Web 服务器与通信客户端之间进行的认证方式。使用上不够便捷灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用。</p><h2 id="DIGEST-认证"><a href="#DIGEST-认证" class="headerlink" title="DIGEST 认证"></a>DIGEST 认证</h2><p>同样使用质询 / 响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。</p><p>所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p><h2 id="SSL-客户端认证"><a href="#SSL-客户端认证" class="headerlink" title="SSL 客户端认证"></a>SSL 客户端认证</h2><h3 id="SSL-客户端认证采用双因素认证"><a href="#SSL-客户端认证采用双因素认证" class="headerlink" title="SSL 客户端认证采用双因素认证"></a>SSL 客户端认证采用双因素认证</h3><p>在多数情况下，SSL客户端认证不会仅依靠证书完成认证，一般会和基于表单认证（稍后讲解）组合形成一种双因素认证（Two-factor authentication）来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。</p><p>第一个认证因素的 SSL客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为。</p><h2 id="基于表单认证"><a href="#基于表单认证" class="headerlink" title="基于表单认证"></a>基于表单认证</h2><p>基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。</p><h1 id="基于-HTTP-的功能追加协议"><a href="#基于-HTTP-的功能追加协议" class="headerlink" title="基于 HTTP 的功能追加协议"></a>基于 HTTP 的功能追加协议</h1><p>HTTP 功能上的不足可通过创建一套全新的协议来弥补。可是目前基于 HTTP 的 Web 浏览器的使用环境已遍布全球，因此无法完全抛弃 HTTP。有一些新协议的规则是基于 HTTP 的，并在此基础上添加了新的功能。</p><h2 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h2><p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。</p><p>SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方法、ookie 以及 HTTP 报文等。</p><p>使用 SPDY 后，HTTP 协议额外获得以下功能。</p><ul><li><p>多路复用流</p><p>通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。</p></li><li><p>赋予请求优先级</p><p>SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</p></li><li><p>压缩 HTTP 首部</p><p>压缩 HTTP 请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。</p></li><li><p>推送功能</p><p>支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</p></li><li><p>服务器提示功能</p><p>服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。</p></li></ul><h2 id="使用浏览器进行全双工通信的-WebSocket"><a href="#使用浏览器进行全双工通信的-WebSocket" class="headerlink" title="使用浏览器进行全双工通信的 WebSocket"></a>使用浏览器进行全双工通信的 WebSocket</h2><p>WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据。</p><p>由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><p>目标是改善用户在使用 Web 时的速度体验。</p><p>主要协议：</p><ul><li><p>SPDY</p></li><li><p>HTTP Speed ＋ Mobility</p><p>由微软公司起草，是用于改善并提高移动端通信时的通信速度和性能的标准。它建立在 Google 公司提出的 SPDY 与 WebSocket 的基础之上。</p></li><li><p>Network-Friendly HTTP Upgrade</p><p>主要是在移动端通信时改善 HTTP 性能的标准。</p></li></ul><h2 id="Web-服务器管理文件的-WebDAV"><a href="#Web-服务器管理文件的-WebDAV" class="headerlink" title="Web 服务器管理文件的 WebDAV"></a>Web 服务器管理文件的 WebDAV</h2><p>WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Envoy基础</title>
      <link href="/2023/11/16/envoy-ji-chu/"/>
      <url>/2023/11/16/envoy-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="Envoy是什么？"><a href="#Envoy是什么？" class="headerlink" title="Envoy是什么？"></a>Envoy是什么？</h2><p>Envoy 是一个用 C++ 开发的高性能代理，Envoy 是一种 L7 代理和通信总线，专为大型的现代面向服务的架构而设计。官网为<a href="https://www.envoyproxy.io/">https://www.envoyproxy.io/</a>, 其为开源项目，源码 github地址为:<a href="https://github.com/envoyproxy/envoy%E3%80%82">https://github.com/envoyproxy/envoy。</a><br><img src="https://seeklogo.com/images/E/envoy-proxy-logo-AA21B06AE5-seeklogo.com.png"></p><h2 id="Envoy提供的功能？"><a href="#Envoy提供的功能？" class="headerlink" title="Envoy提供的功能？"></a>Envoy提供的功能？</h2><p>网络对于应用程序来说应该是透明的，当网络和应用程序出现问题时，应该很容易确定问题的源头。当然要实现上述目标是非常困难的。Envoy 试图通过提供以下高级功能来实现这一目标:</p><ul><li><b>非侵入架构:</b> Envoy 是一个独立的进程，设计为伴随每个应用程序服务一起运行。所有 Envoy 实例形成一个透明的通信网格，每个应用程序通过 localhost 发送和接收消息，不需要知道网络拓扑。对服务的实现语言也完全无感知，这种模式也被称为 Sidecar 模式。</li><li><b>L3/L4 过滤器架构:</b> Envoy 的核心是一个 L3/L4 层的网络代理。可插拔的过滤器链机制允许编写不同的 TCP/UDP 代理任务的过滤器，并将其插入到主服务器中。而且已经内置支持了各种任务的过滤器，例如原始 TCP 代理、UDP 代理、HTTP 代理、TLS 客户端证书身份验证、Redis、MongoDB、Postgres 等。</li><li><b>HTTP L7 过滤器架构:</b> HTTP 是现代应用程序架构的关键组件，因此 Envoy 支持了一个额外的 HTTP L7 过滤器层。HTTP 过滤器可以被插入到 HTTP 连接管理子系统中，执行不同的任务，如缓存、速率限制、路由/转发、嗅探 Amazon 的 DynamoDB 等。</li><li><b>顶级的 HTTP/2 支持:</b> 在 HTTP 模式下运行时，Envoy 同时支持 HTTP/1.1 和 HTTP/2。Envoy 可以作为透明的 HTTP/1.1 到 HTTP/2 双向代理运行。这意味着可以连接任何组合的 HTTP/1.1 和 HTTP/2 客户端与目标服务器。推荐的服务到服务配置在所有 Envoy 之间使用 HTTP/2 创建持久连接网格，请求和响应可以在该连接上进行多路复用。</li><li><b>HTTP/3 支持(目前处于 alpha 版):</b>从 Envoy 1.19.0 版本开始，Envoy 现在支持上游和下游的 HTTP/3，而且可以在任何方向上进行 HTTP/1.1、HTTP/2 和 HTTP/3 之间的转换。</li><li><b>HTTP L7 路由:</b>在 HTTP 模式下运行时，Envoy 支持路由子系统，该子系统能够根据路径、权限、内容类型、运行时值等路由和重定向请求。在使用 Envoy 作为前端/边缘代理时，此功能非常有用，但在构建服务到服务的网格时也可以利用它。</li><li><b>gRPC 支持:</b>gRPC 是 Google 的一个 RPC 框架，使用 HTTP/2 或更高版本作为底层多路复用传输。Envoy 支持用作 gRPC 请求和响应的路由和负载均衡基础所需的所有 HTTP/2 功能，这两个系统非常互补。</li><li><b>可观测性:</b>Envoy 的主要目标是使网络透明，可以生成许多流量方面的统计数据，这是其它代理软件很难取代的地方，内置 stats 模块，可以集成诸如 prometheus/statsd 等监控方案。还可以集成分布式追踪系统，对请求进行追踪。</li><li><b>服务发现和动态配置:</b>Envoy 可以选择使用一组分层的动态配置 API 来进行集中管理。这些层向 Envoy 提供了关于后端集群中的主机、后端集群自身、HTTP 路由、监听套接字和加密材料的动态更新。对于更简单的部署，可以通过 DNS 解析（甚至完全跳过）来完成后端主机发现，并且进一步的层可以由静态配置文件替代。</li><li><b>健康检查:</b>构建 Envoy 网格的推荐方法是将服务发现视为最终一致的过程。Envoy 包含一个健康检查子系统，可以选择对上游服务集群执行主动健康检查。然后，Envoy 使用服务发现和健康检查信息的结合来确定健康的负载均衡目标。Envoy 还通过异常值检测子系统支持被动健康检查。</li><li><b>高级负载均衡:</b>分布式系统中不同组件之间的负载均衡是一个复杂的问题。由于 Envoy 是一个独立的代理而不是库，因此可以独立实现高级负载均衡以供任何应用程序访问。目前 Envoy 支持自动重试、熔断、通过外部速率限制服务进行全局速率限制、异常检测等。</li><li><b>前端/边缘代理支持:</b>在边缘使用相同的软件有很大的好处（可观察性、管理、相同的服务发现和负载均衡算法等）。Envoy 的功能集使其非常适合作为大多数现代 Web 应用程序用例的边缘代理。这包括 TLS 终止、HTTP/1.1、HTTP/2 和 HTTP/3 支持以及 HTTP L7 路由。</li><li><b>最佳的可观测性:</b> 如上所述，Envoy 的主要目标是使网络透明化。但是，问题在网络层面和应用层面都可能会出现。Envoy 为所有子系统提供了强大的统计支持。目前支持的统计数据输出端是 statsd（以及兼容的提供程序），但是接入其他不同的统计数据输出端并不困难。统计数据也可以通过管理端口进行查看，Envoy 还支持通过第三方提供者进行分布式跟踪。</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li><b>Host:</b>Envoy 中主机是逻辑网络应用程序。一个物理硬件可能运行多个主机，只要每个主机可以独立进行寻址。</li><li><b>Downstream:</b>下游主机连接到 Envoy，发送请求并接收响应。</li><li><b>Upstream(上游):</b>上游主机接收来自 Envoy 的连接和请求并返回响应。</li><li><b>Listener(侦听器):</b>侦听器是一个带有名称的网络位置（例如端口、unix domain socket 等），下游客户端可以连接到该位置。Envoy 暴露一个或多个监听器，供下游主机连接。</li><li><b>Cluster(集群):</b>一个集群是一组逻辑上相似的上游主机，Envoy 连接到这些主机。Envoy 通过服务发现来发现集群的成员。它还可以通过主动健康检查来确定集群成员的健康状况。Envoy 根据负载均衡策略确定将请求路由到哪个集群成员。</li><li><b>Mesh(网格):</b>一组主机协同工作，提供一致的网络拓扑结构。在这里 Envoy Mesh 是指一组 Envoy 代理，它们构成了由多种不同服务和应用程序平台组成的分布式系统的消息传递基础。</li><li><b>Runtime configuration(运行时配置):</b>与 Envoy 一起部署的实时配置系统。可以更改配置设置，影响操作而无需重新启动 Envoy 或更改主要配置。</li><li><b>Listener filter：</b>Listener 使用 listener filter（监听器过滤器）来操作链接的元数据。它的作用是在不更改 Envoy 的核心功能的情况下，添加更多的集成功能。Listener filter 的 API 相对简单，因为这些过滤器最终是在新接受的套接字上运行。在链中可以互相衔接以支持更复杂的场景，例如调用速率限制。Envoy 已经包含了多个监听器过滤器。</li><li><b>Http Route Table:</b>HTTP 的路由规则，例如请求的域名，Path 符合什么规则，转发给哪个 Cluster。</li><li><b>Health checking:</b>健康检查会与 SDS 服务发现配合使用。但是，即使使用其他服务发现方式，也有相应需要进行主动健康检查的情况。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Envoy 架构图如下:<br><img src="https://jsdelivr.icloudnative.io/gh/yangchuansheng/imghosting/img/20200504160047.png"><br>Envoy 采用单进程多线程架构</p><p>一个独立的 primary 线程负责控制各种零散的协调任务，而一些 worker 线程则负责执行监听、过滤和转发任务。<br>一旦侦听器接受连接，该连接就会将其生命周期绑定到一个单独的 worker 线程。这使得 Envoy 的大部分工作基本上是单线程来处理的，只有少量更复杂的代码处理工作线程之间的协调。<br>通常情况下 Envoy 实现了 100% 非阻塞。对于大多数工作负载，我们建议将 worker 线程的数量配置为机器上的硬件线程数量。</p><ul><li><b>大致流程</b>：<br>Envoy 进程中运行着一系列 Inbound/Outbound 监听器（Listener），Inbound 代理入站流量，Outbound 代理出站流量。Listener 的核心就是过滤器链（FilterChain），链中每个过滤器都能够控制流量的处理流程。Envoy 接收到请求后，会先走 FilterChain，通过各种 L3/L4/L7 Filter 对请求进行处理，然后再路由到指定的集群，并通过负载均衡获取一个目标地址，最后再转发出去。其中每一个环节可以静态配置，也可以动态服务发现，也就是所谓的 xDS，这里的 x 是一个代词，是 lds、rds、cds、eds、sds 的总称，即服务发现，后 2 个字母 ds 就是 discovery service。</li><li><b>请求流程详解</b><ul><li>1.在工作线程上运行的 Envoy 监听器，接受来自下游的 TCP 连接。<br><img src="https://www.envoyproxy.io/docs/envoy/v1.22.6/_images/lor-listeners.svg"></li><li>2.监听过滤器链被创建并运行后。它可以提供 SNI 和 pre-TLS 信息。一旦完成后， 监听器将匹配网络过滤器链。每个监听器可能具有多个过滤器链，这些过滤器链是在目标 IP CIDR 范围、SNI、ALPN、源端口等的某种组合上匹配。传输套接字（在我们的例子中为 TLS 传输套接字）与此过滤器链相关联。<br><img src="https://www.envoyproxy.io/docs/envoy/v1.22.6/_images/lor-listener-filters.svg"></li><li>3.在进行网络读取时，TLS 传输套接字将从 TCP 连接读取的数据进行解密，以进行进一步处理。<br><img src="https://www.envoyproxy.io/docs/envoy/v1.22.6/_images/lor-transport-socket.svg"></li><li>4.网络过滤器链已创建并运行。与监听过滤器一样，Envoy 将通过 Network::FilterManagerImpl 实例化其过滤器工厂中的一系列网络过滤器。<br><img src="https://www.envoyproxy.io/docs/envoy/v1.22.6/_images/lor-network-filters.svg"><br>HTTP 最重要的过滤器是 HTTP 连接管理器，它是链中的最后一个网络过滤器。它负责创建 HTTP/2 编解码器并管理 HTTP 筛选器链。在我们的示例中，这是唯一的网络过滤器。一个使用多个网络过滤器的网络过滤器链的示例如下：<br><img src="https://www.envoyproxy.io/docs/envoy/v1.22.6/_images/lor-network-read.svg"><br>在响应路径上，以与请求路径相反的顺序执行网络筛选器链。<br><img src="https://www.envoyproxy.io/docs/envoy/v1.22.6/_images/lor-network-write.svg"></li><li>5.HTTP 连接管理器中的 HTTP/2 编解码器，对来自 TLS 连接的解密数据流进行解帧和解复用，使其成为若干独立的数据流。每个流处理一个请求和响应。</li><li>6.对于每个 HTTP 请求流，都会创建并运行一个 HTTP 过滤器链。该请求首先通过可以读取和修改请求的 CustomFilter。路由过滤器是最重要的 HTTP 过滤器，它位于 HTTP 过滤器链的末尾。在路由过滤器上调用 decodeHeaders 时，将选择路由和集群。数据流上的请求头被转发到该集群中的上游端点。路由过滤器通过从集群管理器中匹配到的集群获取 HTTP 连接池，以执行操作。<br><img src="https://www.envoyproxy.io/docs/envoy/v1.22.6/_images/lor-http-filters.svg"></li><li>7.执行集群特定的负载均衡以查找端点。通过检查集群的断路器，来确定是否允许新的数据流。如果端点的连接池为空或容量不足，则会创建到端点的新连接。</li><li>8.上游端点连接的 HTTP/2 编解码器，将请求流与通过单个 TCP 连接流，向上游的任何其他流，进行多路复用和帧化。</li><li>9.上游端点连接的 TLS 传输套接字，对这些字节进行加密，并将其写入上游连接的 TCP 套接字。<br><img src="https://www.envoyproxy.io/docs/envoy/v1.22.6/_images/lor-client.svg"></li><li>10.由请求头、可选的请求体和尾部组成的请求，在上游被代理，而响应在下游被代理。响应以与请求相反的顺序，通过 HTTP 过滤器，从路由器过滤器开始并通过自定义过滤器，然后再发送到下游。</li><li>11.当响应完成后，请求流将被销毁。请求后，处理程序将更新统计信息，写入访问日志并最终确定追踪 span。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Envoy 的核心在于对业务透明的请求拦截，Iptables 等将拦截后的流量转发到 Envoy，Envoy 对拦截的请求进行一定的安全访问控制、流量调度等。通过使用 Envoy，使开发者可以专注于应用功能的开发，而不用考虑复杂的网络通讯。</p><p>参考资料：<br>1.<a href="https://www.envoyproxy.io/">https://www.envoyproxy.io/</a><br>2.<a href="https://mp.weixin.qq.com/s?__biz=MzU4MjQ0MTU4Ng==&amp;mid=2247510233&amp;idx=1&amp;sn=ad8899b9cec7f8617a084ba4f2a5b998&amp;chksm=fdbaa7c4cacd2ed2e103c90e09a780b25955acdb087042434d05ddb0c1bb0089d187b1c12667&amp;scene=178&amp;cur_album_id=1616316605645258755#rd">https://mp.weixin.qq.com/s?__biz=MzU4MjQ0MTU4Ng==&amp;mid=2247510233&amp;idx=1&amp;sn=ad8899b9cec7f8617a084ba4f2a5b998&amp;chksm=fdbaa7c4cacd2ed2e103c90e09a780b25955acdb087042434d05ddb0c1bb0089d187b1c12667&amp;scene=178&amp;cur_album_id=1616316605645258755#rd</a></p>]]></content>
      
      
      <categories>
          
          <category> Envoy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Envoy </tag>
            
            <tag> 代理 </tag>
            
            <tag> 架构 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker镜像</title>
      <link href="/2023/11/16/docker-jing-xiang/"/>
      <url>/2023/11/16/docker-jing-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="如何将应用制作为-Docker-镜像？"><a href="#如何将应用制作为-Docker-镜像？" class="headerlink" title="如何将应用制作为 Docker 镜像？"></a>如何将应用制作为 Docker 镜像？</h2><ul><li><p>第一步: 编写应用程序,例如编写应用 app.py:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">import</span> os<br>app = Flask(__name__)<br>app.run(debug=<span class="hljs-literal">True</span>)<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">'/'</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, my first docker images! '</span> + os.getenv(<span class="hljs-string">"HOSTNAME"</span>) + <span class="hljs-string"><code class="language-hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">import</span> os<br>app = Flask(__name__)<br>app.run(debug=<span class="hljs-literal">True</span>)<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">'/'</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, my first docker images! '</span> + os.getenv(<span class="hljs-string">"HOSTNAME"</span>) + <span class="hljs-string">''</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>第二步: 编写Dockerfile</p><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs Dockerfile"><span class="hljs-comment"># syntax=docker/dockerfile:1</span><br><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.8</span>-slim-buster<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y procps vim apache2-utils &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> requirements.txt requirements.txt</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip3 install -r requirements.txt    </span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"python3"</span>, <span class="hljs-string">"-m"</span> , <span class="hljs-string">"flask"</span>, <span class="hljs-string">"run"</span>, <span class="hljs-string"><code class="language-hljs Dockerfile"><span class="hljs-comment"># syntax=docker/dockerfile:1</span><br><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.8</span>-slim-buster<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y procps vim apache2-utils &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> requirements.txt requirements.txt</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip3 install -r requirements.txt    </span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [ <span class="hljs-string">"python3"</span>, <span class="hljs-string">"-m"</span> , <span class="hljs-string">"flask"</span>, <span class="hljs-string">"run"</span>, <span class="hljs-string">"--host=0.0.0.0"</span>]</span><br></code></pre></td></tr></tbody></table></figure><p><em>说明：</em></p><ul><li>第一行 以 syntax 开头的是解析器注释，它与 Docker 构建镜像的工具 buildkit 相关，在一般情况，建议使用 docker/dockerfile:1,它代表始终指向最新的语法版本。</li><li>第二行 FROM 命令，表示使用官方仓库的 python:3.8-slim-buster 镜像作为基础镜像。这个镜像已经安装了 Python3 和 Pip3 等所有的 Python 相关的工具和包，可以直接使用。 </li><li>第三行 RUN 的含义是在镜像内运行指定的命令，为镜像安装了一些必要的工具。 </li><li>第四行 WORKDIR 的含义是镜像的工作目录，可以理解为后续所有的命令都将以此为基准路径。这样，就可以在后续的命令中使用相对路径而不是完整路径了。 </li><li>第五行 COPY 的含义是将本地的文件或目录复制到镜像内指定的位置。第一个参数代表本地文件或目录，第二个参数代表要复制到镜像内的位置。这里COPY 表示，将本地当前目录下的 requirements.txt 文件复制到镜像工作目录 /app 中，文件命名同样为 requirements.txt。 </li><li>第六行 RUN 的含义是在镜像里运行 pip3 安装 Python 依赖。请注意，这些依赖将会被安装在镜像里而不是本地。 </li><li>第七行 COPY 命令，它的含义是将当前目录所有的源代码复制到镜像的工作目录 /app 下，复制目录的语法和之前提到的复制文件是类似的。 </li><li>最后一行 CMD 的含义是镜像的启动命令。在一个 Dockerfile 中，只能有一个 CMD 命令，如果有多个，那么只有最后一个 CMD 命令会起作用。后面的参数表示运行 python3 命令所需要的参数。 在一些场景下，可能会看到另一种与 CMD 类似的命令:ENTRYPOINT。</li></ul></li><li><p>第三步：构建镜像</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">docker build -t hello-world-flask .<br></code></pre></td></tr></tbody></table></figure><p><em>参数说明：</em> -t 代表的是我们的镜像名; “.” ，这代表了构建镜像的上下文</p></li></ul><h2 id="如何在本地或服务端拉取、运行镜像启动服务、停止镜像停止服务？"><a href="#如何在本地或服务端拉取、运行镜像启动服务、停止镜像停止服务？" class="headerlink" title="如何在本地或服务端拉取、运行镜像启动服务、停止镜像停止服务？"></a>如何在本地或服务端拉取、运行镜像启动服务、停止镜像停止服务？</h2><ul><li>拉取镜像<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">docker pull xxx:latest<br></code></pre></td></tr></tbody></table></figure>其中: xxx 为镜像名称</li><li>查看并运行镜像<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">docker images #查看镜像<br>docker run -d -p 8000:5000 hello-world-flask:latest #运行镜像<br></code></pre></td></tr></tbody></table></figure><em>参数说明：</em><br>-d 代表“在后台运行容器”, 同时它会输出容器 ID, 这是运行容器的唯一标识。<br>-p 代表“将容器内的 5000 端口暴露到宿主机（本地的 8000 端口）”，这可以方便在本地进行访问。</li><li>查看运行的镜像并并进入镜像<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">docker ps #查看运行的镜像(即启动的服务)<br>docker exec -it 镜像id或镜像名称 id bash #进入镜像容器<br></code></pre></td></tr></tbody></table></figure><em>参数说明：</em><br>-it 的含义是“保持 STDIN 打开状态, 并且分配一个虚拟的终端（Terminal）”。可以简单理解为, 我们通过 SSH 登录到了容器内部, 在当前终端下运行的所有命令都是基于容器内的。</li><li>退出镜像容器并停止镜像(即服务):<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><code class="language-hljs shell">exit #退出镜像, 像退出 SSH 登录一样, 在容器的终端下执行 exit 命令退出, 返回宿主机也就是本机的终端。<br>docker stop 镜像id #停止镜像容器(即停止应用), 换言之, 镜像是一个同时包含业务应用和运行环境的“系统安装包”, 它需要运行起来之后才能提供服务, 运行后镜像的“实例化”称为容器（Container）。可以对同一个镜像实例化多次，产生多个独立的容器, 这些容器拥有不同的容器 ID, 不同的容器之间是相互隔离的。<br></code></pre></td></tr></tbody></table></figure></li></ul><h2 id="业务代码构建镜像总结"><a href="#业务代码构建镜像总结" class="headerlink" title="业务代码构建镜像总结"></a>业务代码构建镜像总结</h2><ul><li>1.使用 FROM 命令指定一个已经安装了特定编程语言编译工具的基础镜像。你可以在官方镜像仓库找到你所需的任何基础镜像。例如，对于 Java 而言，可以使用 eclipse-temurin:17-jdk-jammy，对于 Golang 而言，可以使用 golang:1.16-alpine。 </li><li>2.使用 WORKDIR 命令配置一个镜像的工作目录，如 WORKDIR /app。</li><li>3.使用 COPY 命令将本地目录的源码复制到镜像的工作目录下，例如 COPY 。 </li><li>4.使用 RUN 命令下载业务依赖，例如 pip3 install。如果是静态语言，那么要进一步编译源码生成可执行文件。 </li><li>5.最后，使用 CMD 命令配置镜像的启动命令，也就是将你的业务代码启动起来。<br>  实际上，不管是什么编程语言，构建镜像的方法都是大同小异的。这 5 个方法步骤可以满足我们构建容器镜像的基本要求。</li></ul><h2 id="如何与他人共享制作的镜像或者说他人如何拉取镜像去可启动服务？"><a href="#如何与他人共享制作的镜像或者说他人如何拉取镜像去可启动服务？" class="headerlink" title="如何与他人共享制作的镜像或者说他人如何拉取镜像去可启动服务？"></a>如何与他人共享制作的镜像或者说他人如何拉取镜像去可启动服务？</h2><p>把自己制作的镜像上传到 Docker 官方的镜像仓库或者某个仓库平台，就可以和其他人共享了。 为了能够上传镜像，你需要先注册一个 Docker Hub 的账号，并且使用 docker login 登录，这和我们使用的 Git 工具类似。接下来，使用 docke tag 重命名我们之前在本地构建的镜像。例如:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><code class="language-hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag hello-world-flask my_dockerhub_name/hello-world-flask</span><br></code></pre></td></tr></tbody></table></figure><p><em>注意：</em><br>        这里需要把 my_dockerhub_name 替换为你实际的 Docker Hub 账户名，也称为镜像仓库的名字。 然后，我们就可以使用 docker push 把本地的镜像上传到 Docker Hub 了。</p><pre class=" language-shell"><code class="language-shell">        $ docker push my_dockerhub_name/hello-world-flask     </code></pre><p>之后他人就可以直接 pull 制作的该镜像了。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> image构建 </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础</title>
      <link href="/2023/11/16/cao-zuo-xi-tong-ji-chu/"/>
      <url>/2023/11/16/cao-zuo-xi-tong-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h1><ol><li>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</li><li>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</li><li>操作系统的存在屏蔽了硬件层的复杂性。</li><li>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li></ol><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220216160222.png"></p><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="用户态和系统态"><a href="#用户态和系统态" class="headerlink" title="用户态和系统态"></a>用户态和系统态</h2><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ol><li>用户态：用户态运行的进程可以直接读取用户程序的数据。</li><li>系统态：系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li></ol><p>我们运行的程序基本都是运行在用户态，如果需要调用操作系统提供的内核态级别的功能的时候，就需要使用系统调用，通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p><p>系统调用按功能大致可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能；</li><li>文件管理。完成文件的读、写、创建及删除等功能；</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能；</li><li>进程通信。完成进程之间的消息传递或信号传递等功能；</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能</li></ul><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>操作系统在线程等待IO的时候，会阻塞当前线程，切换到其它线程，这样在当前线程等待IO的过程中，其它线程可以继续执行。当系统线程较少的时候没有什么问题，但是当线程数量非常多的时候，却产生了问题。<strong>一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间。</strong></p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220216162037.png"></p><p>协程刚好可以解决上述2个问题。协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</p><p>假如需要同时处理10000个读取数据库的任务，如果只用线程的话，需要10000个线程，但是加入协程之后，我们只需要启动100个线程，每个线程上运行100个协程。这样就显著减小了所需的开销。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220216163355.png"></p><h2 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别"></a>线程和协程的区别</h2><ul><li>线程和进程都是同步机制，而协程是异步机制。</li><li>线程是抢占式，而协程是非抢占式的。协程需要用户释放使用权切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。</li><li>一个线程可以有多个协程，一个进程也可以有多个协程。</li><li>协程不被操作系统内核管理，而完全是由程序控制。</li><li>线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但协程不会直接使用线程，协程直接利用的是执行器关联任意线程或线程池。</li><li>协程能保留上一次调用时的状态。</li></ul><h2 id="并发和并行有什么区别"><a href="#并发和并行有什么区别" class="headerlink" title="并发和并行有什么区别"></a>并发和并行有什么区别</h2><ul><li>并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器可以做到并发。比如有两个进程A和B，A运行一个时间片之后，切换到B，B运行一个时间片之后又切换到A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。</li><li>并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。</li></ul><h2 id="进程有哪几种状态"><a href="#进程有哪几种状态" class="headerlink" title="进程有哪几种状态"></a>进程有哪几种状态</h2><p>我们一般把进程大致分为 5 种状态</p><ul><li>创建状态(new) ：进程正在被创建，尚未到就绪状态。</li><li>就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li><li>运行状态(running) ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li><li>阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li>结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到。所以进程之间要交换数据，必须通过内核，在内核中开辟一块缓冲区。进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。</p><p>大概有七种常见的进程间通信方式。</p><h3 id="管道-匿名管道"><a href="#管道-匿名管道" class="headerlink" title="管道/匿名管道"></a>管道/匿名管道</h3><ul><li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</li><li>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)；</li><li>管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中；</li><li>一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li></ul><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220216165746.png"></p><h3 id="有名管道-FIFO"><a href="#有名管道-FIFO" class="headerlink" title="有名管道(FIFO)"></a>有名管道(FIFO)</h3><ul><li>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信；</li><li>有名管道严格遵循先进先出；</li><li>有名管道的名字存在于文件系统中，内容存放在内存中。</li></ul><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul><li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态；</li><li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程回复执行并传递给它为止；</li><li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul><li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示；</li><li>与管道（匿名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除；</li><li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。</li></ul><h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><ul><li>使得多个进程可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li><li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li><li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li></ul><h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h3><p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</p><p>为了获得共享资源，进程需要执行下列操作：</p><ol><li>创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。</li><li>等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。</li><li>挂出一个信号量：该操作将信号量的值加1，也称为V操作。</li></ol><h3 id="套接字（Socket）"><a href="#套接字（Socket）" class="headerlink" title="套接字（Socket）"></a>套接字（Socket）</h3><p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220216170627.png"></p><p>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p><h2 id="线程间的同步的方式"><a href="#线程间的同步的方式" class="headerlink" title="线程间的同步的方式"></a>线程间的同步的方式</h2><p>线程同步是两个或多个共享关键资源的线程的并发执行，应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p><ul><li>互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li><li>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li>事件(Event)： 用来通知线程有一些事件已发生，从而启动后继任务的开始。事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。</li></ul><h2 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h2><p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，这些就是进程的调度算法</p><ul><li>先到先服务(FCFS)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li>短作业优先(SJF)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li>时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li><li>多级反馈队列调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程。而多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</li><li>优先级调度 ：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li></ul><h2 id="什么是死锁，死锁的产生条件"><a href="#什么是死锁，死锁的产生条件" class="headerlink" title="什么是死锁，死锁的产生条件"></a>什么是死锁，死锁的产生条件</h2><p>多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为 <strong>死锁</strong>。</p><p>如果系统中以下四个条件同时成立，那么就能引起死锁：</p><ul><li>互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止；</li><li>占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有；</li><li>非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放；</li><li>循环等待：有一组等待进程 <code>{P0, P1,..., Pn}</code>，P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，……，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。</li></ul><h1 id="操作系统内存管理基础"><a href="#操作系统内存管理基础" class="headerlink" title="操作系统内存管理基础"></a>操作系统内存管理基础</h1><p>操作系统的内存管理主要负责内存的分配与回收，同时负责内存中的地址转换，即将逻辑地址转换成相应的物理地址</p><h2 id="常见的几种内存管理机制"><a href="#常见的几种内存管理机制" class="headerlink" title="常见的几种内存管理机制"></a>常见的几种内存管理机制</h2><p>内存管理机制可以简单分为连续分配管理方式和非连续分配管理方式这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如 <strong>页式管理</strong> 和 <strong>段式管理</strong>。</p><ul><li>块式管理：远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li><li>页式管理 ：把主存分为大小相等且固定的一页一页的形式，页的内存空间较小，相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。</li><li>段式管理 ： 页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段、子程序段、数据段和栈段。</li><li>段页式管理机制：段页式管理机制结合了段式管理和页式管理的优点，简单来说就是先把主存分为若干段，再将每段分为若干页，也就是说 段页式管理机制 中段与段之间以及段的内部都是离散的内存空间。</li></ul><p>页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。</p><blockquote><p>什么是逻辑地址和物理地址？</p><p>在计算机运行时，CPU是需要从内存中取数据来进行运算的，或者需要把一些数据存放到内存中的。如下图所示，左边是内存的结构图，右边是CPU，CPU和内存之间数据进行交互。为了使CPU知道把数据放到内存中的哪个位置，或者应该在内存中的哪个位置把数据取出来，提出了地址这一概念。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220216180122.png"></p><p>我们的程序分为了代码段和数据段，代码段是存放着要执行的指令，数据段存放着数据。图中所有数值的表示都是采用十六进制表示法表示的。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220216180206.png"></p><p>所以CPU从代码段开始取出指令，然后就开始执行指令，可以看到，CPU取出的第一条指令是 <code>mov ax, [0001]</code>，这条指令的意思就是把内存地址为[0001]上的数据取出来，放到AX寄存器中。其中的[0001]就是所谓的物理地址，一个绝对的固定的地址。</p><p>但是在实际加载中，不能确定操作系统将数据存放在哪个具体的物理地址，也就是说所需的数据很可能没有加载到[0001]这个地址，而是放在了[0003]，如下图所示</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220216180813.png"></p><p>在实际的执行过程中，会将<code>mov ax,[0001]</code>这条指令转换为<code>mov ax,[0000]</code>，其中的[0000]是偏移地址，而逻辑地址 = 偏移地址 + 段基址，段基址就说[0003]，从而能够得到正确的数据。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220216181022.png"></p><p>简单来说，我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p></blockquote><h2 id="快表和多级页表"><a href="#快表和多级页表" class="headerlink" title="快表和多级页表"></a>快表和多级页表</h2><p>在分页内存管理中，很重要的两点是：</p><ol><li>虚拟地址到物理地址的转换要快；</li><li>解决虚拟地址空间大，页表也会很大的问题。</li></ol><blockquote><p>现代操作系统都提供了一种内存管理的抽象，即虚拟内存（virtual memory）。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。</p></blockquote><h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>为了解决虚拟地址到物理地址的转换速度，操作系统在 页表方案 基础之上引入了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。</p><p>由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p><p>使用快表之后的地址转换流程是这样的：</p><ol><li>根据虚拟地址中的页号查找快表；</li><li>如果该页在快表中，直接从快表中读取相应的物理地址；</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><p>类似于 Redis</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了提高内存的空间性能，提出了多级页表的概念，但是提高空间性能是以浪费时间性能为基础的。因此，为了补充损失的时间性能，提出了快表（即 TLB）的概念。不论是快表还是多级页表实际上都利用到了程序的局部性原理。</p><h2 id="分页机制和分段机制的共同点和区别"><a href="#分页机制和分段机制的共同点和区别" class="headerlink" title="分页机制和分段机制的共同点和区别"></a>分页机制和分段机制的共同点和区别</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ol><li>分页机制和分段机制都是为了提高内存利用率，减少内存碎片；</li><li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li><li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li></ol><h2 id="什么是-CPU-寻址，为什么需要虚拟地址空间？"><a href="#什么是-CPU-寻址，为什么需要虚拟地址空间？" class="headerlink" title="什么是 CPU 寻址，为什么需要虚拟地址空间？"></a>什么是 CPU 寻址，为什么需要虚拟地址空间？</h2><p>现代处理器使用的是一种称为 虚拟寻址(Virtual Addressing) 的寻址方式。使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 内存管理单元（Memory Management Unit, MMU） 的硬件。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220216210909.png"></p><h3 id="为什么要有虚拟地址空间呢？"><a href="#为什么要有虚拟地址空间呢？" class="headerlink" title="为什么要有虚拟地址空间呢？"></a>为什么要有虚拟地址空间呢？</h3><p>没有虚拟地址空间的时候，程序都是直接访问和操作的都是物理内存。这样做的问题是：</p><ol><li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li><li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li></ol><p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p><p>通过虚拟地址访问内存有以下优势：</p><ul><li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li><li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li><li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li></ul><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h2><p>很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存，而这正是因为虚拟内存的存在。通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。</p><p>虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。虚拟内存的重要意义是 <strong>它定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间。</strong></p><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p><p>早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。</p><p>局部性原理表现在以下两个方面：</p><ul><li>时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li><li>空间局部性 ：一旦程序访问了某个存储单元，在不久之后，<strong>其附近的存储单元</strong>也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内。这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li></ul><p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。</p><p>虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——虚拟内存（又译作虚拟存储器）。</p><p>虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。</p><h2 id="虚拟内存的技术实现"><a href="#虚拟内存的技术实现" class="headerlink" title="虚拟内存的技术实现"></a>虚拟内存的技术实现</h2><p>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。 虚拟内存的实现有以下三种方式：</p><ul><li>请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li>请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li><li>请求段页式存储管理</li></ul><p>不管是哪种实现方式，一般都需要：</p><ol><li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li><li>缺页中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；</li><li>虚拟地址空间 ：逻辑地址到物理地址的变换。</li></ol><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>虚拟内存管理很重要的一个概念就是页面置换算法。</p><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断。</p><blockquote><p>缺页中断 就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p></blockquote><p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p><ul><li>OPT 页面置换算法（最佳页面置换算法） ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li><li>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法） : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li><li>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法） ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li><li>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法） : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li></ul><h1 id="几种-IO-模型"><a href="#几种-IO-模型" class="headerlink" title="几种 IO 模型"></a>几种 IO 模型</h1><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步和异步指的是一个执行流程中每个方法是否必须依赖前一个方法完成后才可以继续执行。同步指的是调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。异步指的是调用立刻返回，调用者不必等待方法内的代码执行结束，就可以继续后续的行为。</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞与非阻塞指的是单个线程内遇到同步等待时，是否在原地不做任何操作。</p><p>阻塞指的是遇到同步等待后，一直在原地等待同步方法处理完成。</p><p>非阻塞指的是遇到同步等待，不在原地等待，先去做其他的操作，隔断时间再来观察同步方法是否完成。</p><p>阻塞与非阻塞关注的是线程是否在原地等待。</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不作任何事情会造成不必要的线程开销。</p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求会被注册到多路复用器上，多路复用器轮询到有 I/O 请求就会进行处理。</p><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>异步非阻塞，AIO 引入了异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p><h2 id="什么是-IO-多路复用"><a href="#什么是-IO-多路复用" class="headerlink" title="什么是 IO 多路复用"></a>什么是 IO 多路复用</h2><p>为每个 IO 请求分配一个进程/线程的方式不现实，因此采用 IO 多路复用技术来使一个线程维护多个 socket</p><p>一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。</p><p>我们熟悉的 select/poll/epoll 内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件。</p><h2 id="select-poll"><a href="#select-poll" class="headerlink" title="select / poll"></a>select / poll</h2><p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将这个集合拷贝到操作系统内核里，让内核来检查是否有网络事件产生。</p><p>内核检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。</p><p>所以，对于 select 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。</p><p>poll 与 select 的差异在于，不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p><p>但是 poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll 通过两个方面，很好解决了 select/poll 的问题。</p><p>第一点，epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，每当向 epoll 对象添加一个新事件时，该事件都会被挂载到红黑树上。由于红黑树是一个高效的数据结构，时间复杂度为 O(logn)，通过对红黑树进行操作，避免了每次操作都需要传入整个 socket 集合，减少了内存分配。</p><p>第二点：epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p><p>采用 epoll 的方式，即使监听的 Socket 数量很多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。</p><p>epoll 支持两种事件触发模式，分别是边缘触发（edge-triggered，ET）和水平触发（level-triggered，LT）。</p><ul><li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</li><li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，目的是告诉我们有数据需要读取；</li></ul><p>举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式。</p><p>这就是两者的区别，水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。</p><h1 id="进程调度过程"><a href="#进程调度过程" class="headerlink" title="进程调度过程"></a>进程调度过程</h1><h2 id="进程调度类型与时机"><a href="#进程调度类型与时机" class="headerlink" title="进程调度类型与时机"></a>进程调度类型与时机</h2><p>进程调度，即按照某种算法从就绪队列中选择一个进程为其分配处理机。进程调度的时机又分为两种：</p><ol><li>主动放弃</li><li>被动放弃</li></ol><p>以及有三种情况不能进行进程调度与切换：</p><ol><li>在处理中断的过程中</li><li>进程在操作性内核程序临界区中</li><li>在院子操作过程中</li></ol><p>临界资源：一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源</p><p>临界区：访问临界资源的那段代码</p><p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪队列的 PCB 组成）</p><p>调度触发有两种类型，主动调度与被动调度，被动调度又被称为抢占式调度。</p><ol><li><p>非剥夺调度，即主动调度、非抢占方式，只允许进程主动放弃处理机。在运行过程中即使有更紧迫的任务到达，当前进程仍然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p><p>实现简单，系统开销小但是无法及时处理紧急任务</p></li><li><p>剥夺调度，即被动调度、抢占式调度。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更紧急的进程。</p><p>可以优先处理更紧急的进程，也可以实现各个进程按时间片轮流执行的功能。适合分时操作系统、实时操作系统</p></li></ol><h2 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h2><p>进程切换的过程主要完成了：</p><ol><li>对原来运行进程各种数据的保存；</li><li>对新进程各种数据的恢复<br>（如程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在 PCB 中）</li></ol><p>进程切换是有代价的，如果过于频繁地进行上下文切换，使系统大部分时间都花在了进程切换上，导致真正用于执行进程的时间减少，造成系统效率降低。</p><h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><p>在多道程序环境下,程序的执行属于并发执行，。为了使参与并发执行的每个程序都能独立地运行，在操作系统中有一个与之相配的数据结构，称为进程控制块.(Process Control Block,PCB)。</p><p>操作系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。这样，由程序段、相关的数据段和PCB三部分便构成了进程实体（又称进程映像）。一般情况下，我们把进程实体就简称为进程。例如，所谓创建进程就是创建进程中的PCB；而撤销进程就是撤销进程的PCB</p><h2 id="进程的基本状态及转换"><a href="#进程的基本状态及转换" class="headerlink" title="进程的基本状态及转换"></a>进程的基本状态及转换</h2><ol><li>就绪状态。等待 CPU</li><li>执行状态。进程已获cpu，程序正在执行。</li><li>阻塞状态。若处于执行状态的进程发生如IO，申请缓冲区失败，暂时无法继续执行的状态。此时引起进程调度，OS把处理机分配给另一个就绪进程，让受阻进程处于暂停状态。</li></ol><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><ol><li><p>申请空白 PCB</p></li><li><p>为新进程分配其运行所需的资源</p></li><li><p>初始化进程控制块<br>a. 初始化标识信息，将系统分配的标识符和父进程标识符填入新 PCB 中</p><p>b. 初始化处理机控制信息，使程序计数器指向程序入口地址，使栈顶指针指向栈顶</p><p>c. 初始化处理机控制信息，将其设为就绪或静止就绪状态</p></li><li><p>若进程就绪队列能够接纳新进程，则将其加入就绪队列</p></li></ol><h2 id="PCB-的作用"><a href="#PCB-的作用" class="headerlink" title="PCB 的作用"></a>PCB 的作用</h2><ol><li>作为独立运行基本单位的标志</li><li>能实现间断性运行方式</li><li>提供进程管理所需要的信息</li><li>提供进程调度所需要的信息</li><li>实现与其他进程的同步与通信</li></ol><h2 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h2><p>进程控制一般是由操作系统内核中的原语来实现的。操作系统内核包括一些与硬件紧密相关的模块(如中断处理程序)、各种常用设备的驱动程序以及运行频率较高的模块(如时钟管理、进程调度和许多模块所公用的一些基本操作) 将它们常驻内存。</p><p>这种安排的目的有：1.便于对这些软件进行保护，防止遭受其他应用程序的破坏；2.可以提高os的运行效率</p><h1 id="局部性原理-1"><a href="#局部性原理-1" class="headerlink" title="局部性原理"></a>局部性原理</h1><p>处理器在访问某些数据时，短时间内往往存在重复访问，某些数据和位置被访问的概率极大，大多数时间都只是在访问局部的数据</p><h2 id="时间局部性"><a href="#时间局部性" class="headerlink" title="时间局部性"></a>时间局部性</h2><p>同一个内存位置，在较短时间内被多次引用，这是因为程序内往往存在大量循环</p><h2 id="空间局部性"><a href="#空间局部性" class="headerlink" title="空间局部性"></a>空间局部性</h2><p>同一个内存位置，在空间维度看，其附近的内存位置能够被引用，这是因为很多数据在内存中都是连续存放的</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="计算机存储的层级结构"><a href="#计算机存储的层级结构" class="headerlink" title="计算机存储的层级结构"></a>计算机存储的层级结构</h3><p><img src="https://s2.loli.net/2022/05/20/OudBlmR3AMQhVrG.png"></p><p>由于局部性原理的存在，每一层只会有很少部分数据被频繁访问，可以把这部分数据从底层存储挪到高层，从而降低大部分数据的读取时间</p><h3 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h3><p>由于局部性的存在，部分数据可能被重复访问，因此可以把这部分数据缓存到像 Redis 这样的缓存数据库中</p><h3 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h3><p>写时复制。Linux 调用 fork 生成子进程时，子进程应该拥有与父进程一样的指令与数据，由于子进程可能对数据进行修改，为了避免污染父进程的数据，需要单独给子进程拷贝一份。为了效率，fork 时不会直接复制，而是等到子进程各段数据需要写入时才会复制一份给子进程，这就是 写时复制</p><p>这个是考虑到读写分布也是有局部性的，大部分时候只需要读而不需要写，写时复制的方式减少了大量不必要的复制。</p><h1 id="操作系统惊群问题"><a href="#操作系统惊群问题" class="headerlink" title="操作系统惊群问题"></a>操作系统惊群问题</h1><p>在高并发中，会产生惊群的主要有：</p><ul><li>accept 惊群</li><li>epoll 惊群<ul><li>fork 之前创建 epollfd</li><li>fork 之后创建 epollfd</li></ul></li><li>线程池惊群</li></ul><h2 id="accept-惊群"><a href="#accept-惊群" class="headerlink" title="accept 惊群"></a>accept 惊群</h2><p>所谓惊群效应指的是，对于操作系统而言，多个线程/进程在等待同一资源，每当资源可用，所有的线程都来竞争，最终造成后果是：</p><ol><li>系统对于用户线程进行频繁的无效调度与上下文切换，系统性能下降</li><li>为了确保只有一个线程能够获取资源，用户必须对资源操作进行加锁保护，从而进一步加大了系统开销</li></ol><p>操作系统中的惊群效应，最常见的是 socket 描述符的 accept 操作，当多个线程监听同一个端口时，实际上只会 accept 一次，因此会产生惊群。但是目前的操作系统内核已经基本解决了这一问题，当一个链接过来时，内核只会唤醒一个子进程出来 accept。</p><h2 id="epoll-惊群"><a href="#epoll-惊群" class="headerlink" title="epoll 惊群"></a>epoll 惊群</h2><p>主进程创建 socket、bind、listen 后，将该 socket 加入 epoll 中，然后 fork 出多个子进程，每个子进程都阻塞在 epoll_wait 上，如果有事件到来，则判断该事件是否是该 socket 上的事件，如果是，说明有新的连接到来，进行 accept 操作。</p><p>当新的连接到来时，每个阻塞在 epoll_wait 上的进程都会被唤醒，这就是 epoll 惊群。</p><p>为什么内核不处理 epoll 惊群呢？可能是，尽管 accept 只能被一个进程调用成功，但是 epoll 不一样，其监听的文件描述符，除了可能被 accept 调用外，还有可能是其他网络 IO 的，而其他 IO 事件是否只能由一个进程处理是不一定的，这是一个由用户决定的事情，例如可能一个文件会由多个进程来读写。因此，内核不处理 epoll 惊群。</p><h2 id="Nginx-如何处理惊群问题"><a href="#Nginx-如何处理惊群问题" class="headerlink" title="Nginx 如何处理惊群问题"></a>Nginx 如何处理惊群问题</h2><p>Nginx 利用 accept_mutex 锁来解决惊群问题。如果配置文件中没有开启 accept_mutex，那么所有的监听套接字都会加入每个子进程的 epoll 中，这样一个新的连接到来时，所有的子进程都会惊醒。</p><p>如果配置文件开启了 accept_mutex，则只有一个子进程会将监听套接字添加到 epoll 中，这样当一个新的连接到来时，就只有一个 worker 子进程会被唤醒了。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>accept 不会有惊群，epoll_wait 才会</li><li>Nginx 的 accept_mutex 解决 epoll_wait 的惊群问题</li><li>Nginx 并不是解决惊群问题，而是控制是否将监听套接字加入 epoll 中。当监听套接字只在一个子进程的 epoll 中，新的连接来到时，其他子进程当然不会惊醒了。</li></ul><h1 id="高效并发模式-——-半同步-半异步模式"><a href="#高效并发模式-——-半同步-半异步模式" class="headerlink" title="高效并发模式 —— 半同步/半异步模式"></a>高效并发模式 —— 半同步/半异步模式</h1><p>如果程序的 I/O 密集型的，当程序阻塞于 I/O 操作将浪费大量 CPU 时间，因此需要高效的并发模式。</p><h2 id="半同步-半异步模型"><a href="#半同步-半异步模型" class="headerlink" title="半同步/半异步模型"></a>半同步/半异步模型</h2><p>半同步/半异步模型主要分为三层：异步 IO 层 + 队列层 + 同步处理层。</p><p>该模型一般包括一个 IO 线程和多个工作线程。IO 线程可以是主线程，负责异步地从客户端文件描述符获取客户端的请求数据，而工作线程并发地对该数据进行处理。工作线程不关心通信，IO 线程不关心处理过程。</p><p>从 IO 线程到工作线程之间依靠队列来交换数据，这也是利用了软件工程的经典思想，就是引入一个中间层。</p><h3 id="异步-IO-与同步处理"><a href="#异步-IO-与同步处理" class="headerlink" title="异步 IO 与同步处理"></a>异步 IO 与同步处理</h3><p>所谓异步，指的是在接收客户端连接，获取请求数据，以及向队列中写入数据时是异步的。在写入完成时可能会执行预设的回调函数，进行预处理和其他通知操作，也就是 proactor 模式。</p><p>所谓同步，指的是一个客户端连接的一次请求，其具体处理过程，也就是业务逻辑是同步的。虽然在消费队列的时候是多线程，但是并不会多个线程并行处理一次请求。</p><p>综上，也就是说当一个客户端发送请求的时候，整个服务端的逻辑被一分为二了。第一部分，接收请求数据的异步的；第二部分，在收完数据之后的处理逻辑是同步的。因此被称为 半同步半异步。</p><h3 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h3><p>返回数据的实现方式可以有很多，例如在工作线程中，处理完成之后直接在工作线程给客户端发送数据；或者再加一个写入队列，将返回数据和客户端信息，例如文件描述符，一同放入该队列。</p><h2 id="半同步半反应堆"><a href="#半同步半反应堆" class="headerlink" title="半同步半反应堆"></a>半同步半反应堆</h2><p>用 IO 多路复用代替异步 IO，对半同步半异步模型进行改造，就是 半同步半反应堆模型</p><p>开始时，Polling API (如 select/poll/epoll) 只监听服务端 socket，当监测到服务端 socket 可读时，就会进行 accept，获得客户端 socket 放入队列。也就是说，与半同步半异步模型不同的是，该模型的队列中存放的不是请求数据，而是 socket。工作线程从队列中取的不是模型，而是客户端 socket。工作线程从队列获得 socket 后，对 socket 进行 read/recv 获取请求数据，之后进行处理，然后之间 wirte/send 给客户端 socket，将数据返回客户端。</p><p>由此可见，这种 IO 方式是一种 Reactor 模式，也是半反应堆这个名字的由来。</p><h2 id="领导者追随者模式"><a href="#领导者追随者模式" class="headerlink" title="领导者追随者模式"></a>领导者追随者模式</h2><p>若干个线程组成一个线程池，其中一个线程作为领导者监听 IO 事件，其他线程睡眠，当有 IO 事件到来时，当前领导者从线程池中唤醒一个线程作为新的领导者来继续监听新的 IO 事件的到来，而原来的领导者转而去处理自己监听到的 IO 事件，在处理完毕之后加入到追随者中，直到再被选中成为领导者。</p><p>该模式最大的优点是，它是自己监听 IO 事件并处理请求，也就是说从接收到处理都是在同一线程中完成的，所以不需要在线程之间传递额外的数据，也不需要线程间同步对请求队列的访问。但是该模式的缺点也很明显，就是只支持一种事件源集合，这导致这种模式不能像上述模式一样，让每个线程独立管理多个客户端连接。</p><h1 id="线程模型-——-Reactor、Proactor"><a href="#线程模型-——-Reactor、Proactor" class="headerlink" title="线程模型 —— Reactor、Proactor"></a>线程模型 —— Reactor、Proactor</h1><h2 id="传统阻塞-IO-模型"><a href="#传统阻塞-IO-模型" class="headerlink" title="传统阻塞 IO 模型"></a>传统阻塞 IO 模型</h2><ol><li>采用阻塞式 IO 模型获取输入数据</li><li>每个连接都需要独立的线程完成数据输入、业务处理、数据返回的完成操作</li></ol><p>缺点：</p><ol><li>并发数大时，需要创建大量线程来处理连接，系统资源占用大</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程会被阻塞，造成资源浪费</li></ol><h2 id="Reactor-模型"><a href="#Reactor-模型" class="headerlink" title="Reactor 模型"></a>Reactor 模型</h2><p>针对上述的两个传统阻塞式 IO 模型的缺点，解决方案有：</p><ol><li>基于 IO 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可处理时，系统通知应用程序，线程从阻塞状态返回，开始业务处理；</li><li>基于线程池复用线程资源：不必为每个连接创建线程，将连接完成后的业务中的待处理任务分配给线程池中的线程进行处理，一个线程能够处理多个连接的业务。</li></ol><p>将 IO 复用与线程池相结合，就是 Reactor 模式</p><p>Reactor 模式，指的是，服务端程序处理传入的多路请求，并将这些请求同步分派给所对应的处理线程，即通过 IO 多路复用统一监听事件，收到事件后分发给某线程。</p><p>Reactor 模式中有 2 个关键组成：</p><ol><li>Reactor：在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应</li><li>Handlers：对要完成的 IO 实际事件进行执行</li></ol><p>Reactor 有三种典型实现：单 Reactor 单线程、单 Reactor 多线程、主从 Reactor 多线程</p><h3 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h3><ol><li>Reactor 对象通过 Select 监控客户端请求事件，收到事件后进行分发</li><li>如果是建立连接请求事件，由 Acceptor 通过 Accept 处理连接请求，并创建一个 Handler 对象处理连接完成后的后续业务</li><li>如果不是建立连接事件，则会分发调用对应的 Handler 来响应</li><li>Handler 会完成 read、业务处理、send 的流程</li></ol><p>优点：简单、没有多线程通信与竞争的问题，全部在一个线程中完成</p><p>缺点：性能差，只有一个线程；可靠性差</p><p>使用场景：客户端数量有限，业务处理快，如 Redis</p><h3 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h3><ol><li>Reactor 对象通过 Select 监控客户端请求事件，收到事件后进行分发</li><li>如果是建立连接请求事件，由 Acceptor 通过 Accept 处理连接请求，并创建一个 Handler 对象处理连接完成后的后续业务</li><li>如果不是建立连接事件，则会分发调用对应的 Handler 来响应</li><li>Handler 只负责响应事件，不做具体业务处理，通过 read 读取数据之后，会分发给后面的 worker 线程池进行业务处理</li><li>worker 线程池分配独立线程完成业务处理，并将响应结果发给 Handler</li><li>Handler 收到结果后 send 给客户端</li></ol><p>优点：充分利用了多核 CPU 的处理能力</p><p>缺点：多线程数据共享与访问复杂；Reactor 承担所有事件的监听与响应，高并发下性能较差</p><h3 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h3><ol><li>Reactor 主线程通过 Select 监控建立连接请求事件，由 Acceptor 通过 Accept 处理连接请求</li><li>Acceptor 处理连接请求后，MainReactor 将连接分配给 Reactor 子线程 SubReactor 进行处理</li><li>SubReactor 将连接加入队列进行监听，并创建一个 Handler 对象处理连接完成后的后续业务</li><li>当有新的事件发生时，SubReactor 会调用连接对应的 Handler 进行响应</li><li>Handler 通过 read 读取数据之后，会分发给后面的 worker 线程池进行业务处理</li><li>worker 线程池分配独立线程完成业务处理，并将响应结果发给 Handler</li><li>Handler 收到结果后 send 给客户端</li></ol><p>优点：父线程与子线程数据交互简单、职责明确，父线程只需要接收新连接，子线程完成后续业务处理。</p><p>应用：Nginx、Memcached、Netty</p><h2 id="Proactor-模型"><a href="#Proactor-模型" class="headerlink" title="Proactor 模型"></a>Proactor 模型</h2><p>Reactor 模型中，Reactor等待某个事件的发生，之后将这个事件传递给事先注册的 Handler，由后者来同步完成实际的读写操作。因此其是一个 同步非阻塞 的网络模型</p><p>如果将 IO 操作改为异步，就成为了异步网络模型 Proactor，其详细过程如下：</p><ol><li>Proactor Initiator 创建 Proactor 和 Handler 对象，并将其通过 AsyOptProcessor 注册到内核</li><li>Processor 处理注册请求，并完成 IO 操作</li><li>Processor 完成 IO 操作后通知 Proactor</li><li>Proactor 根据不同的事件类型回调不同的 Handler 完成业务处理</li></ol><h2 id="Proactor-与-Reactor-的区别"><a href="#Proactor-与-Reactor-的区别" class="headerlink" title="Proactor 与 Reactor 的区别"></a>Proactor 与 Reactor 的区别</h2><p>Reactor 是同步非阻塞模型，感知的是就绪可读写事件。在每次感知到有事件发生后，就需要应用进程主动调用 read 方法读取数据，也就是主动将 socket 接收缓存中的数据读入应用进程内存，这个过程是同步的，读取完成后应用进程才能处理数据。</p><p>Proactor 是异步非阻塞模型，感知的是已经完成了的读写事件。在发起异步读写请求时，需要传入数据缓冲区的地址(用来存放结果数据)等信息，这样系统内核才能够自动把数据读写工作完成。读写工作全程由操作系统来做，并不需要像 Reactor 那样还要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，会通知应用进程直接处理数据。</p><h2 id="Proactor-与-Reactor-的实现"><a href="#Proactor-与-Reactor-的实现" class="headerlink" title="Proactor 与 Reactor 的实现"></a>Proactor 与 Reactor 的实现</h2><p>在 Linux 中的异步 IO 是不完善的，AIO 系列函数是由 POSIX 定义的异步操作接口，并不是真正的操作系统级实现，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 AIO 操作，不支持网络编程中的 socket，所以 LINUX 一般使用 Reactor 方案</p><p>在 windows 中实现了一套完整的异步编程接口 IOCP，是真正意义上的异步 IO，所以 Windows 可以使用 Proactor 方案。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础</title>
      <link href="/2023/11/16/ji-suan-ji-wang-luo-ji-chu/"/>
      <url>/2023/11/16/ji-suan-ji-wang-luo-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络的分层参考模型"><a href="#计算机网络的分层参考模型" class="headerlink" title="计算机网络的分层参考模型"></a>计算机网络的分层参考模型</h1><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215151852.png"></p><p>自上而下介绍各层的作用：</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层 (application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。</p><blockquote><p>域名系统：可以将域名和 IP 地址相互映射的一个分布式数据库</p><p>HTTP 协议：所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p></blockquote><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>在物理层上所传送的数据单位是比特。</p><p>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异， 使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215154503.png"></p><h1 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h1><h2 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h2><p>为了准确地把数据送到目标处，TCP 协议采用了三次握手机制，其基本流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215154714.png"></p><ul><li>客户端发送带有 SYN 标志的数据包到服务端——一次握手</li><li>服务端发送带有 SYN/ACK 标志的数据包给客户端——二次握手</li><li>客户端发送带有 ACK 标志的数据包给服务端——三次握手</li></ul><p>详细流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215155907.png"></p><p>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</p><ul><li>TCP服务器进程先创建 <strong>传输控制块TCB</strong>，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li><li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文。报文首部中的同步位 SYN=1，同时选择一个初始序列号 seq=x，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。<strong>TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</strong></li><li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该置 ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。<strong>这个报文也不能携带数据，但是同样要消耗一个序号。</strong></li><li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。<strong>TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</strong></li><li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li></ul><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>三次握手的目的是建立可靠的通信信道，使通信双方确认自己与对方的发送与接收是正常的。</p><p>第一次握手：客户端什么都不能确认；服务端确认了对方发送正常，自己接收正常</p><p>第二次握手：客户端确认了：自己发送、接收正常，对方发送、接收正常；服务端确认了：对方发送正常，自己接收正常</p><p>第三次握手：客户端确认了：自己发送、接收正常，对方发送、接收正常；服务端确认了：自己发送、接收正常，对方发送、接收正常</p><h3 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？"></a>为什么TCP客户端最后还要发送一次确认呢？</h3><p>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>假如使用两次握手连接，假设这样的一个场景：<strong>客户端发送了第一个请求连接并且没有丢失，只是在网络结点中滞留的时间太长了。</strong> 由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接，完成了一次正常的通信。</p><p>然而此时，此前滞留的那一次请求连接的网络通畅了，到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h3 id="第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN？</h3><p>传回的 ACK 是为了向客户端确认服务端已经收到了客户端所发送的信号，表明从客户端到服务端的通信是正常的。而 SYN 则是为了建立并确认从服务端到客户端的通信。</p><blockquote><p>SYN 同步序列编号：是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h2 id="TCP-的四次挥手"><a href="#TCP-的四次挥手" class="headerlink" title="TCP 的四次挥手"></a>TCP 的四次挥手</h2><p>数据传输完毕后，通信双方都可释放连接。最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态，然后客户端主动关闭，服务器被动关闭。</p><ul><li>客户端进程发出连接释放报文，并且停止发送数据。FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。<strong>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</strong></li><li>服务器收到连接释放报文，发出确认报文。ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器方向的通信链路就释放了，这时候处于半关闭状态，即：客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。<strong>这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</strong></li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（<strong>在这之前还需要接受服务器发送的最后的数据</strong>）</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文。FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。<strong>注意此时TCP连接还没有释放，必须经过 2 ∗ MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</strong></li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。<strong>可以看到，服务器结束TCP连接的时间要比客户端早一些。</strong></li></ul><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215162846.png"></p><h3 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h3><ul><li>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失。站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次。而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</li><li>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li></ul><h3 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p><p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必已经将全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接。因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办</h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h1 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h1><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信）。</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><h1 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h1><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。（也就是所谓的，TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ 协议：</strong> 每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h2 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h2><p>即自动请求重传协议，是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p><h3 id="停止等待-ARQ-协议"><a href="#停止等待-ARQ-协议" class="headerlink" title="停止等待 ARQ 协议"></a>停止等待 ARQ 协议</h3><p>停止等待协议的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p><p>该方法的主要优点就是简单，但是缺点也非常明显，由于等待时间长，会使得信道利用率低。</p><h3 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p>该方法与停止等待协议相比，提高了信道利用率，并且容易实现。然而缺点就是不能向发送方反映出接收方已经正确收到的所有分组的信息。</p><blockquote><p>例如，发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p></blockquote><h3 id="重传类型"><a href="#重传类型" class="headerlink" title="重传类型"></a>重传类型</h3><p><strong>出现差错情况（超时重传）:</strong> 停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ 。</strong> 另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><p><strong>确认丢失和确认迟到：</strong> </p><ul><li><strong>确认丢失 ：</strong> 确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 重新发送确认消息。</li><li><strong>确认迟到：</strong> 确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li></ul><h2 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h2><p>TCP 利用滑动窗口实现流量控制。滑动窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p>假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215180509.png"></p><p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫累计确认或者累计应答。</p><h3 id="窗口的大小"><a href="#窗口的大小" class="headerlink" title="窗口的大小"></a>窗口的大小</h3><p>TCP 头里有一个字段叫 Window，也就是窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。因此，滑动窗口的大小通常是由接收方决定的。</p><h3 id="接收窗口和发送窗口的大小是相等的吗？"><a href="#接收窗口和发送窗口的大小是相等的吗？" class="headerlink" title="接收窗口和发送窗口的大小是相等的吗？"></a>接收窗口和发送窗口的大小是相等的吗？</h3><p>并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。</p><p>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p><h3 id="什么是流量控制？"><a href="#什么是流量控制？" class="headerlink" title="什么是流量控制？"></a>什么是流量控制？</h3><p>发送方不能无脑发数据给接收方，要考虑接收方处理能力。如果一直无脑发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p><p>为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫<strong>拥塞</strong>。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p><p>拥塞控制与流量控制的区别在于，拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><h2 id="什么是拥塞窗口"><a href="#什么是拥塞窗口" class="headerlink" title="什么是拥塞窗口"></a>什么是拥塞窗口</h2><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>拥塞窗口 cwnd 变化的规则：</p><ul><li>只要网络中没有出现拥塞，cwnd 就会增大；</li><li>但网络中出现了拥塞，cwnd 就减少。</li></ul><h2 id="拥塞控制有哪些控制算法？"><a href="#拥塞控制有哪些控制算法？" class="headerlink" title="拥塞控制有哪些控制算法？"></a>拥塞控制有哪些控制算法？</h2><p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。</p><h3 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h3><p>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</p><h3 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h3><p>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。然而当有多个数据信息包在某一段很短的时间内丢失时，该算法就不能很有效地工作。</p><h1 id="DNS-原理"><a href="#DNS-原理" class="headerlink" title="DNS 原理"></a>DNS 原理</h1><p>DNS 即域名系统，其是用于实现域名和 IP 地址相互映射的一个分布式数据库。其基本解析流程为：</p><ol><li><p>客户端输入域名，即由浏览器发起一个 DNS 解析请求，浏览器会首先在自己的缓存中查找 URL 对应的 IP 地址，如果缓存中没有，会进入下一步</p></li><li><p>通过计算机本地的 Host 文件配置，可以设置 URL 和 IP 地址之间的映射关系，因此会查找本地的 Host 文件，看是否有 IP 地址的缓存</p></li><li><p>如果仍然没有获得 IP 地址，会请求本地 DNS 服务器，通过本地运营商获取 URL 和 IP 的映射关系。由于本地 DNS 物理距离较近、性能较好，因此很快返回域名解析结果。</p></li><li><p>如果本地缓存服务器中找不到结果，则会首先向根服务器查询，根服务器中记录各个顶级域所在服务器的位置，例如向根服务器请求 .cn 时，根服务器会返回 .cn 服务器的位置信息</p></li><li><p>返回顶级域名服务器地址后，访问对应的服务器，并且返回 Name Server 服务器地址。所谓的 Name Server 就算网站注册的域名服务器，上面保存了 URL 和 对应的 IP 信息。</p></li><li><p>Name Server 会把指定域名的 A 记录或者 CNAME 返回给本地服务器，并且设置一个 TTL</p><p>A（Address）记录用来指定主机名对应的 IP 地址记录，CNAME 即别名记录，TTL 即 time to live，即过期时间</p></li><li><p>如果获取的是 A 记录，则可以直接访问，如果获取到的是 CNAME，那么会将其传给 GTM Server</p><p>GTM 即全局流量管理，传给 GTM 是希望通过其负载均衡机制，帮助用户找到最适合自己的服务器 IP 地址。</p></li><li><p>获得 IP 地址，进行访问。</p></li></ol><h1 id="在浏览器中输入-url-地址-显示主页的过程"><a href="#在浏览器中输入-url-地址-显示主页的过程" class="headerlink" title="在浏览器中输入 url 地址 ->> 显示主页的过程"></a>在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程</h1><p>总体来说分为以下几个过程:</p><ol><li>输入地址</li><li>浏览器查找域名的 IP 地址</li><li>浏览器向 web 服务器发送一个 HTTP 请求</li><li>服务器的永久重定向响应</li><li>服务器处理请求</li><li>服务器返回一个 HTTP 响应</li><li>浏览器显示 HTML</li><li>浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</li></ol><h2 id="输入地址"><a href="#输入地址" class="headerlink" title="输入地址"></a>输入地址</h2><p>当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google 的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p><h2 id="浏览器查找域名的-IP-地址"><a href="#浏览器查找域名的-IP-地址" class="headerlink" title="浏览器查找域名的 IP 地址"></a>浏览器查找域名的 IP 地址</h2><ol><li>查看本地硬盘的 hosts 文件：请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</li><li>查询本地DNS服务器：如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</li><li>本地服务器查询缓存：查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</li><li>查询根DNS服务器：如果根 DNS 服务器没有记录具体的域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。</li><li>查询域服务器：本地DNS服务器继续向域服务器发出请求，域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</li><li>向域名解析服务器发出请求：最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li></ol><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215222710.png"></p><h2 id="浏览器向-web-服务器发送一个-HTTP-请求"><a href="#浏览器向-web-服务器发送一个-HTTP-请求" class="headerlink" title="浏览器向 web 服务器发送一个 HTTP 请求"></a>浏览器向 web 服务器发送一个 HTTP 请求</h2><p>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有 httpd,nginx 等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。　</p><p>建立了TCP连接之后，发起一个http请求。一般的浏览器只能发起 GET 或者 POST 请求。客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：</p><ul><li>请求方法 URI 协议/版本</li><li>请求头(Request Header)</li><li>请求正文</li></ul><h2 id="服务器的永久重定向响应"><a href="#服务器的永久重定向响应" class="headerlink" title="服务器的永久重定向响应"></a>服务器的永久重定向响应</h2><p>服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问<a href="http://www.google.com/%E8%80%8C%E9%9D%9Ehttp://google.com/%E3%80%82">http://www.google.com/而非http://google.com/。</a></p><blockquote><p>301 和 302 状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。</p></blockquote><p>当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。</p><h2 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h2><p>后端服务器从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。</p><p>一些大一点的网站会将请求发送到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。</p><p>此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215230219.png"></p><p>通过 Nginx 的反向代理，我们就能够到达web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等</p><blockquote><p>客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。</p></blockquote><h2 id="服务器返回一个-HTTP-响应"><a href="#服务器返回一个-HTTP-响应" class="headerlink" title="服务器返回一个 HTTP 响应"></a>服务器返回一个 HTTP 响应</h2><p>经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p><ul><li>状态行</li><li>响应头</li><li>响应正文</li></ul><h2 id="浏览器显示-HTML"><a href="#浏览器显示-HTML" class="headerlink" title="浏览器显示 HTML"></a>浏览器显示 HTML</h2><p>在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，在此只介绍 webkit 的渲染过程，这个过程包括：</p><p>解析 html 以构建 dom 树 -&gt; 构建 render 树 -&gt; 布局 render 树 -&gt; 绘制 render 树</p><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。</p><p>DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为 reflow；当盒模型的位置，大小以及其他属性，如颜色，字体，等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。</p><p>页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</p><p>当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。</p><blockquote><p>JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我们平时的代码中，js是放在html文档末尾的。</p></blockquote><p>JS的解析是由浏览器中的JS解析引擎完成的，JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。</p><h2 id="浏览器发送请求获取嵌入在-HTML-中的资源"><a href="#浏览器发送请求获取嵌入在-HTML-中的资源" class="headerlink" title="浏览器发送请求获取嵌入在 HTML 中的资源"></a>浏览器发送请求获取嵌入在 HTML 中的资源</h2><p>其实这个步骤可以并列在上一步中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。</p><h2 id="整个过程使用到的协议"><a href="#整个过程使用到的协议" class="headerlink" title="整个过程使用到的协议"></a>整个过程使用到的协议</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215231218.png"></p><h1 id="HTTP-的状态码"><a href="#HTTP-的状态码" class="headerlink" title="HTTP 的状态码"></a>HTTP 的状态码</h1><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215231307.png"></p><h1 id="HTTP-的长连接与短连接"><a href="#HTTP-的长连接与短连接" class="headerlink" title="HTTP 的长连接与短连接"></a>HTTP 的长连接与短连接</h1><p>在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。</p><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p><h1 id="HTTP-是不保存状态的协议-那应该如何保存用户状态"><a href="#HTTP-是不保存状态的协议-那应该如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议, 那应该如何保存用户状态?"></a>HTTP 是不保存状态的协议, 那应该如何保存用户状态?</h1><p>HTTP 协议自身不对请求和响应之间的通信状态进行保存，因此提出了 Session 机制来解决这一问题。Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><h1 id="Cookie-的作用是什么-和-Session-有什么区别？"><a href="#Cookie-的作用是什么-和-Session-有什么区别？" class="headerlink" title="Cookie 的作用是什么? 和 Session 有什么区别？"></a>Cookie 的作用是什么? 和 Session 有什么区别？</h1><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p>Cookie 一般用来保存用户信息，例如已登录过的用户信息、单点登录功能的实现等等；Session 的主要作用就是通过服务端记录用户的状态。 </p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><h1 id="HTTP-1-0-和-HTTP-1-1-的主要区别是什么？"><a href="#HTTP-1-0-和-HTTP-1-1-的主要区别是什么？" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 的主要区别是什么？"></a>HTTP 1.0 和 HTTP 1.1 的主要区别是什么？</h1><ol><li>长连接：在 HTTP 1.0 中默认采用短连接，而 HTTP 1.1 中默认采用长连接。HTTP/1.1 的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li>错误状态响应码：在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li>缓存处理</li><li>带宽优化及网络连接的使用：HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能；HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ol><h1 id="URI-与-URL-的主要区别是什么？"><a href="#URI-与-URL-的主要区别是什么？" class="headerlink" title="URI 与 URL 的主要区别是什么？"></a>URI 与 URL 的主要区别是什么？</h1><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li><li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。</p><h1 id="HTTP-与-HTTPS-的主要区别是什么？"><a href="#HTTP-与-HTTPS-的主要区别是什么？" class="headerlink" title="HTTP 与 HTTPS 的主要区别是什么？"></a>HTTP 与 HTTPS 的主要区别是什么？</h1><ol><li>端口：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li><li>安全性和资源消耗： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li></ol><blockquote><p>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等；</p><p>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。</p></blockquote><h1 id="GET-和-POST-的区别、HTTP请求的方法"><a href="#GET-和-POST-的区别、HTTP请求的方法" class="headerlink" title="GET 和 POST 的区别、HTTP请求的方法"></a>GET 和 POST 的区别、HTTP请求的方法</h1><p>GET 方法请求一个制定资源的表示形式，使用 GET 的请求应该只用于获取数据</p><p>POST 方法会向指定资源提交数据进行处理请求（例如提交表单或上传文件），该请求会导致新资源的建立、已有资源的修改</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>GET 在浏览器回退时是无害的，而 POST 则会再次提交请求</li><li>GET 请求会被缓存，而 POST 请求不会，除非手动设置</li><li>GET 请求可被收藏为书签，POST 不能</li><li>GET 请求参数会被保存在历史记录中，POST 不能</li><li>GET 请求只能用 URL 编码，请求会直接暴露在 URL 上，POST 支持多种编码方式，请求放在请求体中</li></ol><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><ol><li>GET</li><li>POST</li><li>HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</li></ol><p>HTTP 1.1 新增了几种：</p><ol><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ol><h1 id="有哪些有状态协议"><a href="#有哪些有状态协议" class="headerlink" title="有哪些有状态协议"></a>有哪些有状态协议</h1><p>很多应用层协议都是有状态的，例如 BGP 路由协议、OSPF 路由协议、TFTP 文件传输协议</p><h1 id="HTTP-1-0-1-1-2-0-3-0"><a href="#HTTP-1-0-1-1-2-0-3-0" class="headerlink" title="HTTP 1.0/1.1/2.0/3.0"></a>HTTP 1.0/1.1/2.0/3.0</h1><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><p>无状态的应用层协议，浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接(无连接)，服务器不跟踪也每个客户单，也不记录过去的请求(无状态)。</p><p>这种无状态性可以借助cookie/session机制来做身份认证和状态记录。</p><p>存在的问题：</p><ol><li><p>无法复用连接</p><p>每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。</p></li><li><p>队头阻塞</p><p>由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</p></li></ol><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><p>特性包括长连接、管道化</p><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP1.1增加Connection字段，通过设置Keep-Alive保持HTTP连接不断开。避免每次客户端与服务器请求都要重复建立释放建立TCP连接。提高了网络的利用率。</p><h3 id="管道化"><a href="#管道化" class="headerlink" title="管道化"></a>管道化</h3><p>长连接使得管道化成为可能，将先进先出队列由客户端转移到服务端</p><p>允许打开多个 TCP 会话，才算实现真正的并行传输</p><h3 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h3><p>加入了缓存处理机制，支持断点传输，并增加了 Host 字段，使得一个服务器得以创建多个 Web 站点</p><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>HTTP2.0 在应用层和传输层之间增加了一个二进制分层帧，在二进制分帧层上，http2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装。这一做法突破了 HTTP 1.x 的性能限制，改进传输性能，实现了低延迟和高吞吐量。</p><h3 id="多路复用-连接共享"><a href="#多路复用-连接共享" class="headerlink" title="多路复用 / 连接共享"></a>多路复用 / 连接共享</h3><p>所有HTTP2.0通信都在一个TCP链接上完成，这个链接可以承载任意流量的双向数据流。</p><p>每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符(Stream_id)重新封装。</p><p>http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。实现了真正的并行传输。</p><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>在HTTP1.X中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500-8000字节的负荷。</p><p>比如cookie，默认情况下，浏览器会在每次请求的时候，把cookie附在header上面发给服务器。</p><p>HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header_files表，既避免重复header的传输，又减少了需要传输的大小。</p><p>高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。</p><h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><p>把http消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个31比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级。</p><p>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。</p><p>分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p><ul><li><p>优先级最高：主要的html</p></li><li><p>优先级高：CSS文件</p></li><li><p>优先级中：js文件</p></li><li><p>优先级低：图片</p></li></ul><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>服务器除了最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确的需求。</p><h2 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP 3.0"></a>HTTP 3.0</h2><p>即 QUIC 协议，是一个使用UDP来替代TCP的协议</p><h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h3><p>缓存当前会话的上下文，下次恢复会话的时候，只需要将之前的缓存传递给服务器，验证通过，就可以进行传输了。</p><p>RTT：往返时延，0-RTT建连指的是：</p><p>传输层0-RTT就能建立连接</p><p>加密层0-RTT就能建立加密连接</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>基于UDP，一个连接上的多个stream之间没有依赖，即使丢包，只需要重发丢失的包即可，不需要重传整个连接。</p><h3 id="更好的移动端表现"><a href="#更好的移动端表现" class="headerlink" title="更好的移动端表现"></a>更好的移动端表现</h3><p>QUIC在移动端的表现比TCP好，因为TCP是基于IP识别连接，而QUIC是通过ID识别链接。 无论网络环境如何变化，只要ID不便，就能迅速重新连上。</p><h3 id="加密认证的根文"><a href="#加密认证的根文" class="headerlink" title="加密认证的根文"></a>加密认证的根文</h3><p>TCP协议头没有经过任何加密和认证，在传输过程中很容易被中间网络设备篡改、注入和窃听。</p><p>QUIC除了个别报文，比如PUBLIC_RESET和CHLO，所有报文头部都是经过认证的，报文Body都是经过加密的。</p><p>所以只要对 QUIC 做任何更改，接收端都能及时发现，有效地降低了安全风险。</p><h3 id="向前纠错机制"><a href="#向前纠错机制" class="headerlink" title="向前纠错机制"></a>向前纠错机制</h3><p>每个数据包除了它本身的内容之外还包括了其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。</p><p>向前纠错牺牲了每个数据包可以发送数据的上限，但是带来的提升大于丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失，请求重传，等待新数据包等步骤的时间消耗)。</p><h1 id="为什么四次挥手等待-2-MSL"><a href="#为什么四次挥手等待-2-MSL" class="headerlink" title="为什么四次挥手等待 2 MSL"></a>为什么四次挥手等待 2 MSL</h1><p>MSL，Maximum Segment Lifetime，报文最大生存时间，指的是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p>之所以等待 2 MSL，是因为在发送了第三次挥手之后，网络中仍然有可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。</p><p>比如，三次挥手方没有收到断开连接的最后的 ACK 报文，就会再次发送 FIN 报文，另一方接收到 FIN之后，会再次重发 ACK 报文。</p><p>四次挥手方发送 ACK 报文后，报文会在一个 MSL 后失效，如果失效了，那么三次挥手方会重发 FIN 报文，这个报文同样会在一个 MSL 后失效。这样一来一回恰好是两个 MSL，也就是说这两个 MSL 内，如果没有故障，三次挥手方必然会收到 ACK，因此等 2 个 MSL 是为了防止 ACK 消息丢失，三次挥手方再次发送的 FIN 消息没有收到。</p><p>因此，2MSL 时长其实是相当于至少允许报文丢失一次</p><p>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。</p><h1 id="301-和-302-状态码的区别"><a href="#301-和-302-状态码的区别" class="headerlink" title="301 和 302 状态码的区别"></a>301 和 302 状态码的区别</h1><p>301 适合永久重定向，代表所请求的资源已被永久定位到新位置，比较常用的场景是域名跳转。例如对 <a href="http://www.baidu.com/">http://www.baidu.com</a> 的访问会跳转到 <a href="https://www.baidu.com/">https://www.baidu.com</a></p><p>302 是临时重定向，即请求的资源现在临时从不同的 URL 响应请求。适合用来做临时跳转，比如未登录的用户访问用户中心会自动跳转到登录、访问 404 页面会重新定向到首页</p><p>总之，302 重定向只是暂时重定向，浏览器会抓取新内容并保留旧内容</p><p>301重定向是永久重定向，浏览器抓取新内容的同时将旧网址替换为了重定向后的网址</p><h1 id="HTTP、TCP、IP-三种协议中，接收端如何判断已接收完对端发送来的数据？"><a href="#HTTP、TCP、IP-三种协议中，接收端如何判断已接收完对端发送来的数据？" class="headerlink" title="HTTP、TCP、IP 三种协议中，接收端如何判断已接收完对端发送来的数据？"></a>HTTP、TCP、IP 三种协议中，接收端如何判断已接收完对端发送来的数据？</h1><ul><li>HTTP 协议的服务端响应报文含有 Content-Length 字段，明确的报文的长度，客户端能够根据该字段进行判断</li><li>TCP 协议需要接收方回传确认号。如果双方各自向对方请求下一个数据包，却没有响应对方的请求，那么说明数据已经传完了。有时数据发送方发送完毕，会发出中断连接请求，对方也能够得知已经发送完毕了</li><li>IP 协议是无连接协议，不会考虑对方是否发送完毕，如果IP数据报被分片发送，那么只有最后一个分片的 “还有分片” 字段 flag 置为0，之前的都为1</li></ul><h1 id="HTTP-状态码故障排除"><a href="#HTTP-状态码故障排除" class="headerlink" title="HTTP 状态码故障排除"></a>HTTP 状态码故障排除</h1><h2 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h2><h3 id="500"><a href="#500" class="headerlink" title="500"></a>500</h3><p>500 表示服务器端错误的响应状态码，代表所请求的服务器遇到意外情况，阻止其执行请求。可能是服务器端程序或配置发生了致命错误，需要对服务器进行检查。</p><p>这个状态码是一个通用状态码，对于该类错误，需要访问更详细的请求信息来确定错误</p><h3 id="501"><a href="#501" class="headerlink" title="501"></a>501</h3><p>表示所请求的方法不被服务器锁支持，无法被处理，服务器必须支持的方法只有 GET 与 HEAD</p><h3 id="502"><a href="#502" class="headerlink" title="502"></a>502</h3><p>502 BAD GATEWAY 表示作为网关或代理的服务器，从上游服务器中接收到的响应是无效的</p><p>说白了就是，网站突然有大量请求进来，服务器无法及时处理，出现了502，需要进行重启。如果重启后依旧发生 502，则可能是数据库出现死锁导致超时，需要重启数据库或杀死死锁的 SQL 进程</p><p>可能导致的原因：上游服务器处理超时、配置错误、负载高导致处理请求慢、数据库发生死锁、服务未启动等</p><h3 id="503"><a href="#503" class="headerlink" title="503"></a>503</h3><p>源服务器存在性能问题，可能是源服务器没有足够的容量支持请求速率</p><p>可能是收到 DDoS 攻击，造成系统带宽和资源超载、可能系统在进行维护、可能存在防火墙配置错误，例如在传递网络时，防火墙可能将来自 CDN 的请求识别为攻击并阻止它们</p><h3 id="504"><a href="#504" class="headerlink" title="504"></a>504</h3><p>网关超时，一般和 Nginx 的配置有关，可能 Nginx 设置了超时时间，如果在超时时间内没有收到响应，则会给客户端返回 504</p><h2 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h2><h3 id="400"><a href="#400" class="headerlink" title="400"></a>400</h3><p>主要有两种形式：bad request 为请求错误，invalid hostname 为域名不存在</p><p>Bad request 是由于明显的客户端错误，例如格式错误的请求语法，请求大小太大，无效的请求消息或者欺骗性的路由请求等，对于这类请求服务器不会处理</p><p>常见的原因有：</p><ol><li>前端提交数据的字段名称或类型与后端的实体类不一致，导致无法封装，例如需要 int 传回了 String</li><li>前端提交到后台的数据应该是 json 类型，而前端没有将对象转化为字符串类型</li></ol><p>解决方案：</p><ol><li>对照字段名称，确保类型一致性</li><li>使用 Stringify 将前端传递的对象转化为字符串</li></ol><p>还有可能是走代理用的 HTTP 协议，但是目标地址是 HTTPS</p><h3 id="401"><a href="#401" class="headerlink" title="401"></a>401</h3><p>请求授权失败，可能是没有验证，例如需要账号密码但是没有输入，或者没有权限</p><h3 id="403"><a href="#403" class="headerlink" title="403"></a>403</h3><p>服务器已经理解该请求，但是拒绝执行，可能是由于以下的几种原因</p><p>原因：</p><ul><li>IP 被列入黑名单</li><li>一定时间内过多访问此网站，被防火墙拒绝</li><li>网络域名解析到了空间，但是空间没有绑定此域名</li><li>网页脚本文件在当前目录下没有执行权限</li><li>以 HTTP 方式访问需要 SSL 连接的网址</li><li>身份验证失败</li><li>DNS 解析错误</li><li>服务器繁忙</li></ul><p>解决方法：</p><ol><li>重建 DNS 缓存</li><li>修改文件夹安全属性</li></ol><h3 id="404"><a href="#404" class="headerlink" title="404"></a>404</h3><p>请求失败，所请求的资源在服务器上未找到</p><p>可能是部署的路径不正确，排查 xml 中配置文件路径是否写错，并确保 Tomcat 服务器正常开启</p><h2 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h2><h3 id="300"><a href="#300" class="headerlink" title="300"></a>300</h3><p>请求的资源可在多处获得</p><h3 id="301-302"><a href="#301-302" class="headerlink" title="301 &amp; 302"></a>301 &amp; 302</h3><p>代表客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，即重定向</p><p>301 代表永久重定向，说明资源已经不复存在，需要用新的 URL 进行访问</p><p>302 代表临时重定向，暂时用另一个 URL 进行访问</p><p>301 和 302 都会在响应头使用字段 Location，指明后续要跳转的 URL</p><h1 id="301-和-302-的区别"><a href="#301-和-302-的区别" class="headerlink" title="301 和 302 的区别"></a>301 和 302 的区别</h1><ul><li>302 虽然是重定向，但鉴于是临时的，所以浏览器自己的 URL 缓存不会改变，依然是原路径。在 302 重定向结束之后，只需要删除响应的重定向相关代码即可</li><li>301 是永久的，所以浏览器会更改自身的 URL 缓存，将旧路径换为新路径</li></ul><h2 id="302-的风险"><a href="#302-的风险" class="headerlink" title="302 的风险"></a>302 的风险</h2><ol><li>URL 劫持</li><li>网络降权</li></ol><h1 id="HTTP、TCP、IP-三种协议中，接收端如何判断已接收完对端发送来的数据？-1"><a href="#HTTP、TCP、IP-三种协议中，接收端如何判断已接收完对端发送来的数据？-1" class="headerlink" title="HTTP、TCP、IP 三种协议中，接收端如何判断已接收完对端发送来的数据？"></a>HTTP、TCP、IP 三种协议中，接收端如何判断已接收完对端发送来的数据？</h1><ul><li>HTTP 协议的服务端响应报文含有 Content-Length 字段，明确的报文的长度，客户端能够根据该字段进行判断</li><li>TCP 协议需要接收方回传确认号。如果双方各自向对方请求下一个数据包，却没有响应对方的请求，那么说明数据已经传完了。有时数据发送方发送完毕，会发出中断连接请求，对方也能够得知已经发送完毕了</li><li>IP 协议是无连接协议，不会考虑对方是否发送完毕，如果IP数据报被分片发送，那么只有最后一个分片的 “还有分片” 字段 flag 置为0，之前的都为1</li></ul><h1 id="HTTP-header-有哪些？"><a href="#HTTP-header-有哪些？" class="headerlink" title="HTTP header 有哪些？"></a>HTTP header 有哪些？</h1><h2 id="Request-的头部信息"><a href="#Request-的头部信息" class="headerlink" title="Request 的头部信息"></a>Request 的头部信息</h2><ol><li>HTTP 请求方式，包括 GET（发送请求）、POST、PUT（向服务器发生数据并存储在服务器内部）、HEAD（检查对象是否存在）、DELETE（删除文件）、TRACE（跟踪到服务器的路径）、OPTIONS（查询服务器性能）</li><li>HOST 请求的服务器域名地址</li><li>User=Agent 客户端运行的浏览器详细信息</li><li>Accept 指定客户端能够接收的内容类型</li><li>Keep-alive 此 HTTP 连接的时间</li><li>cookie</li></ol><h2 id="Response-的头部信息"><a href="#Response-的头部信息" class="headerlink" title="Response 的头部信息"></a>Response 的头部信息</h2><p>Response 中第一行叫状态行，由 HTTP 协议的版本号、状态码、状态消息 三部分组成</p><ol><li>Content-Length：表示服务器返回消息的长度</li><li>Content-type：返回数据的类型和字符编码格式</li><li>Date：当前时间</li></ol><h1 id="HTTPS-的通信过程"><a href="#HTTPS-的通信过程" class="headerlink" title="HTTPS 的通信过程"></a>HTTPS 的通信过程</h1><ol><li><p>客户端发起 HTTPS 请求</p><p>用户在浏览器输入网址，连接至服务器的 443 端口</p></li><li><p>服务端配置</p><p>采用 HTTPS 协议的服务器必须有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才能够继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书也就是一对公钥和私钥</p></li><li><p>传送服务器的证书给客户端</p><p>证书里其实就是公钥，并且包含了很多信息，如证书的颁发机构、过期时间等</p></li><li><p>客户端解析验证服务器证书</p><p>这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构、过期时间等。如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书中公钥对该随机值进行非对称加密。</p></li><li><p>客户端将加密信息传送服务器</p><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值进行加密解密了。</p></li><li><p>服务端解密信息</p><p>服务端将客户端发送过来的加密信息用服务器私钥解密后，得到客户端传送的随机值</p></li><li><p>服务端加密信息并发送信息</p><p>服务器将数据利用随机值进行对称加密，再发送给客户端</p></li><li><p>客户端接收并解密信息</p><p>客户端用之前生成的随机值解密服务端信息，获取解密后的内容</p></li></ol><h1 id="HTTPS-加密原理"><a href="#HTTPS-加密原理" class="headerlink" title="HTTPS 加密原理"></a>HTTPS 加密原理</h1><h2 id="什么是对称加密？"><a href="#什么是对称加密？" class="headerlink" title="什么是对称加密？"></a>什么是对称加密？</h2><p>即发送与接收方使用同一个密钥，它可以加密一段信息，也能够对这段信息进行解密，类似于日常生活中的钥匙</p><h2 id="为什么不仅仅用对称加密？"><a href="#为什么不仅仅用对称加密？" class="headerlink" title="为什么不仅仅用对称加密？"></a>为什么不仅仅用对称加密？</h2><p>最大的问题是怎么保证这个密钥让传输双方知道，并且不被别人知道。这除非是浏览器保存了世界上所有网站的密钥，而这是不现实的</p><h2 id="什么是非对称加密？"><a href="#什么是非对称加密？" class="headerlink" title="什么是非对称加密？"></a>什么是非对称加密？</h2><p>有两把密钥，一把公钥一把私钥，用公钥加密的内容必须用私钥才能解开，反之，私钥加密的内容只有公钥能够解开。</p><h2 id="为什么不仅仅用非对称加密？"><a href="#为什么不仅仅用非对称加密？" class="headerlink" title="为什么不仅仅用非对称加密？"></a>为什么不仅仅用非对称加密？</h2><p>如果仅仅用非对称加密，那么服务器需要先把公钥明文发给客户端，之后客户端向服务器传数据前都用该公钥加密后再传，这条数据的安全就能够保证了。因为只有服务器有相应的私钥解开这条数据。</p><p>但是，服务器给浏览器发送的数据就无法保证安全。如果服务器用自己的私钥加密数据传给客户端，那么客户端用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被劫持了，那么就失去了安全性。</p><h2 id="非对称加密-对称加密-？"><a href="#非对称加密-对称加密-？" class="headerlink" title="非对称加密 + 对称加密 ？"></a>非对称加密 + 对称加密 ？</h2><ol><li>某网站拥有用于非对称加密的公钥 A、私钥 A1</li><li>浏览器向网站服务器请求，服务器将公钥 A 明文传输给浏览器</li><li>浏览器随机生成一个用于对称加密的密钥 X，用公钥 A 加密后传给服务器</li><li>服务器拿到后用私钥 A1 解密得到密钥 X</li><li>双方都拥有了密钥 X，之后的数据传输就用 X 即可</li></ol><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>如果在数据传输过程中，中间人劫持了数据，此时其确实无法得知密钥 X。然而，这个中间人是可能劫持到公钥 A，并对其进行保存，将公钥 A 替换成自己伪造的公钥 B 的。在后续浏览器用该公钥 B 加密 X 后传给服务器，中间人是能够劫持该数据，并用私钥 B1 对其进行解密的。之后，中间人再将其用公钥 A 加密后传给服务器。这样，中间人就获得了 X，而双方不会发现异常。</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>为了保证浏览器收到的公钥就是该网站的公钥，网站在使用 HTTPS 之前，需要向 CA 机构申请一份数字证书。数字证书中含有证书持有者信息、公钥信息等。服务器将证书传递给浏览器，浏览器可以从证书中获取公钥。</p><h2 id="如何防止数字证书被篡改？"><a href="#如何防止数字证书被篡改？" class="headerlink" title="如何防止数字证书被篡改？"></a>如何防止数字证书被篡改？</h2><p>将证书原本的内容生成一份签名，对比证书内容和签名是否一致就能够判断是否被篡改。</p><p>数字签名的制作过程：</p><ol><li>CA 机构拥有非对称加密的私钥与公钥</li><li>CA 机构对证书明文数据 T 进行 hash</li><li>对 hash 后的值用私钥进行加密，得到数字签名 S</li></ol><p>浏览器验证：</p><ol><li>拿到证书，得到明文 T，签名 S</li><li>用 CA 机构的公钥（由于是浏览器信任的机构，因此浏览器保有公钥）对 S 解密，得到 S1</li><li>用证书指明的 hash 算法对明文 T 进行 hash 得到 T1</li><li>此时 S1 = T1，除非证书被篡改。因此对比 S1 是否等于 T1 就能够判断证书是否可信</li></ol><h2 id="为什么说-CA-机构的公钥是可信的"><a href="#为什么说-CA-机构的公钥是可信的" class="headerlink" title="为什么说 CA 机构的公钥是可信的"></a>为什么说 CA 机构的公钥是可信的</h2><p>操作系统、浏览器本身会预装一些根证书，其中就会有 CA 机构的根证书，从而拿到可信的公钥。</p><p>证书间的认证也可以不止一层，可以构成信任链。</p><h2 id="中间人有可能篡改该证书吗？"><a href="#中间人有可能篡改该证书吗？" class="headerlink" title="中间人有可能篡改该证书吗？"></a>中间人有可能篡改该证书吗？</h2><p>假设中间人篡改了证书原文，但是他没有 CA 机构的私钥，所以无法得知加密后的签名，无法篡改签名，浏览器就能够发现证书内容与签名不一致。</p><h2 id="中间人有可能掉包证书吗？"><a href="#中间人有可能掉包证书吗？" class="headerlink" title="中间人有可能掉包证书吗？"></a>中间人有可能掉包证书吗？</h2><p>证书中包含了网站的信息，只需要对比就能发现是否掉包</p><h2 id="为什么制作数字签名需要一次-hash"><a href="#为什么制作数字签名需要一次-hash" class="headerlink" title="为什么制作数字签名需要一次 hash"></a>为什么制作数字签名需要一次 hash</h2><p>非对称加密效率较差，证书信息较长，通过 hash 后能够获得固定长度信息，例如用 md5 算法 hash 后固定得到 128 位的值</p><h2 id="每次进行-HTTP-请求，都必须在-SSL-TLS-进行握手传输密钥吗"><a href="#每次进行-HTTP-请求，都必须在-SSL-TLS-进行握手传输密钥吗" class="headerlink" title="每次进行 HTTP 请求，都必须在 SSL/TLS 进行握手传输密钥吗"></a>每次进行 HTTP 请求，都必须在 SSL/TLS 进行握手传输密钥吗</h2><p>服务器会为每个客户端维护一个 session ID，在 TLS 握手阶段传给浏览器，浏览器生成好密钥传给服务器后，该密钥就被存入了相应的 session ID 之下，从而避免了密钥的重复传输</p><h1 id="HTTP-的问题"><a href="#HTTP-的问题" class="headerlink" title="HTTP 的问题"></a>HTTP 的问题</h1><p>HTTP发展到1.1存在的问题：</p><ul><li>队头阻塞问题：队头阻塞(Head Of Line Blocking)，每个TCP同时只能处理一个HTTP请求，浏览器遵循FIFO原则，如果上一个没返回后续请求会被阻塞。</li><li>多个TCP连接：HTTP 1.1 版本的请求并发依赖于建立多个TCP连接，建立TCP连接的成本很高，还会存在慢启动的问题。为了避免网络拥堵，占用过多的CPU和内存。因此，不同的浏览器会限制TCP连接的数量。</li><li>请求头冗余：HTTP/1.X 版本的请求头采用文本格式，首部未压缩，而且每一个请求都会带上cookie、user-agent等完全相同的首部。</li><li>客户端需要主动建立请求</li></ul><h1 id="HTTP-2-0-和-HTTP-1-0-的区别"><a href="#HTTP-2-0-和-HTTP-1-0-的区别" class="headerlink" title="HTTP 2.0 和 HTTP 1.0 的区别"></a>HTTP 2.0 和 HTTP 1.0 的区别</h1><p>HTTP 2.0的实现是基于SPDY协议的一些标准来实现的。HTTP 2.0提供了：二进制分帧、首部压缩、多路复用、请求优先级、服务器推送等优化。HTTP/2 的目的是通过支持请求与响应的多路复用来较少延迟，通过压缩HTTPS首部字段将协议开销降低，同时增加请求优先级和服务器端推送的支持。</p><h2 id="什么是-SPYD-协议"><a href="#什么是-SPYD-协议" class="headerlink" title="什么是 SPYD 协议"></a>什么是 SPYD 协议</h2><p>SPDY是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。协议的核心思想是尽量减少TCP连接数。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。</p><p>互联网工程任务组(IETF)对谷歌提出的SPDY协议进行了标准化，于 2015 年 5 月推出了**类似于 SPDY 协议的 HTTP 2.0 协议标准(简称HTTP/2)**。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。</p><p>下面详细了解一下HTTP 2.0提供的新特性。</p><h2 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h2><p>在保证HTTP1.x不受到影响的情况下，HTTP 2.0是怎样突破HTTP 1.1的性能限制，改进传输性能，实现低延迟高吞吐量的呢?关键之一就是在应用层(HTTP)和传输层(TCP)之间增加一个二进制分帧层。HTTP/2性能提升的核心就在于二进制分帧层。HTTP/2是二进制协议，他采用二进制格式传输数据而不是1.x的文本格式。</p><p>HTTP 1.1在应用层以纯文本的形式进行通信，而HTTP 2.0将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。同时，客户端和服务端都需要引入新的二进制编码和解码的机制。如下图所示，HTTP 2.0并没有改变HTTP 1.x的语义，只是在应用层使用二进制分帧方式传输。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220225160527.png"></p><p>上图很清晰地表达了HTTP/1.1的响应和2.0的区别。1.1响应是文本格式，而2.0把响应划分成了两个帧，图中的HEADERS（首部）和DATA（消息负载） 是帧的类型。也就是说一条HTTP响应，划分成了两个帧来传输，并且采用二进制来编码。</p><p>关于二进制分帧，有三个相关概念：帧、消息和流。</p><ul><li>帧：HTTP 2.0通信的最小单位</li><li>消息：比帧大的通讯单位，是指逻辑上的HTTP消息(请求/响应)，一系列数据帧组成了一个完整的消息。</li><li>流：比消息大的通讯单位，是TCP连接中的一个虚拟通道，可以承载双向的消息。</li></ul><h2 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h2><p>上面提到的 HTTP/1.1 的线头阻塞和多个 TCP 连接的问题，HTTP/2的多路复用能够完美解决。HTTP2让所有的通信都在一个TCP连接上完成，真正实现了请求的并发。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220225161239.png"></p><p>多路复用允许同时通过一个TCP连接发起多重的请求-响应消息。消息由帧构成，每帧数据上都标识属于哪个流(StreamID)，对方接收时根据流ID拼接每个流所有帧的数据，组成一块完整的数据。这就是HTTP/2的多路复用。</p><p>流的概念实现了单连接上多请求-响应并行，HTTP/2建立一个TCP连接，一个连接上面可以有任意多个流（stream），消息分割成一个或多个帧在流里面传输。帧传输过去以后，再进行重组，形成一个完整的请求或响应。</p><blockquote><p>请求太多时，浏览器或服务器还是会受不了，这超出了它的处理能力。流控制帮我们解决了这个问题，流控制会管理数据的传输，允许接收者停止或减少发送的数据量，免得接收方不堪重负。所以请求太多时，还是会存在排队等待的问题，因为不管是客户端或服务器端，能同时处理请求或响应都是有限的。</p></blockquote><h2 id="头部压缩-1"><a href="#头部压缩-1" class="headerlink" title="头部压缩"></a>头部压缩</h2><p>HTTP/1.1并不支持HTTP首部压缩，为此SPDY和HTTP/2应运而生， SPDY使用的是通用的算法，而HTTP/2则使用了专门为首部压缩而设计的算法 (HPACK算法)。</p><p>HTTP协议是无状态的，每次请求都必须附上所有信息(描述资源属性)，重传数据达到几百甚至几千字节。所以，请求头字段很多都是重复的，比如Cookie，一样的内容每次请求都必须附带，会浪费很多带宽，也影响速度。</p><p>其实，对于相同的头部，只需发送一次即可。HTTP/2对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。</p><h2 id="服务器端推送"><a href="#服务器端推送" class="headerlink" title="服务器端推送"></a>服务器端推送</h2><p>服务器端推送使得服务器可以预测客户端需要的资源，主动推送到客户端。客户端发送一个请求，服务器根据客户端的请求，提前返回多个响应，这样客户端就不用发起后续请求。也就是说，在HTTP/2中，服务器可以对客户端的一个请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。</p><h2 id="请求优先级-1"><a href="#请求优先级-1" class="headerlink" title="请求优先级"></a>请求优先级</h2><p>把HTTP消息分为很多独立帧之后，就可以通过<strong>优化这些帧的交错和传输顺序</strong>进一步优化性能。HTTP/2中每个Stream都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题。</p><h2 id="应用层的重置连接"><a href="#应用层的重置连接" class="headerlink" title="应用层的重置连接"></a>应用层的重置连接</h2><p>对于 HTTP/1 来说，是通过设置 tcp segment 中的 reset flag 来通知对端关闭连接的。这种方式会直接断开连接，下次再发请求就必须重新建立连接。HTTP/2 引入 RST_STREAM 类型的 frame，可以在不断开连接的前提下取消某个 request 的 stream ，表现更好。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>TCP协议是通过 sliding window 算法来做流量控制的。发送方有一个 sending window，接收方有一个 receive window。HTTP/2的流量控制类似receive window，数据接收方通知对方字节的 flow window 大小，表明还能接收的数据量。只有Data类型的frame才有流量控制功能。</p><p>通过上述方式，可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2023/11/16/rabbitmq/"/>
      <url>/2023/11/16/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-MQ"><a href="#什么是-MQ" class="headerlink" title="什么是 MQ"></a>什么是 MQ</h1><p>即消息队列，软件与软件之间进行通信的中间产品，主要优点包括异步处理、应用解耦、流量削峰、日志处理（解决大量日志传输）、消息通讯</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220214102118.png"></p><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？此时 A 系统就跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。</p><h2 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h2><p>减少高峰时期对服务器压力。</p><p><strong>MQ 的缺点：</strong> 系统可用性降低、复杂度升高，系统存在一致性问题</p><h1 id="消息队列的应用"><a href="#消息队列的应用" class="headerlink" title="消息队列的应用"></a>消息队列的应用</h1><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>例如在用户注册的场景中，需要发送注册邮件与短信，传统方式可以串行与并行发送。串行方式指的是在将注册信息写入数据库成功之后，先发送注册邮件，再发送注册短信，这一过程速度缓慢。并行方式指的是在将注册信息写入数据库成功之后，发送注册邮件的同时发送注册短信，提高了处理时间，但是会消耗较大的系统性能。</p><p>引入消息队列之后，能够实现异步处理。即将注册信息写入数据库之后，将待处理信息写入消息队列，邮件与短信的发送模块分别异步从消息队列中读取信息，提高了速度，增大了吞吐量。</p><h2 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h2><p>例如在下单场景中，订单下单之后需要通知库存系统，如果不采用消息队列，订单系统需要调用库存系统的接口，二者产生耦合。</p><p>引入消息队列之后，订单系统将消息写入消息队列，并给用户返回下单成功的消息。库存系统订阅消息队列，获取下单信息，根据该信息进行相关的库存操作。</p><h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h2><h2 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h2><p>同样是采用订阅消息队列的思想，日志采集客户端负责相关数据的采集，并定时写入消息队列，消息队列负责日志数据的接收、存储以及转发，日志处理端则负责订阅并消费队列中的日志数据</p><h2 id="消息通讯"><a href="#消息通讯" class="headerlink" title="消息通讯"></a>消息通讯</h2><p>由于消息队列内置了高效的通信机制，因此可以用于纯粹的消息通讯。例如实现点对点通信队列以及聊天室通讯等。</p><p>点对点通信：客户端A与B共用一个队列，进行消息通讯</p><p>聊天室通讯：多个客户端共同订阅同一主题，进行消息的发布与接收，实现类似聊天室的效果。</p><h2 id="各个-MQ-的对比"><a href="#各个-MQ-的对比" class="headerlink" title="各个 MQ 的对比"></a>各个 MQ 的对比</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220214102720.png"></p><h1 id="RabbitMQ-简介"><a href="#RabbitMQ-简介" class="headerlink" title="RabbitMQ 简介"></a>RabbitMQ 简介</h1><p>是一款开源的，Erlang 编写的消息中间件； 最大的特点就是消费并不需要确保提供方存在，实现了服务之间的高度解耦。可以用它来：解耦、异步、削峰。</p><h2 id="Rabbit-MQ-基本概念"><a href="#Rabbit-MQ-基本概念" class="headerlink" title="Rabbit MQ 基本概念"></a>Rabbit MQ 基本概念</h2><ul><li>Broker： 简单来说就是消息队列服务器实体</li><li>Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列</li><li>Queue： 消息队列载体，每个消息都会被投入到一个或多个队列</li><li>Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来</li><li>Routing Key： 路由关键字，exchange根据这个关键字进行消息投递</li><li>Producer： 消息生产者，就是投递消息的程序</li><li>Consumer： 消息消费者，就是接受消息的程序</li><li>Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务</li><li>VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。</li></ul><h1 id="如何保证RabbitMQ消息的顺序性"><a href="#如何保证RabbitMQ消息的顺序性" class="headerlink" title="如何保证RabbitMQ消息的顺序性"></a>如何保证RabbitMQ消息的顺序性</h1><h2 id="消息顺序性"><a href="#消息顺序性" class="headerlink" title="消息顺序性"></a>消息顺序性</h2><p>例如，数据中台服务器A发送  创建学生信息 与 更新学生信息 两条消息。应用服务器B需要接受服务A的消息。接收到创建学生信息的消息就在表里创建一个学生记录。接受到更新学生的消息就更新学生基本信息。</p><p>如果B服务器部署了两台，服务A在很短的时间内发送了两条消息，那么服务B可能有一台做创建学生的操作，另外一台做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。因此，就需要保证这两条消息的顺序性。</p><h2 id="如何保证消息顺序性"><a href="#如何保证消息顺序性" class="headerlink" title="如何保证消息顺序性"></a>如何保证消息顺序性</h2><p>例如对同一条数据做了insert，update，delete操作，我们往MQ顺序写入了insert，update，delete操作的三条消息，那么根据分析，最终同步到另一个库中，这条数据是被删除了的。但是，如果这三条消息不是按照insert，update，delete顺序被消费，而是按照delete，insert，update的顺序被消费，那么最终这条数据是会保存到新库中的。这就导致了数据错乱了。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220214105818.png"></p><p>为了解决上述问题，使得 RabbitMQ 保证消息的顺序性，可以拆分多个 queue，每个 queue 对应一个 consumer（消费者），就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220214110851.png"></p><h1 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h1><p>RabbitMQ 存在三种丢失消息的情况：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220214202946.png"></p><p>解决方法：</p><ol><li><p>生产者发送至 MQ 的消息数据丢失（消息在写到消息队列的过程中丢失）</p><p>解决方法：在生产者端开启 comfirm 确认模式，每次写的消息都会被分配一个唯一的 id，如果写入了 RabbitMQ 中，RabbitMQ 会回传一个 ack 消息，告诉生产者端这个消息 ok 了</p></li><li><p>MQ 收到消息，暂存内存中，还没消费，自己挂掉，数据会都丢失</p><p>解决方式：MQ设置为持久化，将内存数据持久化到磁盘中</p></li><li><p>消费者刚拿到消息，还没处理，挂掉了，MQ又以为消费者处理完（在消费的过程中存在消息丢失的可能）</p><p>解决方式：RabbitMQ 有手动 ack 机制与自动 ack 机制来解决消费者弄丢数据的问题，如果使用 RabbitMQ 提供的 ack 机制，首先关闭 RabbitMQ 的自动 ack，使用手动 ack，每次在确保处理完这个消息之后，在代码里手动调用 ack。这样就可以避免消息还没有处理完就ack。</p><p>但是ack机制在异常情况下可能造成重复消费：当消费者异常断掉连接，但并未挂掉，broker 会得知， 此时 Broker 尚未获得 ack，那么消息会被重新放入其他队列，这样就导致数据被重复消费了。</p><p>应用层解决重复的方式：</p><ul><li>用来存储每个消息的执行状态（用 msgid 区分），执行成功之后更新 Map，有另外消息重复消费的时候，读取 Map 数据判断 msgid 对应的执行状态，已消费则不执行。</li><li>业务逻辑判断：消息执行完会更改某个实体状态，判断实体状态是否更新，如果更新，则不进行重复消费。</li></ul></li></ol><blockquote><p>RabbitMQ 给我们提供了消费者应答（ack）机制，默认情况下这个机制是自动应答，只要消息推送到消费者就会自动 ack ，然后 RabbitMQ 删除队列中的消息。启用手动应答之后我们在消费端调用 API 手动 ack 确认之后，RabbitMQ 才会从队列删除这条消息。</p><p>然而，在实际的生产环境中如果直接采用该方法，很容易就会出现问题。因为该方法需要设置如果消费者接收消息失败后是否需要将消息重新放回消息队列。如果不放回，则直接丢弃该消息，相当于没有保证消息可靠。而如果放回，当发生消费报错之后，这个消息会被重回消息队列顶端，继续推送到消费端，继续消费这条消息，通常代码的报错并不会因为重试就能解决，所以这个消息将会出现这种情况：继续被消费，继续报错，重回队列，继续被消费……死循环</p><p>为了解决这一问题，在真实场景下通常有三种选择：</p><ol><li>当消费失败后将此消息存到 Redis，记录消费次数，如果消费了三次还是失败，就丢弃掉消息，记录日志落库保存 </li><li>直接不重回队列，记录日志、发送邮件等待开发手动处理</li><li>不启用手动 ack ，使用 SpringBoot 提供的消息重试</li></ol></blockquote><h1 id="如何保证-RabbitMQ-消息不被重复消费"><a href="#如何保证-RabbitMQ-消息不被重复消费" class="headerlink" title="如何保证 RabbitMQ 消息不被重复消费"></a>如何保证 RabbitMQ 消息不被重复消费</h1><p>解决消息重复消费有两种角度，第一种就是不让消费端执行两次，第二种是让它重复消费了，但是不会对我的业务数据造成影响就行了。</p><h2 id="确保消费端只执行一次"><a href="#确保消费端只执行一次" class="headerlink" title="确保消费端只执行一次"></a>确保消费端只执行一次</h2><p>一般来说消息重复消费都是在短暂的一瞬间消费多次，我们可以使用 redis 将消费过的消息唯一标识存储起来，然后在消费端业务执行之前判断 redis 中是否已经存在这个标识。举个例子，订单使用优惠券后，要通知优惠券系统，增加使用流水。这里可以用订单号 + 优惠券 id 做唯一标识。业务开始先判断 redis 是否已经存在这个标识，如果已经存在代表处理过了。不存在就放进 redis 设置过期时间，执行业务。</p><h2 id="允许消费端执行多次，保证数据不受影响"><a href="#允许消费端执行多次，保证数据不受影响" class="headerlink" title="允许消费端执行多次，保证数据不受影响"></a>允许消费端执行多次，保证数据不受影响</h2><ul><li><p>数据库唯一键约束</p><p>如果消费端业务是新增操作，我们可以利用数据库的唯一键约束，比如优惠券流水表的优惠券编号，如果重复消费将会插入两条相同的优惠券编号记录，数据库会给我们报错，可以保证数据库数据不会插入两条。</p></li><li><p>数据库乐观锁思想</p><p>如果消费端业务是更新操作，可以给业务表加一个 version 字段，每次更新把 version 作为条件，更新之后 version + 1。由于 MySQL 的 innoDB 是行锁，当其中一个请求成功更新之后，另一个请求才能进来，由于版本号 version 已经变成 2，必定更新的 SQL 语句影响行数为 0，不会影响数据库数据。</p></li></ul><h1 id="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？"><a href="#如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？"></a>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？</h1><p>所谓消息积压一般是由于消费端消费的速度远小于生产者发消息的速度，导致大量消息在 RabbitMQ 的队列中无法消费。产生的原因主要有：消费端宕机、消费端消费能力不足、生产端发送流量过大。</p><ul><li>最直接的解决方案就是增加消费端实例。说白了就是增加机器。如果出现线上事故，能申请多少机器就申请多少机器，争取在最短的时间内消费掉积压在MQ中的消息。</li><li>还可以增加消费端的消费能力，在MQ的配置中配置”最大消费者数量”与”每次从队列中获取的消息数量”</li><li>最后还可以紧急上线专门用于记录消息的队列，先把MQ中的消息记录到数据库中，然后再慢慢的消化处理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rabbit MQ </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/11/16/redis/"/>
      <url>/2023/11/16/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis"></a>什么是 Redis</h1><p>Redis 就是一个使用 C 语言开发的高性能非关系型的键值对数据库。与传统数据库不同的是 Redis 的数据是存在内存中的 ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。Redis可以将数据写入磁盘中，保证了数据的安全不丢失，而且Redis的操作是原子性的。</p><h1 id="Redis-的应用场景"><a href="#Redis-的应用场景" class="headerlink" title="Redis 的应用场景"></a>Redis 的应用场景</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>合理利用缓存来提升网站的访问速度、降低数据库的压力</p><h2 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h2><p>有序集合数据结构能够实现复杂的排行榜应用</p><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>如视频播放量、商品浏览量等，如果直接对数据库操作可能无法应对较高的并发量，Redis 可以用 incr 命令来实现计数功能</p><h2 id="分布式会话"><a href="#分布式会话" class="headerlink" title="分布式会话"></a>分布式会话</h2><p>可以搭建以 Redis 等内存数据库为中心的 session 服务，session 不再由容器管理，而是由 session 服务及内存数据库管理</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式技术的一个挑战是对同一个资源的并发访问，并发量大的情况下使用数据库锁来控制并发访问是不理想的，大大影响了数据库性能，因此可以采用 Redis 来实现分布式锁</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>Redis 还有发布/订阅以及阻塞队列的功能，可以充当消息队列使用</p><h1 id="Redis-的优缺点"><a href="#Redis-的优缺点" class="headerlink" title="Redis 的优缺点"></a>Redis 的优缺点</h1><p><strong>优点：</strong></p><ol><li>基于内存操作，内存读写速度快。</li><li>单线程的，避免线程切换开销及多线程的竞争问题。单线程是指网络请求使用一个线程来处理，即一个线程处理所有网络请求，Redis 运行时不止有一个线程，比如数据持久化的过程会另起线程。</li><li>支持多种数据类型，包括String、Hash、List、Set、ZSet等。</li><li>支持持久化。Redis支持RDB和AOF两种持久化机制，持久化功能可以有效地避免数据丢失问题。<blockquote><p>像 Redis 一样将数据保存在内存中有一个很大的缺陷，就是一旦断电或者宕机，内存数据库中的内容将会全部丢失。为了弥补这一缺陷，Redis提供了把内存数据持久化到硬盘文件，以及通过备份文件来恢复数据的功能，即Redis持久化机制。</p></blockquote></li><li>支持事务。Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li><li>支持主从复制。主节点会自动将数据同步到从节点，可以进行读写分离。</li></ol><p><strong>缺点：</strong></p><ol><li>对结构化查询的支持比较差。</li><li>数据库容量受到物理内存的限制，不适合用作海量数据的高性能读写</li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li></ol><h1 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h1><ul><li>基于内存：Redis是使用内存存储，没有磁盘IO上的开销。数据存在内存中，读写速度快。</li><li>单线程实现（ Redis 6.0以前）：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。</li><li>IO多路复用模型：Redis 采用 IO 多路复用技术。Redis 使用单线程来轮询描述符，将数据库的操作都转换成了事件，不在网络I/O上浪费过多的时间。</li><li>高效的数据结构：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。</li></ul><h1 id="缓存数据的处理流程是怎样的"><a href="#缓存数据的处理流程是怎样的" class="headerlink" title="缓存数据的处理流程是怎样的"></a>缓存数据的处理流程是怎样的</h1><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220212180228.png"></p><ol><li>如果用户请求的数据在缓存中就直接返回。</li><li>缓存中不存在的话就看数据库中是否存在。</li><li>数据库中存在的话就更新缓存中的数据。</li><li>数据库中不存在的话就返回空数据。</li></ol><h1 id="为什么要用-Redis-缓存"><a href="#为什么要用-Redis-缓存" class="headerlink" title="为什么要用 Redis/缓存"></a>为什么要用 Redis/缓存</h1><p>使用缓存主要是为了提升用户体验以及应对更多的用户。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220212202245.png"></p><p>高性能：</p><p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p><p>这样做的好处就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p><p>不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p>高并发：</p><p>Redis 缓存之后的 QPS 更高，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，进而也就提高了系统整体的并发。</p><blockquote><p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p></blockquote><h1 id="Redis-的数据类型"><a href="#Redis-的数据类型" class="headerlink" title="Redis 的数据类型"></a>Redis 的数据类型</h1><p>Redis 总共有八种数据结构，五种基本数据类型和三种特殊数据类型</p><h2 id="五种基本数据类型"><a href="#五种基本数据类型" class="headerlink" title="五种基本数据类型"></a>五种基本数据类型</h2><ul><li>String：字符串类型，可用于存储计数器、粉丝数等</li><li>hashmap：key - value 形式</li><li>list：列表，在 Redis 中可以把 list 用作栈、队列、阻塞队列。</li><li>set：集合，可用于记录点赞、收藏等</li><li>sorted set：有序集合，有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序，可用于记录排行榜</li></ul><h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><ul><li>geospatial：该功能可以推算出地理位置信息，两地之间的距离。</li><li>hyperloglog：数学上集合的元素个数，比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。</li><li>bitmap：通过最小的单位 bit 来进行 0 或者 1 的设置，表示某个元素对应的值或者状态。</li></ul><h1 id="Redis-单线程模型"><a href="#Redis-单线程模型" class="headerlink" title="Redis 单线程模型"></a>Redis 单线程模型</h1><p>Redis 单线程模型指的是执行 Redis 命令的核心模块是单线程的，并不是整个 Redis 实例就一个线程，Redis 其他模块还有各自模块的线程的。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220213161415.png"></p><blockquote><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p></blockquote><h2 id="单线程怎么监听大量的客户端连接呢？"><a href="#单线程怎么监听大量的客户端连接呢？" class="headerlink" title="单线程怎么监听大量的客户端连接呢？"></a>单线程怎么监听大量的客户端连接呢？</h2><p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p><p>Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：1. 文件事件; 2. 时间事件。其中需要关注的是文件事件，也就是客户端进行读取写入等操作，涉及一系列网络通信。</p><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p><p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><h2 id="为什么网络处理要引入多线程"><a href="#为什么网络处理要引入多线程" class="headerlink" title="为什么网络处理要引入多线程"></a>为什么网络处理要引入多线程</h2><p>Redis 的瓶颈并不在 CPU，而在内存和网络。网络 IO 的读写在 Redis 整个执行期间占用了大部分的 CPU 时间，如果把网络处理这部分做成多线程处理方式，那对整个 Redis 的性能会有很大的提升。</p><p>因此，Redis 6.0 在网络 IO 处理方面使用了多线程，如网络数据的读写和协议解析等，需要注意的是，执行命令的核心模块还是单线程的。</p><h1 id="Redis-的持久化机制"><a href="#Redis-的持久化机制" class="headerlink" title="Redis 的持久化机制"></a>Redis 的持久化机制</h1><p>有两种持久化机制：AOF 和 RDB</p><h2 id="快照持久化（RDB）"><a href="#快照持久化（RDB）" class="headerlink" title="快照持久化（RDB）"></a>快照持久化（RDB）</h2><p>Redis 可以通过创建快照来获得存储在内存中的数据在某个时间点上的副本。也就是在指定的时间间隔内将内存中的数据集快照写入磁盘，恢复时就是将快照文件直接读入内存内。该方法以紧缩的二进制文件保存 Redis 数据库某一时刻所有数据对象的内存快照，可用于 Redis 的数据备份、转移与恢复。</p><p>Redis 会单独创建（fork）一个子进程来进行持久化，其基本过程就是将数据写入到一个临时文件当中，待持久化过程结束后再用这个临时文件替换上次持久化后所保存的文件。</p><h3 id="RDB-工作原理"><a href="#RDB-工作原理" class="headerlink" title="RDB 工作原理"></a>RDB 工作原理</h3><p>默认情况下，Redis中有16个数据库，编号从0-15，每个Redis数据库使用一个 redisDb 对象来表示，redisDb 使用 hashtable 存储 K-V 对象。</p><p>时间点快照也就是某一时刻Redis内每个DB中每个数据对象的状态，<strong>先假设在这一时刻所有的数据对象不再改变</strong>，我们就可以把数据对象依次读取出来并写入到文件中，以此实现Redis的持久化。然后，当Redis重启时按照规则读取这个文件中的内容，再写入到Redis内存即可恢复至持久化时的状态。</p><p>然而，这样的持久化备份会导致短时间内Redis服务不可用，这对于高HA的系统来讲是无法容忍的。所以，RDB持久化的主要实践方式就是利用操作系统提供的fork()函数创建的子进程来获得与父进程一致的内存数据，相当于获取了内存数据副本。fork完成后，父进程该干嘛干嘛，持久化状态的工作交给子进程就行了。</p><p>由于fork子进程后，父进程数据一直在变化，子进程并不与父进程同步，RDB持久化必然无法保证实时性；RDB持久化完成后发生断电或宕机，会导致部分数据丢失；备份频率决定了丢失数据量的大小，提高备份频率，意味着fork过程消耗较多的CPU资源，也会导致较大的磁盘I/O。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>优势：</strong> </p><ul><li>适合大规模的数据恢复，因为整个持久化过程中不需要主进程进行操作，而是用新创建的子进程来完成的，因此性能很高；</li><li>对于灾难恢复、数据迁移等情况非常友好，因为 RDB 文件可以转移到任何需要的地方并重新加载；</li><li>RDB是一个紧凑压缩的二进制文件，代表Redis在某一个时间点上的数据快照，非常适合用于备份、全量复制等场景。</li></ul><p><strong>缺点：</strong></p><ul><li>RDB方式无法做到实时或秒级持久化。因为持久化过程是通过fork子进程后由子进程完成的，子进程的内存只是在fork操作那一时刻父进程的数据快照，而fork操作后父进程持续对外服务，内部数据时刻变更，子进程的数据不再更新，两者始终存在差异，所以无法做到实时性；</li><li>RDB持久化过程中的fork操作，会导致内存占用加倍，而且父进程数据越多，fork过程越长；</li><li>Redis请求高并发可能会频繁命中save规则，导致fork操作及持久化备份的频率不可控；</li><li>RDB文件有文件格式要求，不同版本的Redis会对文件格式进行调整，存在老版本无法兼容新版本的问题。</li></ul><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>由于 RDB 无法保证实时性持久化，这对于缓存丢失零容忍的系统来说是个硬伤，于是就有了AOF。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>AOF的持久化对象是Redis内每一个key的状态，持久化的目的是为了在Reids发生故障重启后能够恢复至重启前或故障前的状态。相比于RDB，AOF采取的策略是按照执行顺序持久化每一条能够引起Redis中对象状态变更的命令，命令是有序的、有选择的。把 aof 文件转移至任何一台 Redis Server，从头到尾按序重放这些命令即可恢复如初。</p><p>例如：</p><p>首先执行指令 <code>set number 0</code>，然后随机调用 <code>incr number</code>、<code>get number</code> 各5次，最后再执行一次<code>get number</code> ，我们得到的结果肯定是5。</p><p>因为在这个过程中，能够引起number状态变更的只有set/incr类型的指令，并且它们执行的先后顺序是已知的，无论执行多少次get都不会影响number的状态。所以，保留所有set/incr命令并持久化至aof文件即可。按照aof的设计原理，aof文件中的内容应该是这样的（这里是假设，实际为RESP协议）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">set number 0<br>incr number<br>incr number<br>incr number<br>incr number<br>incr number<br></code></pre></td></tr></tbody></table></figure><p>考虑实际生产环境的复杂性及操作系统等方面的限制，Redis所要考虑的工作要比这个例子复杂的多.</p><h3 id="持久化流程"><a href="#持久化流程" class="headerlink" title="持久化流程"></a>持久化流程</h3><p>从流程上来看，AOF的工作原理可以概括为几个步骤：命令追加（append）、文件写入与同步（fsync）、文件重写（rewrite）、重启加载（load）</p><p><strong>命令追加</strong></p><p>当 AOF 持久化功能处于打开状态时，Redis 在执行完一个写命令之后，会以协议格式 (也就是RESP，即 Redis 客户端和服务器交互的通信协议) 把被执行的写命令追加到 Redis 服务端维护的 AOF 缓冲区末尾。</p><p><strong>文件写入与同步</strong></p><p>Redis每次事件轮训结束前（beforeSleep）都会调用函数flushAppendOnlyFile，flushAppendOnlyFile会把AOF缓冲区（aof_buf）中的数据写入内核缓冲区，并且根据appendfsync配置来决定采用何种策略把内核缓冲区中的数据写入磁盘，即调用fsync()。</p><p><strong>文件重写</strong></p><p>Redis长时间运行，命令不断写入AOF，文件会越来越大，不加控制可能影响宿主机的安全。</p><p>为了解决AOF文件体积问题，Redis引入了AOF文件重写功能，它会根据Redis内数据对象的最新状态生成新的AOF文件，新旧文件对应的数据状态一致，但是新文件会具有较小的体积。重写既减少了AOF文件对磁盘空间的占用，又可以提高Redis重启时数据恢复的速度。例如上面的例子可以重写为：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220213165904.png"></p><p><strong>数据加载</strong></p><p>Redis启动后通过loadDataFromDisk函数执行数据加载工作。这里需要注意，虽然持久化方式可以选择AOF、RDB或者两者兼用，但是数据加载时必须做出选择，两种方式各自加载一遍就乱套了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>优点</strong></p><ul><li>AOF持久化有更好的实时性</li><li>AOF文件只有append操作，无复杂的seek等文件操作，没有损坏风险。</li><li>当AOF文件变大时，Redis可在后台自动重写。</li><li>AOF文件以易于理解与解析的方式包含了对Redis中数据的所有操作命令。即使不小心错误的清除了所有数据，只要没有对AOF文件重写，我们就可以通过移除最后一条命令找回所有数据。</li><li>AOF已经支持混合持久化，文件大小可以有效控制，并提高了数据加载时的效率。</li></ul><p><strong>缺点</strong></p><ul><li>对于相同的数据集合，AOF文件通常会比RDB文件大；</li><li>在特定的fsync策略下，AOF会比RDB略慢；</li><li>在AOF上，Redis曾经遇到一些几乎不可能在RDB上遇到的罕见bug</li></ul><h1 id="Redis-中的数据过期策略"><a href="#Redis-中的数据过期策略" class="headerlink" title="Redis 中的数据过期策略"></a>Redis 中的数据过期策略</h1><h2 id="Redis-给缓存数据设置过期时间有什么用"><a href="#Redis-给缓存数据设置过期时间有什么用" class="headerlink" title="Redis 给缓存数据设置过期时间有什么用"></a>Redis 给缓存数据设置过期时间有什么用</h2><p>首先肯定是因为内存是有限的，如果缓存中的所有数据都是一直保存的话，那么很容易耗尽内存。同时，由于业务场景就是需要某个数据只在某一时间段内存在，例如短信验证码、用户登录的 token 的有效期都是有限的，如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。因此需要采用 redis 来给缓存数据设置过期时间。</p><h2 id="Redis-是如何判断数据是否过期的"><a href="#Redis-是如何判断数据是否过期的" class="headerlink" title="Redis 是如何判断数据是否过期的"></a>Redis 是如何判断数据是否过期的</h2><p>Redis 通过过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><h2 id="过期数据的删除策略"><a href="#过期数据的删除策略" class="headerlink" title="过期数据的删除策略"></a>过期数据的删除策略</h2><p>假设设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？常用的过期数据的删除策略有两个：</p><ol><li><p>惰性删除：<strong>每次从数据库获取key的时候去检查是否过期</strong>，若过期，则删除，返回null。</p><p>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步</p><p>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p></li><li><p>定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作。同时，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</p><p>优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用；定期删除过期key</p><p>缺点：对内存 CPU 不够友好</p></li></ol><h2 id="Redis-内存淘汰机制"><a href="#Redis-内存淘汰机制" class="headerlink" title="Redis 内存淘汰机制"></a>Redis 内存淘汰机制</h2><p>定期删除和惰性删除仍然可能漏掉了很多过期 key，导致大量过期 key 堆积在内存里，引发内存泄漏，因此可以采用内存淘汰机制来解决这一问题。</p><p>共有八种内存淘汰策略：</p><p><strong>两种 LRU (最近最少被使用) 策略：</strong></p><ul><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key</li></ul><p><strong>两种 LFU （最近最少使用频次）策略：</strong></p><ul><li>volatile-lfu：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰</li><li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ul><blockquote><p>LRU 与 LFU 的区别：</p><p>假设 LFU 的访问时期设定为 10 分钟，有 1、2、3、4 几个页面，访问顺序依次为 2 1 2 1 2 3 4</p><p>若此时内存已满，需要对页面进行淘汰，若按LRU算法，应替换掉页面1。因为页面1是最长时间没有被使用的了，页面2和3都在它后面被使用过；若按LFU算法，应替换掉页面3。因为在这段时间内，页面1被访问了2次，页面2被访问了3次，而页面3只被访问了1次，一段时间内被访问的次数最少。</p></blockquote><p>剩余的四种策略：</p><ul><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li><li>allkeys-random：从数据集中任意选择数据淘汰</li><li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</li></ul><h1 id="Redis-bigkey"><a href="#Redis-bigkey" class="headerlink" title="Redis bigkey"></a>Redis bigkey</h1><h2 id="什么是-bigkey？"><a href="#什么是-bigkey？" class="headerlink" title="什么是 bigkey？"></a>什么是 bigkey？</h2><p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。</p><h2 id="bigkey-有什么危害？"><a href="#bigkey-有什么危害？" class="headerlink" title="bigkey 有什么危害？"></a>bigkey 有什么危害？</h2><ul><li>内存空间不均匀：会不利于集群对内存的统一管理，存在丢失数据的隐患。</li><li>超时阻塞：由于Redis单线程的特性，操作bigkey的通常比较耗时，也就意味着阻塞Redis可能性越大，这样会造成客户端阻塞或者引起故障切换，它们通常出现在慢查询中。</li><li>网络拥塞：bigkey也就意味着每次获取要产生的网络流量较大，而且一般服务器会采用单机多实例的方式来部署，也就是说一个bigkey可能会对其他实例造成影响，其后果不堪设想。</li><li>过期删除：对 bigkey 进行删除时会存在阻塞Redis的可能性</li><li>迁移困难</li></ul><h1 id="如何发现-bigkey？"><a href="#如何发现-bigkey？" class="headerlink" title="如何发现 bigkey？"></a>如何发现 bigkey？</h1><ul><li><p>使用 Redis 自带的 –bigkeys 参数来查找。</p><p>这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构占用内存最大的 bigkey</p></li><li><p>分析 RDB 文件</p></li></ul><h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h1><p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： 1. 原子性，2. 隔离性，3. 持久性，4. 一致性。</p><blockquote><p>原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； </p><p>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； </p><p>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 </p><p>一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。</p></blockquote><p>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</p><p>可以将 Redis 中的事务就理解为 ：Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><h2 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起针对该数据请求，例如我们数据库的 id 都是 1 开始自增上去的，而用户不断发起针对id值为 -1 的数据或 id 为特别大不存在的数据的请求。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</p><h2 id="缓存穿透情况的处理流程是怎样的"><a href="#缓存穿透情况的处理流程是怎样的" class="headerlink" title="缓存穿透情况的处理流程是怎样的"></a>缓存穿透情况的处理流程是怎样的</h2><p>如下图所示，用户的请求最终都要跑到数据库中查询一遍。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220213185117.png"></p><h2 id="有哪些解决办法"><a href="#有哪些解决办法" class="headerlink" title="有哪些解决办法"></a>有哪些解决办法</h2><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><h3 id="缓存无效-key"><a href="#缓存无效-key" class="headerlink" title="缓存无效 key"></a>缓存无效 key</h3><p>如果缓存和数据库都查不到某个 key 的数据，就写一个到 Redis 中去并设置过期时间，这种方式可以解决请求的 key 变化不频繁的情况。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点，比如 1 分钟。</p><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>通过布隆过滤器，我们可以非常方便地判断一个给定数据是否存在于海量数据中。当一个元素进入布隆过滤器时，会进行如下的操作：</p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）；</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</p><p>因此，可以用 布隆过滤器 缓解缓存穿透问题，具体做法为：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会进入数据库中查询。</p><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>数据库中有的某条数据，缓存中没有，一般是该缓存突然失效，此时如果有大量用户请求该数据，缓存中没有就会去数据库请求，会引发数据库压力增大，可能被击垮。</p><p>针对该问题，一般有以下做法：</p><ol><li>如果是热点数据，那么可以考虑设置为永不过期</li><li>如果数据一定会过期，那么需要在数据是空的时候，设置一个互斥锁，只允许一个请求通过，只让一个请求去数据库拉取数据，取完数据无论如何都要释放锁，否则其他线程会无法获取锁。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getProductDescById</span><span class="hljs-params">(String id)</span> {<br>   <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> redis.get(id);<br>   <span class="hljs-comment">// 缓存为空，过期了</span><br>   <span class="hljs-keyword">if</span>(desc == <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 互斥锁，只有一个请求可以成功</span><br>      <span class="hljs-keyword">if</span>(redis.setnx(lock_id, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>) == <span class="hljs-number">1</span>) {<br>         <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 从数据库取出数据</span><br>            desc = getFromDB(id);<br>            redis.set(id, desc, <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>);<br>         } <span class="hljs-keyword">catch</span>(Exception ex) {<br>            LogHelper.error(ex);<br>         } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 确保最后删除释放锁</span><br>            redis.del(lock_id);<br>            <span class="hljs-keyword">return</span> desc;<br>         }<br>      } <span class="hljs-keyword">else</span> {<br>         <span class="hljs-comment">// 否则休眠200ms，重新尝试获取锁</span><br>         Thread.sleep(<span class="hljs-number">200</span>);<br>         <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getProductDescById</span><span class="hljs-params">(String id)</span> {<br>   <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> redis.get(id);<br>   <span class="hljs-comment">// 缓存为空，过期了</span><br>   <span class="hljs-keyword">if</span>(desc == <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 互斥锁，只有一个请求可以成功</span><br>      <span class="hljs-keyword">if</span>(redis.setnx(lock_id, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>) == <span class="hljs-number">1</span>) {<br>         <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 从数据库取出数据</span><br>            desc = getFromDB(id);<br>            redis.set(id, desc, <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>);<br>         } <span class="hljs-keyword">catch</span>(Exception ex) {<br>            LogHelper.error(ex);<br>         } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 确保最后删除释放锁</span><br>            redis.del(lock_id);<br>            <span class="hljs-keyword">return</span> desc;<br>         }<br>      } <span class="hljs-keyword">else</span> {<br>         <span class="hljs-comment">// 否则休眠200ms，重新尝试获取锁</span><br>         Thread.sleep(<span class="hljs-number">200</span>);<br>         <span class="hljs-keyword">return</span> getProductDescById(id);<br>      }<br>   }<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h2><p>缓存雪崩描述的就是这样一个简单的场景：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</p><p>例如：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>热点数据可以考虑永不过期</li><li>缓存过期时间除非业务要求十分严格，否则可以考虑设置为波动的随机值，例如理论要求10分钟，那么可以加一个1到3的随机值，让过期时间在 7~13 分钟内波动，从而防止在同一个时间的大规模过期</li><li>如果所有的热点数据都在同一台 Redis 服务器上也是非常危险的，因此可以考虑将热点数据打散分到不同的机房中</li><li>考虑双缓冲方式，数据库数据同步到缓存 A 与 B，A 设置过期时间，B 不设置过期时间，当 A 为空的时候去读取 B，同时异步更新缓存。</li></ol><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间，比如随机设置缓存的失效时间</li><li>缓存永不失效</li></ol><h1 id="在实际项目中使用缓存有遇到什么问题？"><a href="#在实际项目中使用缓存有遇到什么问题？" class="headerlink" title="在实际项目中使用缓存有遇到什么问题？"></a>在实际项目中使用缓存有遇到什么问题？</h1><p>缓存和数据库数据一致性问题：分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。</p><h1 id="如何保证缓存和数据库数据的一致性"><a href="#如何保证缓存和数据库数据的一致性" class="headerlink" title="如何保证缓存和数据库数据的一致性"></a>如何保证缓存和数据库数据的一致性</h1><h2 id="如何提高缓存利用率"><a href="#如何提高缓存利用率" class="headerlink" title="如何提高缓存利用率"></a>如何提高缓存利用率</h2><p>缓存中只保留最近访问的「热数据」。具体的方法为：</p><ol><li>写请求依旧只写数据库</li><li>读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存</li><li>同时，写入缓存中的数据，都设置失效时间</li></ol><p>这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「热数据」，缓存利用率得以最大化。</p><h2 id="如何保持数据一致性"><a href="#如何保持数据一致性" class="headerlink" title="如何保持数据一致性"></a>如何保持数据一致性</h2><p>可以采取更新 DB，然后直接删除 cache 的方式，如果更新数据库成功，而删除缓存这一步失败的情况的话，存在两种解决方案：</p><ol><li>缓存失效时间变短（不推荐，治标不治本） ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li>增加 cache 更新重试机制（常用）：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li></ol><h1 id="Redis-与-DB-之间如何保持一致性"><a href="#Redis-与-DB-之间如何保持一致性" class="headerlink" title="Redis 与 DB 之间如何保持一致性"></a>Redis 与 DB 之间如何保持一致性</h1><p>更新缓存的方案主要有四种：Cache aside，Read through，Write through，Write behind caching</p><h2 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h2><ul><li>失效：应用程序先从 cache 读取数据，若没有得到，则从数据库中取数据，成功后，放入缓存</li><li>命中：应用程序从缓存取数据，取到后返回</li><li>更新：先把数据放入数据库，成功后，使缓存失效</li></ul><p>因此，该操作是 <strong>先更新数据库，再使缓存失效</strong></p><p>为什么不是写完数据库后直接更新缓存呢？主要是怕两个并发的写操作导致脏数据。</p><p>该方法仍然有可能存在问题：假设对数据库有一个读操作，且没有命中缓存，该操作去数据库读取数据。此时来了一个写操作，写完数据库后，让缓存失效，此时读操作又把老的数据放入缓存，导致了缓存的脏数据。</p><p>但是该种操作实际出现的概率可能非常低，因为实际上写操作比读操作慢得多，还要锁表，因此读操作必须在写操作之前进入数据库，又要在写操作之后更新缓存，概率很小。</p><h2 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h2><p>该模式是把更新数据库的操作交由缓存代理，也就是应用认为后端就是一个单一的存储，而存储自己维护自己的缓存</p><h3 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read Through"></a>Read Through</h3><p>在查询操作中更新缓存，也就是说，当缓存失效时，cache aside 是由调用方负责将数据加载入缓存，而 read through 则是利用缓存服务自己来完成加载，对于应用方来说是透明的。</p><h3 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h3><p>更新数据时发生，当有数据更新时，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由缓存自己更新数据库。</p><h3 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h3><p>更新数据时，只更新缓存不更新数据库，缓存最后会异步地批量更新数据库。但是数据不是强一致性的，还会导致丢失。</p><h1 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>没有采用 C 语言传统的字符串表示（即空字符结尾的字符数组），而是创建了 SDS 抽象类型。该类型包括以下优点</p><ol><li><p>常数复杂度获取字符串长度</p></li><li><p>杜绝缓存区溢出</p><p>在进行修改前先判断 SDS 空间是否满足修改所需的要求，若不满足则自动执行空间扩展</p></li><li><p>减少修改字符串带来的内存重分配次数</p><p>实现了 空间预分配 与 惰性空间释放 两种策略</p><p>空间预分配指的是在对字符串进行空间扩展时，扩展的内存比需要的多，从而减少字符串增长所需的内存重分配次数</p><p>惰性空间释放是指，缩短字符串时，不立即使用内存重新分配来回收缩短后的内存空间</p></li><li><p>二进制安全</p><p>C 字符串以空字符作为结束标志，对于二进制文件，也可能包含空字符，导致 C 字符串无法正常存取，而 SDS 则杜绝了这一问题</p></li><li><p>兼容部分 C 字符串函数</p><p>SDS 虽然不以空字符判断结尾，但是仍然以空字符结尾，因此 C 的 API 仍然可用</p></li></ol><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>由于 C 没有实现链表，因此 Redis 实现了自己的链表结构，特点包括：</p><ul><li>双端</li><li>无欢</li><li>带表头与表尾指针，获取头部与尾部的复杂度为 O(1)</li><li>带长度计数器</li><li>多态：能够保存不同类型的值</li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>同样实现了自己的字典</p><p>采用链地址法解决哈希冲突</p><p>当哈希表进行扩容和收缩时，采用 Rehash (重新散列)</p><p>如果扩展则基于原哈希表创建一个大小等于二倍原大小的哈希表，如果收缩则创建原大小一半的哈希表，并重新计算索引值，迁徙键值对，释放原哈希表的内存空间</p><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>采用跳表实现</p><p>跳表类似于增加了索引的链表，通过增加多级索引减少了搜索次数</p><h2 id="与平衡树、哈希表的比较"><a href="#与平衡树、哈希表的比较" class="headerlink" title="与平衡树、哈希表的比较"></a>与平衡树、哈希表的比较</h2><p>首先哈希表不是有序排列的，不适宜进行范围查找</p><p>在进行范围查找时，平衡树操作更复杂，同时插入与删除操作会导致平衡树节点的调整，复杂度较高</p><p>跳表的查找时间复杂度为 O(log n)， 最坏复杂度为O(n)</p><h1 id="基于-Redis-实现分布式锁"><a href="#基于-Redis-实现分布式锁" class="headerlink" title="基于 Redis 实现分布式锁"></a>基于 Redis 实现分布式锁</h1><h2 id="使用-setnx-实现分布式锁"><a href="#使用-setnx-实现分布式锁" class="headerlink" title="使用 setnx 实现分布式锁"></a>使用 setnx 实现分布式锁</h2><p>使用 Redis 的 SETNX 命令能够保证只有一次能写入成功，但是该方法可能会带来问题：如果仅仅使用 SETNX 命令，当某个节点抢占到锁，如果此时该节点宕机，那么这个锁就不会被释放，导致出现死锁。</p><p>为了解决这个问题，可以采用 SETNX + EXPIRE 共同实现分布式锁的策略</p><h2 id="使用-SETNX-和-EXPIRE-实现分布式锁"><a href="#使用-SETNX-和-EXPIRE-实现分布式锁" class="headerlink" title="使用 SETNX 和 EXPIRE 实现分布式锁"></a>使用 SETNX 和 EXPIRE 实现分布式锁</h2><p>在使用 SETNX 获取锁之后，可以通过 EXPIRE 为锁加一个过期时间，利用缓存失效策略对锁进行超时清除。</p><p>然而，在 Redis 中，SETNX 和 EXPIRE 这两条命令都不具有原子性，如果一个线程在执行完 SETNX 之后突然崩溃，导致锁没有设置过期时间，那么这个锁就会一直存在，无法被其他线程获取。</p><h2 id="使用-SETNX-value值设置为-系统时间-过期时间"><a href="#使用-SETNX-value值设置为-系统时间-过期时间" class="headerlink" title="使用 SETNX + value值设置为 系统时间+过期时间"></a>使用 SETNX + value值设置为 系统时间+过期时间</h2><p>为了解决 SETNX 和 EXPIRE 发生异常导致锁得不到释放的情况，还可以将过期时间放入 SETNX 的 value 值中，如果加锁失败，则直接将 value 值取出进行校验。</p><p>该方案的优点在于，移除了采用 EXPIRE 设置过期时间的操作，而是将过期时间放入 SETNX 的 value 值中。</p><p>然而该方案也存在别的缺点，一方面是该锁没有保存锁持有者的唯一标识，可能会被其他的客户端释放；一方面是加锁成功的锁过期时间可能会被别的客户端所覆盖</p><h2 id="使用-Lua-脚本"><a href="#使用-Lua-脚本" class="headerlink" title="使用 Lua 脚本"></a>使用 Lua 脚本</h2><p>使用 Lua 脚本能够解决上述的原子性问题，但是 setnx 锁最大的缺点是它加锁时只作用于一个 Redis 节点上，即使 Redis 通过 哨兵 模式保证了高可用，如果 master 节点发生了主从切换，那么就会出现锁丢失的情况。有时候新选出来的 master 节点可以重新获取同样的锁，导致出现一把锁被拿两次的场景。</p><h2 id="使用-SET-的扩展命令"><a href="#使用-SET-的扩展命令" class="headerlink" title="使用 SET 的扩展命令"></a>使用 SET 的扩展命令</h2><p>SET EX PX NX 命令也是原子性的</p><p>其中，NX 表示只有当 key 不存在时才能设置成功，保证了只有第一个客户端请求才能获得锁，其他客户端请求只能等其释放锁才能获取</p><p>EX seconds 设定了 key 的过期时间</p><p>PX milliseconds 设定了 key 的过期时间，单位为毫秒</p><p>XX 仅当 key 存在时设置值</p><p>仍然可能存在的问题：</p><ul><li>在业务执行完之前，锁过期释放了</li><li>锁可能被别的线程误删：线程 a 执行完后，去释放锁，但是此时的锁可能是线程 b 持有的，即线程 a 释放锁时，线程 b 进来占有了锁，那么线程 a 就错误地把 b 的锁释放了</li></ul><h2 id="SET-EX-PX-NX-校验唯一随机值，再删除"><a href="#SET-EX-PX-NX-校验唯一随机值，再删除" class="headerlink" title="SET EX PX NX + 校验唯一随机值，再删除"></a>SET EX PX NX + 校验唯一随机值，再删除</h2><p>为了解决锁可能被别的线程误删的问题，可以给 value 设置一个随机数来标记当前线程，在删除时进行校验。</p><p>为了保证判断是不是当前线程加的锁和释放锁这两步是一个原子操作，一般采用 Lua 脚本来执行命令。</p><h2 id="Redisson-框架"><a href="#Redisson-框架" class="headerlink" title="Redisson 框架"></a>Redisson 框架</h2><p>为了解决业务没执行完锁就过期释放的问题，可以采用开源框架 Redisson。这个框架在线程 A 加锁成功后，会启动一个 watch dog 后台线程，该线程会每隔 10 秒检查一下，如果该线程还持有锁，那么就会不断延长锁的过期时间，从而解决该问题</p><h2 id="多机实现的分布式锁-Redlock-Redisson"><a href="#多机实现的分布式锁-Redlock-Redisson" class="headerlink" title="多机实现的分布式锁 Redlock + Redisson"></a>多机实现的分布式锁 Redlock + Redisson</h2><p>由于 Redis 通常是集群部署的，在集群部署时，分布式锁可能会出现一个问题：如果线程 A 在 Redis 的 master 节点上拿到了锁，但是加锁的 key 还没有同步到 slave 节点，恰好此时 master 宕机，一个 slave 节点就会升级为 master 节点，线程 B 就能够获得该 key 的锁，相当于 A、B 两个线程同时获得了锁，失去了安全性</p><p>为了解决上述问题，Redis 的作者提出了一种高级的分布式锁算法 Redlock，其核心思想为：</p><p>设置多个 Redis master 部署，保证其不会同时宕机，并且这些 master 是完全相互独立的，相互之间不存在数据同步、主从复制或其他集群协调机制</p><p>假设有 5 个 master 节点，在这些节点上运行 Redis 实例，RedLock 的实现步骤为：</p><ul><li>获取当前 Unix 时间，单位毫秒</li><li>依次尝试向 5 个实例，使用相同的 key 和具有唯一性的 value(例如 UUID + threadId)获取锁，客户端会设置一个网络连接和响应超时时间，并且该时间需要小于锁的失效时间(假设锁自动失效时间为 10s，则超时时间设置为 5-50ms 之间)，如果超时则跳过该 master 节点，尽快去尝试下一个节点。这样可以防止服务端 Redis 宕机的情况下依然等待锁</li><li>客户端使用当前时间减去开始获取锁的时间，得到获取锁所消耗的时间。当且仅当超过一半的 master 节点都获得锁，并且使用的时间小于锁失效时间时，才算获取锁成功</li><li>获取锁之后，key 的真正有效时间也发生了改变，需要减去获取锁所消耗的时间</li><li>若获取锁失败，还需要在所有 master 上解锁，即使某些 Redis 实例根本没有加锁，这是为了防止某些节点获取到锁但是客户端没有得到响应，而导致接下来的一段时间都无法获取锁。</li></ul><h1 id="Redis-快的原因"><a href="#Redis-快的原因" class="headerlink" title="Redis 快的原因"></a>Redis 快的原因</h1><p>首先，Redis是一个单线程应用，所说的单线程指的是 Redis 使用单个线程处理客户端的请求。</p><p>虽然Redis是单线程的应用，但是即便不通过部署多个 Redis 实例和集群的方式来提升系统吞吐， 从官网给出的数据可以看出，Redis处理速度依然非常快。</p><p>Redis性能非常高的原因主要有以下几点：</p><ul><li>内存存储：Redis是使用内存(in-memeroy)存储,没有磁盘IO上的开销</li><li>单线程实现：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销</li><li>非阻塞IO：Redis使用多路复用IO技术，在poll，epool，kqueue选择最优IO实现</li><li>优化的数据结构：Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能</li></ul><p>接下来将主要介绍非阻塞IO和优化的数据结构两部分</p><h1 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h1><h2 id="什么是-IO-多路复用"><a href="#什么是-IO-多路复用" class="headerlink" title="什么是 IO 多路复用"></a>什么是 IO 多路复用</h2><p><strong>多进程</strong></p><p>首先从多进程说起，对于常见的并发情况，假如一个线程不能处理，那么增加多个线程不就可以同时处理多个客户端连接了么？多线程这种方式的确可以解决了服务器在同一时间能处理多个客户端连接请求的问题，但是仍存在一些缺点：</p><ul><li>进程之间需要进行上下文切换，效率较低</li><li>进程创建的数量随着连接请求的增加而增加，数量越多，开销越大</li><li>进程与进程之间的地址空间是私有、独立的，使得进程之间的数据共享变得困难</li></ul><p><strong>多线程</strong></p><p>线程是运行在进程上下文的逻辑流，一个进程可以包含多个线程，多个线程运行在同一进程上下文中，因此可共享这个进程地址空间的所有内容，解决了进程与进程之间通信难的问题。</p><p>同时，由于一个线程的上下文要比一个进程的上下文小得多，所以线程的上下文切换，要比进程的上下文切换效率高得多。</p><p><strong>IO 多路复用</strong></p><ul><li>多路：多个客户端连接（连接就是套接字描述符）</li><li>复用：使用单进程就能够实现同时处理多个客户端的连接</li></ul><p>因此简单理解 IO 多路复用就是：一个服务端进程可以同时处理多个套接字描述符。如果通过增加进程和线程的数量来并发处理多个套接字，免不了上下文切换的开销，而 IO 多路复用只需要一个进程就能够处理多个套接字，从而解决了上下文切换的问题。</p><p>其发展可以分 select-&gt;poll-&gt;epoll 三个阶段来描述。</p><h2 id="如何简单理解-select-poll-epoll-呢？"><a href="#如何简单理解-select-poll-epoll-呢？" class="headerlink" title="如何简单理解 select/poll/epoll 呢？"></a>如何简单理解 select/poll/epoll 呢？</h2><blockquote><p>举栗说明：</p><p>领导分配员工开发任务，有些员工还没完成。如果领导要每个员工的工作都要验收 check，那在未完成的员工那里，只能阻塞等待，等待他完成之后，再去 check 下一位员工的任务，造成性能问题。</p></blockquote><p><strong>那如何解决这个问题呢？</strong></p><p><strong>select</strong></p><blockquote><p>举栗说明：</p><p>领导找个 Team Leader（后文简称 TL），负责代自己 check 每位员工的开发任务。TL 的做法是：遍历问各个员工“完成了么？”，完成的待 CR check 无误后合并到 Git 分支，对于其他未完成的，休息一会儿后再去遍历….</p></blockquote><p>这样存在什么问题呢？</p><ul><li>这个 TL 存在能力短板问题，最多只能管理 1024 个员工</li><li>很多员工的任务没有完成，而且短时间内也完不成的话，TL 还是会不停的去遍历问询，影响效率。</li></ul><p>这个 TL 就是 select 函数，select 函数监视的文件描述符分 3 类，分别是 writefds、readfds、和 exceptfds。调用后 select 函数会阻塞，直到有描述符就绪（有数据可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 select 函数返回后，可以通过遍历 fdset，来找到就绪的描述符。</p><p>select 具有良好的跨平台支持，其缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024。</p><p><strong>poll</strong></p><blockquote><p>举栗说明：</p><p>换一个能力更强的 New Team Leader（后文简称 NTL），可以管理更多的员工，这个 NTL 可以理解为 poll。</p></blockquote><p>poll 改变了文件描述符集合的描述方式，使用了 pollfd 结构而不是 select 的 fd_set 结构，使得 poll 支持的文件描述符集合限制远大于 select 的 1024。</p><p><strong>epoll</strong></p><blockquote><p>举栗说明：</p><p>在上一步 poll 方式的 NTL 基础上，改进一下 NTL 的办事方法：遍历一次所有员工，如果任务没有完成，告诉员工待完成之后，其应该做 xx 操作（制定一些列的流程规范）。这样 NTL 只需要定期 check 指定的关键节点就好了。这就是 epoll。</p></blockquote><p>epoll 是 Linux 内核为处理大批量文件描述符而作了改进的 poll，是 Linux 下多路复用 IO 接口 select/poll 的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p><p><strong>总结</strong></p><ul><li>select 就是轮询，在 Linux 上限制个数一般为 1024 个</li><li>poll 解决了 select 的个数限制，但是依然是轮询</li><li>epoll 解决了个数的限制，同时解决了轮询的方式</li></ul><h2 id="IO-多路复用在-Redis-中的应用"><a href="#IO-多路复用在-Redis-中的应用" class="headerlink" title="IO 多路复用在 Redis 中的应用"></a>IO 多路复用在 Redis 中的应用</h2><p>Redis 服务器是一个事件驱动程序， 服务器处理的事件分为时间事件和文件事件两类。</p><ul><li>文件事件：Redis 主进程中，主要处理客户端的连接请求与响应；</li><li>时间事件：fork 出的子进程中，处理如 AOF 持久化任务等。</li></ul><p>尽管 Redis 的文件事件是单进程、单线程模型，但是却保持着优秀的吞吐量，IO 多路复用起到了主要作用。</p><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。IO 多路复用程序负责监听多个套接字并向文件事件分派器传送那些产生了事件的套接字，文件事件分派器接收 IO 多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。其具体流程如下图所示。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220223145130.png"></p><p>Redis 的 IO 多路复用程序的所有功能都是通过包装常见的 select、poll、evport 和 kqueue 这些 IO 多路复用函数库来实现的，每个 IO 多路复用函数库在 Redis 源码中都有对应的一个单独的文件。</p><p>Redis 为每个 IO 多路复用函数库都实现了相同的 API，所以 IO 多路复用程序的底层实现是可以互换的。如下图所示：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220223145323.png"></p><p>Redis 把所有连接与读写事件、还有我们没提到的时间事件一起集中管理，并对底层 IO 多路复用机制进行了封装，最终实现了单进程能够处理多个连接以及读写事件。这就是 IO 多路复用在 redis 中的应用。</p><h1 id="丰富高效的数据结构"><a href="#丰富高效的数据结构" class="headerlink" title="丰富高效的数据结构"></a>丰富高效的数据结构</h1><p>Redis 提供了丰富的数据结构，并且不同场景下提供不同实现。其共有 5 种基本的数据结构，它们分别是：string(字符串)、list(列表)、hash(字典)、set(集合) 和 zset(有序集合)。</p><h2 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h2><p>Redis 中的字符串是一种 动态字符串，这意味着使用者可以修改，它的底层实现有点类似于 Java 中的 ArrayList，有一个字符数组。从源码中可以看到 Redis 底层对于字符串的定义为 SDS，即 Simple Dynamic String 结构。</p><p>String 是 Redis 最简单最常用的数据结构，也是 Memcached 唯一的数据结构。在平时的开发中，String 可以说是使用最频繁的了。</p><p>底层实现：</p><ul><li>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。</li><li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw。</li><li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</li></ul><p>该数据结构可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储 512M</p><p>应用场景：</p><ul><li>缓存功能：string 最常用的就是缓存功能，会将一些更新不频繁但是查询频繁的数据缓存起来，以此来减轻 DB 的压力。</li><li>计数器：可以用来计数，通过 incr 操作，如统计网站的访问量、文章访问量等。</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Redis 的列表相当于 Java 语言中的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p><p>底层实现：</p><ul><li>列表对象的编码可以是 ziplist 或者 linkedlist；</li><li>列表对象保存的所有字符串元素的长度都小于 64 字节并且保存的元素数量小于 512 个，使用 ziplist 编码；否则使用 linkedlist。</li></ul><p>使用场景：</p><ul><li>消息队列：Redis 的 list 是有序的列表结构，可以实现阻塞队列，使用左进右出的方式。Lpush 用来生产 从左侧插入数据，Brpop 用来消费，用来从右侧弹出消费数据。</li><li>数据的分页展示： lrange 命令需要两个索引来获取数据，这个就可以用来实现分页，可以在代码中计算两个索引值，然后来 redis 中取数据。</li><li>可以用来实现粉丝列表以及最新消息排行等功能。</li></ul><h2 id="字典-Hash"><a href="#字典-Hash" class="headerlink" title="字典 Hash"></a>字典 Hash</h2><p>Redis 中的字典相当于 Java 中的 HashMap，内部实现也差不多类似，都是通过 “数组 + 链表” 的链地址法来解决部分 哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。</p><p>底层实现：</p><ul><li>哈希对象的编码可以是 ziplist 或者 hashtable；</li><li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节并且保存的键值对数量小于 512 个，使用ziplist 编码；否则使用hashtable。</li></ul><p>实际上 Redis 字典结构的内部包含两个 hashtable，通常情况下只有一个 hashtable 是有值的，但是在字典扩容缩容时，需要分配新的 hashtable，然后进行 渐进式搬迁</p><p><strong>渐进式 rehash</strong></p><p>大字典的扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新的数组下面，这是一个 O(n) 级别的操作，作为单线程的 Redis 很难承受这样耗时的过程，所以 Redis 使用 渐进式 rehash 小步搬迁：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220223153026.png"></p><p>渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，如上图所示，查询时会同时查询两个 hash 结构，然后在后续的定时任务以及 hash 操作指令中，循序渐进的把旧字典的内容迁移到新字典中。当搬迁完成了，就会使用新的 hash 结构取而代之。</p><p><strong>扩缩容的条件</strong></p><p>正常情况下，当 hash 表中 <strong>元素的个数等于第一维数组的长度时</strong>，就会开始扩容，扩容的新数组是 <strong>原数组大小的 2 倍</strong>。不过如果 Redis 正在做 bgsave(持久化命令)，为了减少内存，Redis 尽量不去扩容，但是如果 hash 表非常满了，达到了第一维数组长度的 5 倍了，这个时候就会 强制扩容。</p><p>当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 元素个数低于数组长度的 10%，缩容不会考虑 Redis 是否在做 bgsave。</p><p><strong>应用场景：</strong></p><ul><li>Hash 更适合存储结构化的数据，比如 Java 中的对象；其实 Java 中的对象也可以用 string 进行存储，只需要将 对象 序列化成 json 串就可以，但是如果这个对象的某个属性更新比较频繁的话，那么每次就需要重新将整个对象序列化存储，这样消耗开销比较大。可如果用 hash 来存储 对象的每个属性，那么每次只需要更新要更新的属性就可以。</li><li>购物车场景：可以以用户的id为key，商品的id 为存储的field，商品数量为键值对的value，这样就构成了购物车的三个要素。</li></ul><h2 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 Set"></a>集合 Set</h2><p>Redis 的集合相当于 Java 语言中的 HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。</p><p>底层实现：</p><ul><li>集合对象的编码可以是 intset 或者 hashtable；</li><li>集合对象保存的所有元素都是整数值并且保存的元素数量不超过 512 个，使用intset 编码；否则使用hashtable。</li></ul><p>应用场景：</p><ul><li>标签：可以将博客网站每个人的标签用 set 集合存储，然后还按每个标签将用户进行归并；</li><li>存储好友/粉丝：set 具有去重功能；还可以利用set并集功能得到共同好友之类的功能。</li></ul><h2 id="有序列表-SortedSet-（zset）"><a href="#有序列表-SortedSet-（zset）" class="headerlink" title="有序列表 SortedSet （zset）"></a>有序列表 SortedSet （zset）</h2><p>这可能是 Redis 最具特色的一个数据结构了，它类似于 Java 中 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。</p><p>基本概念：</p><p>有序集合和散列一样，都用于存储键值对：其中有序集合的每个键称为成员（member），都是独一无二的，而有序集合的每个值称为分值（score），都必须是浮点数，可以根据分数进行排序。有序集合是Redis里面唯一既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。和Redis的其他结构一样，用户可以对有序集合执行添加、移除和获取等操作。</p><p><strong>底层实现：</strong></p><p>该结构的内部实现用的是一种叫做 「跳跃表」 的数据结构，由于比较复杂，所以在这里仅仅简单提一下原理：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220223154103.png"></p><p>想象你是一家创业公司的老板，刚开始只有几个人，大家都平起平坐。后来随着公司的发展，人数越来越多，团队沟通成本逐渐增加，渐渐地引入了组长制，对团队进行划分，于是有一些人又是员工又有组长的身份。</p><p>再后来，公司规模进一步扩大，公司需要再进入一个层级：部门。于是每个部门又会从组长中推举一位选出部长。</p><p>跳跃表就类似于这样的机制，最下面一层所有的元素都会串起来，都是员工，然后每隔几个元素就会挑选出一个代表，再把这几个代表使用另外一级指针串起来。然后再在这些代表里面挑出二级代表，再串起来。最终形成了一个金字塔的结构。</p><p>应用场景：</p><ul><li>排行榜：有序集合最常用的场景。如新闻网站对热点新闻排序，比如根据点击量、点赞量等；</li><li>带权重的消息队列：重要的消息 score 大一些，普通消息 score 小一些，可以实现优先级高的任务先执行。</li></ul><p>除了上述的五种基本数据结构外，Redis 还有三种高级数据结构，分别为 HyperLogLog、GEO、Bitmap和 BloomFilter</p><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><blockquote><p>基数，可以理解为一个集合（这里的集合允许存在重复元素）中不重复元素的个数。例如集合{1,2,3,1,2}，它有5个元素，但它的基数/Distinct数为3。</p></blockquote><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>应用场景：</p><ul><li>可以用来统计网站的登陆人数以及其他指标</li></ul><h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><p>主要用来存储地理位置信息，并对存储的信息进行操作。</p><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>BitMap，即位图，也就是 byte 数组，用二进制表示，只有 0 和 1 两个数字，底层使用SDS存储。</p><p><strong>使用场景</strong></p><ul><li>日活跃用户：如果是日活跃用户的话只需要创建一个Bitmap即可，每个用户根据ID对应Bitmap中的一位，当某个用户满足活跃用户条件后，就在Bitmap中把标识此用户的位置为1。假设有1000W用户，那么只需要 1000W/8/1024/1024 差不多1.2M的空间，简直完美</li><li>布隆过滤器：根据hash算法确定key要映射到哪些bit上(一般为多个,越多冲突越小)；setbit 将对应的bit全置为1；查询时同样先hash,如果对应的映射不是都为1则说明该key一定不存在，都为1则说明可能存在。</li></ul><p>由于具备了如此丰富高效的数据结构，Redis 对于特定 key 的操作过程就可以很容易的实现，也因此成就了 Redis 的高效：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220223160058.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库</title>
      <link href="/2023/11/16/mysql-shu-ju-ku/"/>
      <url>/2023/11/16/mysql-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><h2 id="第一范式（无重复的列）"><a href="#第一范式（无重复的列）" class="headerlink" title="第一范式（无重复的列）"></a>第一范式（无重复的列）</h2><p>属性（对应于表中的字段）不能再被分割，即这个属性不能有多个值或者不能有重复的属性。1NF 是所有关系型数据库的最基本要求 ，也就是说关系型数据库中创建的表一定满足第一范式。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220222111047.png"></p><h2 id="第二范式（属性完全依赖于主键）"><a href="#第二范式（属性完全依赖于主键）" class="headerlink" title="第二范式（属性完全依赖于主键）"></a>第二范式（属性完全依赖于主键）</h2><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为了实现这样的区分，通常为表增加一列唯一的属性，用以存储区分每个实例的唯一标记。这样的属性就是常说的 <strong>主键</strong>。</p><p>例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。</p><p>简而言之，第二范式（2NF）就是 <strong>非主属性完全依赖于主关键字</strong>。</p><h2 id="第三范式（属性不依赖于其它非主属性）"><a href="#第三范式（属性不依赖于其它非主属性）" class="headerlink" title="第三范式（属性不依赖于其它非主属性）"></a>第三范式（属性不依赖于其它非主属性）</h2><p>满足第三范式（3NF）必须先满足第二范式（2NF）。第三范式（3NF）要求 <strong>一个数据库表中不包含已在其它表中包含的非主键信息</strong>。</p><p>例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。</p><p>符合 3NF 要求的数据库设计，基本上解决了 数据冗余过大，插入异常，修改异常，删除异常的问题。</p><h1 id="事务的四大特性（ACID）"><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）"></a>事务的四大特性（ACID）</h1><h2 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h2><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。</p><h2 id="原子性实现原理：undo-log"><a href="#原子性实现原理：undo-log" class="headerlink" title="原子性实现原理：undo log"></a>原子性实现原理：undo log</h2><p>实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p><p>undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</p><h2 id="一致性（Consistency"><a href="#一致性（Consistency" class="headerlink" title="一致性（Consistency)"></a>一致性（Consistency)</h2><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p><p>通俗地说，就是执行事务前后，数据应该保持一致。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的。</p><h2 id="一致性实现原理"><a href="#一致性实现原理" class="headerlink" title="一致性实现原理"></a>一致性实现原理</h2><p>一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。</p><p>实现一致性的措施包括：</p><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li><li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致</li></ul><h2 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h2><p>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</p><h2 id="隔离性实现原理"><a href="#隔离性实现原理" class="headerlink" title="隔离性实现原理"></a>隔离性实现原理</h2><p>主要分为以下两部分：</p><ul><li>(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性</li><li>(一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性</li></ul><h2 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h2><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p><p>持久性的体现就是数据一旦commit之后，那么对于数据的改变就是永久的。我们commit之后，张三的账户就永久减少了100元，李四的账户就永久增加了100元。</p><h2 id="持久性实现原理：redo-log"><a href="#持久性实现原理：redo-log" class="headerlink" title="持久性实现原理：redo log"></a>持久性实现原理：redo log</h2><p>InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。</p><p>Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p><p>于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p><p>既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：</p><ol><li>刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。</li><li>刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。</li></ol><h2 id="redo-log-与-bin-log-的区别是什么"><a href="#redo-log-与-bin-log-的区别是什么" class="headerlink" title="redo log 与 bin log 的区别是什么"></a>redo log 与 bin log 的区别是什么</h2><p>我们知道，在MySQL中还存在binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：</p><ol><li>作用不同：redo log是用于故障恢复的，保证MySQL宕机也不会影响持久性；binlog是用于时间点恢复的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。</li><li>层次不同：redo log是InnoDB存储引擎实现的，而binlog是MySQL的服务器层(可以参考文章前面对MySQL逻辑架构的介绍)实现的，同时支持InnoDB和其他存储引擎。</li><li>内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。</li><li>写入时机不同：binlog在事务提交时写入；redo log的写入时机相对多元：默认情况下是在事务提交时刷盘，但是还能够灵活设置刷盘时机，例如每秒一次，从而提升 commit 速度</li></ol><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><h2 id="并发事务可能带来的问题"><a href="#并发事务可能带来的问题" class="headerlink" title="并发事务可能带来的问题"></a>并发事务可能带来的问题</h2><p>在典型的应用程序中，多个事务并发运行，经常会对相同的数据进行操作，这会带来一系列的问题。</p><ul><li><p><strong>脏读（Dirty read）：</strong> 事务中的修改，即使没有提交，对其他事务也都是可见的。当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p></li><li><p><strong>丢失修改（Lost to modify）：</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p></li><li><p><strong>不可重复读（Unrepeatable read）:</strong> 指一个事务多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>例如，事务A第一次查询余额为100元，事务B充值100元，余额变为200元，事务B提交后，事务A第二次查询余额，此时余额变为200元，事务A提交。在事务A提交前的两次查询过程中，所得到的数据是不同的。</p></li><li><p><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。当一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时，在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p></li><li><p>不可重复读和幻读的区别：不可重复读的重点是修改，比如多次读取一条记录发现其中某些属性的值被修改；幻读的重点在于新增或者删除，比如多次读取一条记录，发现记录增多或减少了。</p></li></ul><h2 id="事务的隔离级别有哪些"><a href="#事务的隔离级别有哪些" class="headerlink" title="事务的隔离级别有哪些"></a>事务的隔离级别有哪些</h2><p>事务隔离就是为了解决上面提到的脏读、不可重复读、幻读这几个问题。</p><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被进行读取的事务本身所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><h2 id="事务隔离级别的实现原理"><a href="#事务隔离级别的实现原理" class="headerlink" title="事务隔离级别的实现原理"></a>事务隔离级别的实现原理</h2><ul><li>读取未提交：事务对当前被读取数据不加锁，都是当前读；事务更新某数据的瞬间，必须先对其加行级共享锁，直到事务结束才释放</li><li>读取已提交：事务对对当前被读取数据不加锁，并且是快照读；事务更新某数据的瞬间，必须先对其加行级排他锁（record），直到事务结束才释放</li><li>可重复读：事务对对当前被读取数据不加锁，并且是快照读；事务在更新某数据的瞬间，，必须先对其加行级排他锁（record、GAP、Next-Key），直到事务结束才释放。通过间隙锁，解决了幻读的问题；通过 MVCC 快照读，解决了不可重复读的问题</li><li>串行化：事务读取数据时，必须对其加表级共享锁，直到事务结束才释放，都是当前读；事务在更新数据时，必须对其加表级排他锁，直到事务结束才释放。</li></ul><h2 id="MySQL-的默认隔离级别"><a href="#MySQL-的默认隔离级别" class="headerlink" title="MySQL 的默认隔离级别"></a>MySQL 的默认隔离级别</h2><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要额外使用加锁读来保证。而这个加锁读使用到的机制就是 Next-Key Locks。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED (读取已提交)，但是需要知道的是，InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读） 并不会有任何性能损失。</p><p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。</p><blockquote><p>分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。</p></blockquote><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引，有什么用"><a href="#什么是索引，有什么用" class="headerlink" title="什么是索引，有什么用"></a>什么是索引，有什么用</h2><p>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</p><blockquote><p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p></blockquote><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>优点：</p><ul><li>使用索引可以大大加快数据的检索速度</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p>缺点：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h2 id="MyISAM-引擎中的索引实现"><a href="#MyISAM-引擎中的索引实现" class="headerlink" title="MyISAM 引擎中的索引实现"></a>MyISAM 引擎中的索引实现</h2><p>MyISAM 与 InnoDB 索引都基于 B+ 树实现，只不过在索引管理数据的方式上有所不同。</p><p>MyISAM 索引文件与数据文件是相互分离的，索引文件仅用于保存数据记录的地址。</p><p>对于主键索引，MyISAM 叶子结点的 data 域存储的是数据记录的地址。MyISAM 的辅助索引与主键索引在结构上没有什么区别，只是其在叶子结点处存储的是相应的列 + 行号。</p><p>MyISAM 中“索引是索引，数据是数据”，InnoDB中“索引即数据，数据即索引”</p><h2 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h2><h3 id="Hash表-B-树"><a href="#Hash表-B-树" class="headerlink" title="Hash表 &amp; B+树"></a>Hash表 &amp; B+树</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据 (接近O(1))。</p><p>哈希表能够快速根据 key 来获取 value，是因为其内部采用的哈希算法。通过哈希算法，能够快速通过 key 得到对应的 index，再通过 index 找到对应的 value。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220222143854.png"></p><p>然而，哈希算法存在 哈希冲突 的问题，当所采用的哈希函数不够先进时，就会出现多个不同的 key 通过哈希函数计算得出的 index 相同。为了解决这一问题，常用的方法是 链地址法。链地址法就是将产生哈希冲突的数据存放到链表中。在 JDK 1.8 之前，HashMap 就是通过该方法来解决哈希冲突问题的，然而在后续版本中，为了减少链表带来的过长的搜索时间，HashMap 改用红黑树来存储哈希冲突数据。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220222143907.png"></p><p>那么，<strong>为什么 MySQL 没有选择 Hash 表来作为索引的数据结构呢？</strong></p><ol><li><p>Hash 冲突问题</p></li><li><p>Hash 索引不支持顺序和范围查询：当需要对表中数据根据属性值进行排序或者范围查询时，Hash 索引就容易失效。</p><p>假如需要对 id 小于 500 的数据进行查询：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">SELECT * FROM id1 WHERE id < 500;<br></code></pre></td></tr></tbody></table></figure><p>此时的 Hash 索引是根据 hash 算法来进行定位的，需要将 id 在 1 ~ 499 的数据每个都进行一次 hash 定位，计算非常繁琐复杂。而 B+ 树则直接遍历比 500 小的叶子节点即可。</p></li></ol><h3 id="B-树-B-树"><a href="#B-树-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h3><p>B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。</p><p><strong>B 树和 B+ 树有何异同？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220222145801.png"></p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>每张表一般都会有自己的主键，mysql会在主键上建立一个索引，这就是主键索引。</p><p>在 MySQL 的 InnoDB 表中，当没有显性地指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><h3 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h3><p>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</p><p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p><ol><li><p><strong>唯一索引(Unique Key) ：</strong> 唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</p></li><li><p><strong>普通索引(Index) ：</strong> 普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</p></li><li><p><strong>前缀索引(Prefix) ：</strong> 前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</p></li><li><p><strong>全文索引(Full Text) ：</strong> 全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</p></li></ol><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220222155523.png"></p><p>对于辅助索引，叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签（bookmark)。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。</p><p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220222162730.png"></p><p>特点：</p><ul><li>手动创建，可以有多个</li><li>内节点包含索引列、主键列、页号（page_no）</li><li>叶子节点只包含索引列以及记录主键的值</li><li>每层节点都是按照索引列的值从小到大排序（索引列值相同时按照主键排序）</li></ul><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引是一种特殊的二级索引。联合索引指的是同时对多列创建的索引，创建联合索引后，叶子节点会同时包含每个索引列的值，并且同时根据多列排序，这个排序和我们所理解的字典序类似。</p><p>每个叶子节点同时保存了所有的索引列，除此之外，还是只包含了主键id。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220222163408.png"></p><p>特点：</p><ul><li>手动创建，可以有多个</li><li>内节点包含索引列、主键列、页号</li><li>叶子节点只包含索引列以及记录主键的值</li><li>每层节点先按照索引中的第1列排序。第1列值相等时，按第2列排序。第2列值相等时，按第3列排序 依次类推，所有列都相等时按照主键排序。</li></ul><h3 id="覆盖索引（covering-index）"><a href="#覆盖索引（covering-index）" class="headerlink" title="覆盖索引（covering index）"></a>覆盖索引（covering index）</h3><p>在流程中从非主键索引树搜索回到主键索引树搜索的过程称为：回表，例如下图所示的两颗索引树，执行如下代码的流程为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">SELECT age FROM student WHERE name = '小李'；<br></code></pre></td></tr></tbody></table></figure><ol><li>在name索引树上找到名称为小李的节点 id为03</li><li>从id索引树上找到id为03的节点，获取所有数据</li><li>从数据中获取字段命为age的值返回 12</li></ol><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220222164013.png"></p><p>覆盖索引即从非主键索引中就能得到查询的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。</p><p>那么如何使用覆盖索引呢？</p><p>之前我们已经建立了表student，那么现在出现的业务需求中要求根据名称获取学生的年龄，并且该搜索场景非常频繁，那么先在我们删除掉之前以字段name建立的普通索引，以name和age两个字段建立联合索引，sql命令与建立后的索引树结构如下</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220222164954.png"></p><p>再次执行上文的 sql 语句后，流程变为：</p><ol><li>在name,age联合索引树上找到名称为小李的节点</li><li>此时节点索引里包含信息age 直接返回 12</li></ol><h2 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h2><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220222161618.png"></p><p>特点：</p><ul><li>自动建立，一个表只有1个。</li><li>叶子节点包含所有用户记录（包括隐藏列），record_type为0</li><li>每层节点都是按照主键从小到大排序</li><li>内节点（非叶子节点）：存储主键值以及页号， record_type为1</li></ul><p>聚集索引的优点</p><p>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p><p>聚集索引的缺点</p><ul><li>依赖于有序的数据：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li>更新代价大：如果对索引列的数据进行修改时，那么对应的索引也将会被修改，同时聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li></ul><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引。</p><blockquote><p>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p></blockquote><p>非聚集索引的优点</p><p>更新代价比聚集索引要小，因为非聚集索引的叶子节点是不存放数据的</p><p>非聚集索引的缺点</p><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li>可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ol><h2 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h2><ol><li><p>选择合适的字段创建索引</p><ul><li><p>不为 NULL 的字段</p></li><li><p>被频繁查询的字段</p></li><li><p>被作为条件查询的字段</p></li><li><p>频繁需要排序的字段</p></li><li><p>被经常频繁用于连接的字段</p></li></ul></li><li><p>被频繁更新的字段应该慎重建立索引</p></li><li><p>尽可能考虑建立联合索引而不是单列索引</p></li><li><p>注意避免冗余索引</p></li><li><p>考虑在字符串类型的字段上使用前缀索引代替普通索引</p></li></ol><h1 id="数据库视图是什么？有什么作用？"><a href="#数据库视图是什么？有什么作用？" class="headerlink" title="数据库视图是什么？有什么作用？"></a>数据库视图是什么？有什么作用？</h1><p>视图即从一个或几个基本表中导出的表，它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。</p><p>所以基本表中的数据发生变化，从视图中查询得到的数据也就随之改变。</p><p>作用：</p><ol><li>隐藏了底层的表结构，简化了数据访问操作，客户端不再需要底层表的结构及其之间的关系</li><li>视图提供了一个统一访问数据的接口</li><li>加强了安全性，使用户只能看到视图所显示的数据</li><li>视图还可以被嵌套，一个视图中可以嵌套另一个视图。</li></ol><h1 id="一条-SQL-语句是怎么运行的"><a href="#一条-SQL-语句是怎么运行的" class="headerlink" title="一条 SQL 语句是怎么运行的"></a>一条 SQL 语句是怎么运行的</h1><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><p>先检查该语句是否有权限，若无权限则返回错误结果，如果有权限则先查询数据库缓存，若缓存中无结果则进行下一步</p><p>通过分析器进行词法分析，提取sql语句关键元素，并判断该语句是否存在语法错误，若没问题则进行下一步</p><p>优化器确定执行方案，并选择自认为效率最高的方案</p><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，并返回执行结果</p><h2 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h2><p>先查询该语句中的数据，如果有缓存，同样会从缓存中返回</p><p>拿到查询语句，将数据进行更改，调用引擎API接口，写入这一行数据，Innodb 引擎将数据保存在内存中，同时记录 redo log，redo log 进入 prepare 状态，并告诉执行器执行完成，随时可提交</p><p>执行器收到通知后记录 binlog，调用引擎接口，提交redo log 诶提交状态</p><p>更新完成</p><h1 id="慢查询怎么优化？"><a href="#慢查询怎么优化？" class="headerlink" title="慢查询怎么优化？"></a>慢查询怎么优化？</h1><h2 id="慢查询优化的基本步骤"><a href="#慢查询优化的基本步骤" class="headerlink" title="慢查询优化的基本步骤"></a>慢查询优化的基本步骤</h2><h3 id="开启-MySQL-慢查询"><a href="#开启-MySQL-慢查询" class="headerlink" title="开启 MySQL 慢查询"></a>开启 MySQL 慢查询</h3><p>慢查询日志用于记录在 MySQL 中响应时间超过阈值的语句</p><h3 id="分析慢查询日志"><a href="#分析慢查询日志" class="headerlink" title="分析慢查询日志"></a>分析慢查询日志</h3><p>利用 EXPLAIN 关键字来分析慢查询语句的执行情况</p><p>结果分析包括的列：</p><ul><li>TABLE：数据是关于哪张表的</li><li>TYPE：显示连接采用了何种类型，从最好到最差的连接类型依次为 const、eq_reg、ref、range、indexhe 和 all</li><li>ROWS：显示需要扫描的行数</li><li>KEY：用到的索引</li></ul><h3 id="常用的优化方式"><a href="#常用的优化方式" class="headerlink" title="常用的优化方式"></a>常用的优化方式</h3><ol><li><p>索引没起作用</p></li><li><p>优化数据结构</p><p>可以将字段很多的表分为多个表</p><p>对于经常需要联合查询的表，可以建立中间表来提高查询效率，通过建立中间表，把需要经常联合查询的数据放入中间表中，再把原来的联合查询改为对中间表的查询</p></li><li><p>分解关联查询</p><p>把一个大的查询分解为多个小查询是很有必要的</p></li><li><p>优化 LIMIT 分页</p><p>当偏移量很大时，例如 LIMIT 10000, 20 时，需要查询 10020 条数据并只返回最后 20 条，前面的数据都被舍弃，代价很高。</p><p>比较简单的优化做法是，尽可能用索引覆盖扫描，而不是查询所有列，然后根据需要做一次关联操作再返回所需列。</p><p>或者直接利用主键 ID，先查询出第 10000 条数据的值，再利用该 ID 查询后面的数据</p></li></ol><h3 id="数据库表的优化"><a href="#数据库表的优化" class="headerlink" title="数据库表的优化"></a>数据库表的优化</h3><ol><li><p>表的字段尽可能为 NOT NULL</p></li><li><p>字段长度固定的表，查询速度会更快</p></li><li><p>把数据库大表按照一定标志，分为小表</p></li><li><p>将表拆分，包括垂直拆分与水平拆分</p><p>水平拆分：将记录散列到不同的表中，每次从分表中查询</p><p>垂直拆分：将表中大字段单独拆到另外一张表中，形成一对一的关系</p></li></ol><h2 id="EXPLAIN-命令详解"><a href="#EXPLAIN-命令详解" class="headerlink" title="EXPLAIN 命令详解"></a>EXPLAIN 命令详解</h2><p>包含若干参数，重点关注 type、possible_keys、key、key_len、extra 五个</p><ul><li><p>possible_keys：此次查询中可能用到的索引</p></li><li><p>key：查询中真正用到的索引，复合索引时不能确定是否被充分使用</p></li><li><p>type：访问类型，表示 MySQL 在表中查找所需行的方式</p><p>  <img src="https://s2.loli.net/2022/05/02/aVs3rcKhguCA7t2.png"></p></li><li><p>key_len：索引中使用的字节数，用于计算索引是否被充分使用，越短越好</p><p><img src="https://s2.loli.net/2022/05/02/3e9zCwBDcUNu1yQ.png"></p></li><li><p>extra</p><p>Using WHERE 说明 SQL 使用了 WHERE 条件过滤数据</p><p>Using Index 表示已经用来覆盖索引</p></li></ul><h2 id="建索引的策略"><a href="#建索引的策略" class="headerlink" title="建索引的策略"></a>建索引的策略</h2><p><img src="https://s2.loli.net/2022/05/02/HzQW8EamJpKFsXc.png"></p><h3 id="尽量考虑覆盖索引"><a href="#尽量考虑覆盖索引" class="headerlink" title="尽量考虑覆盖索引"></a>尽量考虑覆盖索引</h3><p>覆盖索引：SQL只需要通过遍历索引树就可以返回所需要查询的数据，而不必通过辅助索引查到主键值之后再去查询数据（回表操作）。</p><h3 id="遵循最左前缀匹配"><a href="#遵循最左前缀匹配" class="headerlink" title="遵循最左前缀匹配"></a>遵循最左前缀匹配</h3><p>联合索引命中必须遵循“最左前缀法则”。即SQL查询Where条件字段必须从索引的最左前列开始匹配，不能跳过索引中的列。联合索引又称复合索引，类似于书籍的目录，多级的目录结构中子目录依赖于父级目录存在，也是遵循“最左前缀法则”。</p><h3 id="范围查询字段放最后"><a href="#范围查询字段放最后" class="headerlink" title="范围查询字段放最后"></a>范围查询字段放最后</h3><p>联合索引定义时，尽量将范围查询字段放在最后（放在最后联合索引使用最充分，放在中间联合索引使用不充分）。使用联合索引时范围列（当前范围列索引生效）后面的索引列无法生效，同时索引最多用于一个范围列，如果查询条件中有多个范围列，也只能用到一个范围列索引。</p><h3 id="不对索引字段进行逻辑操作"><a href="#不对索引字段进行逻辑操作" class="headerlink" title="不对索引字段进行逻辑操作"></a>不对索引字段进行逻辑操作</h3><p>在索引字段上进行计算、函数、类型转换（自动\手动）都会导致索引失效。</p><h3 id="尽量全值匹配"><a href="#尽量全值匹配" class="headerlink" title="尽量全值匹配"></a>尽量全值匹配</h3><p>全值匹配也就是精确匹配不使用like查询（模糊匹配），使用like会使查询效率降低。</p><h3 id="Like查询，左侧尽量不要加"><a href="#Like查询，左侧尽量不要加" class="headerlink" title="Like查询，左侧尽量不要加%"></a>Like查询，左侧尽量不要加%</h3><p>like 以 % 开头，当前列的索引无效(当为联合索引时，当前列和后续列索引不生效，可能导致索引使用不充分)；当like前缀没有%，后缀有%时，索引有效。</p><h3 id="注意NULL-NOT-NULL可能对索引有影响"><a href="#注意NULL-NOT-NULL可能对索引有影响" class="headerlink" title="注意NULL/NOT NULL可能对索引有影响"></a>注意NULL/NOT NULL可能对索引有影响</h3><p>不一定不走索引</p><h3 id="尽量减少使用-不等于"><a href="#尽量减少使用-不等于" class="headerlink" title="尽量减少使用 不等于"></a>尽量减少使用 不等于</h3><p>不等于操作符包括：not，&lt;&gt;，!=，不一定不走索引</p><p>这两条都不一定不走索引，优化器一般会对成本进行一次衡量，当走索引的成本大于全表扫描的成本时，就不会走索引</p><p>例如二级索引还有回表的操作，这样一来就有可能出现走索引速度要慢于不走索引的速度</p><h3 id="字符类型务必加上引号"><a href="#字符类型务必加上引号" class="headerlink" title="字符类型务必加上引号"></a>字符类型务必加上引号</h3><p>若varchar类型字段值不加单引号，可能会发生数据类型隐式转化，自动转换为int型，使索引无效。</p><h3 id="OR关键字前后尽量都为索引列"><a href="#OR关键字前后尽量都为索引列" class="headerlink" title="OR关键字前后尽量都为索引列"></a>OR关键字前后尽量都为索引列</h3><h2 id="建索引的原则"><a href="#建索引的原则" class="headerlink" title="建索引的原则"></a>建索引的原则</h2><ol><li>最左前缀匹配</li><li>尽量选择区分度高的列作为索引，区分度表示字段不重复的比例，比例越大所要扫描的记录越少</li><li>索引列不参与运算</li><li>尽量扩展索引而不是新建</li></ol><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs SQL"><span class="hljs-keyword">CREATE</span> INDEX indexName <span class="hljs-keyword"><code class="language-hljs SQL"><span class="hljs-keyword">CREATE</span> INDEX indexName <span class="hljs-keyword">ON</span> table_name (column_name);<br></code></pre></td></tr></tbody></table></figure><h1 id="查询平均成绩大于-60-的学生姓名"><a href="#查询平均成绩大于-60-的学生姓名" class="headerlink" title="查询平均成绩大于 60 的学生姓名"></a>查询平均成绩大于 60 的学生姓名</h1><p>一个学生表，一个分数表</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> s.name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s <span class="hljs-keyword">JOIN</span> score <span class="hljs-keyword">AS</span> sc<br><span class="hljs-keyword">ON</span> s.id <span class="hljs-operator">=</span> sc.id<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> s.name<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(sc.score) <span class="hljs-operator">&gt;=</span> <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> s.name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s <span class="hljs-keyword">JOIN</span> score <span class="hljs-keyword">AS</span> sc<br><span class="hljs-keyword">ON</span> s.id <span class="hljs-operator">=</span> sc.id<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> s.name<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(sc.score) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">60</span>;<br></code></pre></td></tr></tbody></table></figure><p>仅分数表</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> name <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(score) <span class="hljs-operator">&gt;=</span> <span class="hljs-number"><code class="language-hljs sql"><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> name <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(score) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">60</span>;<br></code></pre></td></tr></tbody></table></figure><h1 id="HAVING-字句"><a href="#HAVING-字句" class="headerlink" title="HAVING 字句"></a>HAVING 字句</h1><p>在 select 语句中使用 having 字句来指定一组行或聚合的过滤条件</p><p>having 字句通常与 group by 一起使用</p><h1 id="MySQL-有哪些锁"><a href="#MySQL-有哪些锁" class="headerlink" title="MySQL 有哪些锁"></a>MySQL 有哪些锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>执行后整个数据库就处于只读状态，主要应用于做全库逻辑备份，这样备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不同。但是当数据库中数据量大时，会花费大量时间，造成业务停滞。</p><p>为了避免数据备份时使用全局锁对业务的影响，可以采用其他方式避免。如果数据库引擎支持可重复读隔离级别，那么在备份数据库之前开启事务，会创建 Read View，在事务执行期间都会使用这个 read view，并且由于 MVCC 的支持，备份期间业务仍然能够更新数据。</p><p>因为在可重复读的隔离级别下，即使其他事务更新了表数据，也不会影响 read view，从而确保了隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</p><p>使用 mysqldump 工具备份数据库，加上 -single-transaction 参数时，就会在备份数据库之前开启事务，InnoDB 默认存储引擎就是可重复读，因此可以采用该方式备份数据库。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁有这几种：表锁、元数据锁 MDL、意向锁、AUTO-INC 锁</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 表级共享锁，即读锁<br>lock tables t_student read;<br><span class="hljs-operator">/</span><span class="hljs-operator"><code class="language-hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 表级共享锁，即读锁<br>lock tables t_student read;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 表级独占锁，即写锁<br>lock tables t_student write;<br></code></pre></td></tr></tbody></table></figure><p>如果本线程对表加了共享表锁，那么本线程接下来如果想对表进行写操作语句，是会被阻塞的，其他线程也当然会被阻塞，直到锁被释放。</p><p>由于表锁粒度太大，影响性能，因此常常采用行级锁。</p><h3 id="元数据锁-MDL"><a href="#元数据锁-MDL" class="headerlink" title="元数据锁 MDL"></a>元数据锁 MDL</h3><p>不需要显式使用 MDL，因为对数据库表进行操作时，会自动加上 MDL：</p><ul><li>进行 CRUD 操作时，加 MDL 读锁</li><li>做结构变更操作时，加 MDL 写锁</li></ul><p>MDL 的目的是保证用户对表执行 CRUD 操作时，防止其他线程对表结构做变更。当有线程执行 select 语句时，如果有其他线程想更改表结构，需要申请 MDL 写锁，会被阻塞，直到 select 语句执行完。当有线程对表结构进行变更时，如果有其他线程执行 CRUD 操作，那么就会被阻塞，直到表结构变更完。</p><p>MDL 在事务提交之后才会被释放，即事务执行期间，MDL 一直持有。这也导致会出现一些问题，例如：</p><ol><li>线程 A 启用事务，但是一直不提交，执行一条 select 语句，此时会对表加上 MDL 读锁</li><li>线程 B 执行同样的 select 语句，此时不会阻塞，因为 读读 不冲突</li><li>线程 C 修改表字段，此时由于 A 的事务未提交，即 MDL 读锁还占用着，线程 C 会被阻塞</li></ol><p>那么线程 C 被阻塞后，后续的 select 语句就都会被阻塞，如果此时大量 select 请求到达，就会有大量线程被阻塞。</p><p>造成这个问题的原因是，申请 MDL 锁的操作会形成一个队列，队列中写锁优先级高于读锁，一旦出现 MDL 写锁等待，就会阻塞后续所有操作。</p><p>为了解决这一问题，需要在变更表结构之前，先看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以最好 kill 掉这个长事务，再做表结构的变更。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><ul><li>在 InnoDB 引擎中，对某些记录加共享锁之前，需要在表级别上加一个 意向共享锁</li><li>在 InnoDB 引擎中，对某些记录加独占锁之前，需要在表级别上加一个 意向独占锁</li></ul><p>在执行插入、删除、更新时，需要对表先加上 意向共享锁，然后对该记录加独占锁，而普通的 select 不会加行级锁，而是通过 MVCC 保证一致性读，是无锁的。</p><p>如果没有 意向锁，那么加 独占表锁 时，需要遍历表中记录，查看是否有记录独占锁，降低效率。而有了 意向锁，那么只需要在加 独占表锁 时，直接查看该表是否有意向独占锁，如果有则代表已经有记录被加了独占锁，不需要遍历。</p><h3 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a>AUTO-INC 锁</h3><p>在为某个字段声明 AUTO_INCREMENT 自增属性后，之后插入数据数据库会自动给该字段赋递增的值，这是通过 AUTO-INC 锁实现的。</p><p>是特殊的表锁机制，锁不是在一个事务提交后释放，而是在执行完插入语句后立即释放。在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为自增字段赋值，等插入语句执行完后，会释放锁。</p><p>因此，一个事务在持有 AUTO-INC 锁的过程中，其他事务如果要向该表插入语句都会被阻塞，从而保证了自增字段是连续递增的。但是该锁在进行大量数据的插入时会影响性能，因此 InnoDB 引擎又提供了一种轻量级锁来完成自增。其过程是在插入数据时为自增字段加锁，然后赋值结束后就会自动释放锁，不需要等待整个插入语句执行完。</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>主要有三类：Record Lock 记录锁、Gap Lock 间隙锁、Next-Key Lock ：前两者是结合。对记录加锁时，基本单位是 Next-Key Lock ，该锁是前开后闭区间，而间隙锁是前开后开区间。</p><h3 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h3><ul><li>若查询记录存在，唯一索引等值查询时，Next-Key Lock 退化为 记录锁</li><li>若查询记录不存在，Next-Key Lock 退化为间隙锁</li></ul><p>也就是说，如果查询记录存在，那么 Next-Key Lock 只会加锁要查的那一行；如果查询记录不存在，那么会退化为间隙锁</p><h3 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h3><p>由于是范围查找，会继续往后查找已经存在的记录，所以往往会退化为间隙锁</p><h3 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h3><ul><li>若查询记录存在，除了会加 next-key lock 外，还会额外加间隙锁，也就是加两把锁</li><li>若查询记录不存在，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁</li></ul><h3 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h3><p>由于是非唯一索引，因此 next-key lock 不会退化为间隙锁和记录锁</p><h1 id="什么是-MVCC"><a href="#什么是-MVCC" class="headerlink" title="什么是 MVCC"></a>什么是 MVCC</h1><p>多版本并发控制，主要是为了提高数据库的并发性能。</p><p>当一行数据平时发生读写请求时，会上锁阻塞，而 MVCC 用更好的方式来处理 读-写 请求，从而在发生 读-写 请求冲突时不用加锁。</p><p>MVCC 的读指的是 快照读，而非当前读，普通的 当前读 采用加锁操作，是悲观锁。</p><h1 id="什么是快照读、当前读"><a href="#什么是快照读、当前读" class="headerlink" title="什么是快照读、当前读"></a>什么是快照读、当前读</h1><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>读取的数据库记录都是当前最新的版本，会对当前进行读取的数据进行加锁，防止其他事务对数据进行修改，是悲观锁的一种操作。</p><h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>快照读的实现就是基于 MVCC，其读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。</p><h2 id="快照读与-MVCC-的关系"><a href="#快照读与-MVCC-的关系" class="headerlink" title="快照读与 MVCC 的关系"></a>快照读与 MVCC 的关系</h2><p>MVCC 是一种“维持一个数据的多个版本，使得读写操作没有冲突”的一个抽象概念。这个概念的实现方法就是 快照读。</p><h1 id="MVCC-解决的问题"><a href="#MVCC-解决的问题" class="headerlink" title="MVCC 解决的问题"></a>MVCC 解决的问题</h1><h2 id="数据库并发场景"><a href="#数据库并发场景" class="headerlink" title="数据库并发场景"></a>数据库并发场景</h2><ul><li>读-读：不存在任何问题，不需要并发控制</li><li>读-写：有线程安全问题，可能造成事务隔离性问题，可能遇到脏读、幻读、不可重复读</li><li>写-写：有线程安全问题，可能造成丢失修改问题</li></ul><h2 id="MVCC-解决了哪些并发问题？"><a href="#MVCC-解决了哪些并发问题？" class="headerlink" title="MVCC 解决了哪些并发问题？"></a>MVCC 解决了哪些并发问题？</h2><p>MVCC 用来解决 读-写 冲突的无锁并发控制，其方法就是为事务分配单向增长的时间戳，为每个数据修改保存一个版本，版本与事务的时间戳相关联。</p><p>在进行读操作时，只读取该事务开始前的数据库快照。</p><p>所解决的问题主要包括：</p><ul><li>并发 读-写 时：能够做到读操作不阻塞写操作，同时写操作也不会阻塞读操作</li><li>解决了脏读、幻读、不可重复读的问题，但是不能解决丢失修改的问题</li></ul><p>可以采用 MVCC + 悲观锁、MVCC + 乐观锁 的方法解决</p><h1 id="MVCC-的实现原理"><a href="#MVCC-的实现原理" class="headerlink" title="MVCC 的实现原理"></a>MVCC 的实现原理</h1><p>主要通过 版本链、undo 日志、Read View 来实现的</p><h2 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h2><p>数据库中的每行数据中，都包括几个隐藏字段，分别是 db_trx_id、db_roll_pointer、db_row_id</p><ul><li>db_trx_id：6 byte，记录创建这条记录/最后一次修改这条记录的事务 ID</li><li>db_roll_pointer：7 byte，回滚指针，用于配合 undo 日志，指向这条记录的上一个版本</li><li>db_row_id：6 byte，隐含的自增 ID，若数据表没有主键，那么 InnoDB 会自动以该字段产生一个 聚簇索引</li></ul><p>每次对数据库记录进行改动，都会记录一条 undo 日志，每条 undo 日志都有一个 roll_pointer 属性（除了 INSERT 操作对应的日志没有该属性，因为该操作对应的记录并没有更早的版本），可以将这些 undo 日志都连起来，组成一个链表。</p><p>对该记录每次更新之后，都会把旧值放入 undo 日志中，算作是该记录的一个旧版本，随着更新次数的增多，所有版本会被 roll_pointer 属性连接为一个链表，这个链表就被称之为 版本链，版本链的头节点就是该条记录当前最新的值。</p><p>此外，每个版本中还包含生成该版本时的事务 ID。</p><h2 id="undo-日志"><a href="#undo-日志" class="headerlink" title="undo 日志"></a>undo 日志</h2><p>Undo log 主要用于记录数据被修改之前的日志，在表信息被修改之前会先把数据都拷贝到 undo log 中。当事务需要进行回滚时，可以利用该日志进行数据还原。</p><p>undo log 的用途主要有：</p><ul><li>保证事务进行 rollback 时的原子性和一致性，回滚时进行数据恢复</li><li>用于 MVCC 的快照读：MVCC 通过读取 undo log 的历史版本数据可以实现不用事务版本号都拥有自己独立的快照数据版本</li></ul><p>undo log 主要分为两种：</p><ul><li>insert undo log：代表事务在 insert 新记录时产生的 undo log，只有事务回滚时需要，在事务提交成功后可以被立即丢弃；</li><li>update undo log：事务进行 update 或者 delete 时产生的 undo log，事务回滚、快照读都需要，不可随便删除，只有在不涉及该日志之后，才会被 purge 线程统一清除</li></ul><h2 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h2><p>事务进行快照读操作时生成的 读视图，在该事务执行快照读的那一刻，会生成数据库系统当前的一个快照，该快照记录并维护系统当前活跃事务的 ID（每个事务开启时，都会被分配一个 ID），是系统中当前不应该被本读事务看到的其他事务的 id 列表。</p><p>Read View 的主要目的就是进行可见性判断，即当我们的某个事务执行读操作时，对该事务创建一个 Read View，将其作为条件来确定当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该记录的 undo log 中某个版本的数据</p><p>Read View 的几个属性：</p><ul><li>当前系统活跃（未提交）的事务版本号集合</li><li>创建 Read View 时的当前系统最大事务版本号 + 1</li><li>创建 Read View 时的当前系统最小事务版本号</li><li>创建 Read View 的事务版本号</li></ul><h2 id="Read-View-可见性判断条件"><a href="#Read-View-可见性判断条件" class="headerlink" title="Read View 可见性判断条件"></a>Read View 可见性判断条件</h2><ul><li>如果数据事务 ID 小于当前活跃的最小事务 ID，可以肯定数据是早就存在了的，并且没有进行过修改，可以显示；</li><li>如果数据事务 ID 等于创建 Read View 的事务 ID，说明这个数据最后一次修改是当前的读事务进行的，因此可以显示</li><li>如果数据事务 ID 大于 Read View 中的最大事务 ID，说明这个数据是 Read View 创建之后才产生的，不能显示，否则会出现幻读</li><li>如果数据事务 ID 在当前活跃事务 ID 中，则说明当前事务还可能对数据进行修改，不能显示，否则会出现脏读或不可重复读</li><li>若数据事务 ID 不存在于活跃事务中，说明该事务已经提交了，数据可以显示</li></ul><h1 id="MVCC-和事务隔离级别"><a href="#MVCC-和事务隔离级别" class="headerlink" title="MVCC 和事务隔离级别"></a>MVCC 和事务隔离级别</h1><p>MVCC 实现了 RC （已提交读） 和 RR （可重复读） 两种隔离级别的实现</p><h2 id="怎么实现？"><a href="#怎么实现？" class="headerlink" title="怎么实现？"></a>怎么实现？</h2><ul><li>RC 隔离级别下，每个快照读都会生成并获取最新的 Read View</li><li>RR 隔离级别下，同一事务中只有第一次快照快照读才会创建 Read View，之后的快照读都使用同一个 Read View，确保每次查询结果的一致性。</li></ul><h2 id="什么区别？"><a href="#什么区别？" class="headerlink" title="什么区别？"></a>什么区别？</h2><p>在 RR 隔离级别下，仅会使用一个 Read View，哪怕后续事务提交了修改，当前事务再进行一次读数据，该数据依然和修改事务提交之前的一样，不会发送改变，不会出现不可重复读的现象，实现了 RR 隔离级别</p><p>而 RC 隔离级别下，每次读数据都会生成一个新的 Read View，导致能够看到别的数据提交的数据更新</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发四-AQS</title>
      <link href="/2023/11/16/java-bing-fa-si-aqs/"/>
      <url>/2023/11/16/java-bing-fa-si-aqs/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-AQS"><a href="#什么是-AQS" class="headerlink" title="什么是 AQS"></a>什么是 AQS</h1><p>AQS 就是一个抽象类，主要用来构建锁和同步器，使用 AQS 能够简单且高效地构造出应用广泛的大量同步器，例如常见的 ReentrantLock 就是 AQS 实现的</p><h2 id="AQS-基本原理"><a href="#AQS-基本原理" class="headerlink" title="AQS 基本原理"></a>AQS 基本原理</h2><p>AQS 的核心思想就是，如果被请求的共享资源空闲，就将当前请求该资源的线程设置为有效的工作线程，并将该共享资源设置为锁定状态。</p><p>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时的锁分配机制。该机制 AQS 是用 CLH 队列锁实现的，也就是将暂时获取不到锁的线程加入到该队列中。</p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（所谓虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p><img src="https://s2.loli.net/2022/03/04/DTdp7FcsiRhjBrN.png"></p><p>AQS 使用一个 int 成员变量来表示其同步状态，通过内置的 FIFO 队列来完成等待获取资源的线程的排队工作（多线程争用资源被阻塞时就会进入该队列）。AQS 使用 CAS 来对该同步状态进行原子操作从而实现对其值的修改。</p><h2 id="什么是-CAS？"><a href="#什么是-CAS？" class="headerlink" title="什么是 CAS？"></a>什么是 CAS？</h2><p>CAS 是一种乐观锁的实现方法，意为比较并交换。其主要操作三个值：v 表示要更新的变量；e 表示变量更新前的预期值，也就是旧值；n 表示变量更新后的新值。</p><p>在进行更新时，只有在判断得到 e 的值等于 v 变量的当前旧值之后，才会把 n 新值赋给 v，否则就会认为已经有其他的线程对该变量进行过了操作，那么当前线程就什么都不做，并将 v 更新为该变量的当前值。</p><p>当多个线程使用 CAS 同时操作一个变量时，只有一个会胜出，并成功更新该变量，其余均会失败。失败的线程不会被挂起，而是仅仅被告知失败，并且允许再次进行尝试。</p><p><strong>ABA 问题</strong></p><p>CAS 会导致 ABA 问题，也就是说，如果一个线程 X 从内存中取出了变量 A，此时另一个线程 Y 也取出该变量 A，线程 Y 对该变量进行更新操作，使其变为 B，之后又进行了第二次更新操作使其变为 A，而线程 X 进行 CAS 操作发现该变量仍然是 A，就会认为这期间没有线程修改过该变量，从而进行自己的操作并操作成功。</p><p>尽管线程 X 的 CAS 操作成功，但是并不代表该操作是没有问题的。</p><p>部分乐观锁是采用版本号的方式来解决 ABA 问题的，其每次修改数据都会带上一个版本号，一旦该版本号与数据版本号一致，就可以执行修改并在修改后对版本号 + 1，否则执行失败。</p><h2 id="使用版本号的例子"><a href="#使用版本号的例子" class="headerlink" title="使用版本号的例子"></a>使用版本号的例子</h2><p>数据表中除了数据之外还有一个 version 字段</p><p>Java 中的 AtomicStampedReference 类使用版本号解决了 ABA 问题，其中使用了版本号参数 stamp，get方法负责从 Pair 对象的属性中获取值，set方法负责将不同的对象或版本号设置给 pair 对象</p><h2 id="AQS-对-CAS-的应用"><a href="#AQS-对-CAS-的应用" class="headerlink" title="AQS 对 CAS 的应用"></a>AQS 对 CAS 的应用</h2><p>AQS 就是采用该方法修改表示同步状态的成员变量 state 的。假设 state = 0 表示同步状态可用，state = 1 表示同步状态已经被占用。</p><p>下面举例说一下获取和释放同步状态的过程：</p><p><strong>获取同步状态</strong></p><p>假设线程 A 想获取同步状态（可以理解为锁），初始状态下 state = 0，A 可以顺利获取锁，A 获取锁之后将 state 置为 1。</p><p>在 A 没有释放锁期间，线程 B 也来获取锁，此时因为 state = 1，表示锁被占用，因此需要将 B 的线程信息和等待状态等信息构造出一个 Node 节点对象，放入同步队列，head 和 tail 分别指向队列的头部和尾部（队列中有一个空的 Node 节点作为头节点，head 指向这个空节点，该节点的后继节点是 B 对应的 Node 节点，tail 指向该节点），同时阻塞线程 B。</p><p>后续如果还有线程想要获取锁，都会进入该队列尾部并阻塞。</p><p><strong>释放同步状态</strong></p><p>线程 A 释放锁时，将 state 置为 0，此时 A 会唤醒头结点的后继节点，此时 B 发现 state 为 0，获取锁，其 Node 节点随之出队。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>Java 中的大部分同步类（如 Lock、ReentrantLock 等）的实现都是基于 AQS 的。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>即可重入锁，指的是一个线程对一个资源进行重复加锁。其与常用的 Synchronized 对比如下。</p><p><img src="https://s2.loli.net/2022/03/06/sCz7daATmbUHKki.png"></p><p>重入性需要满足：1. 在线程获取锁的时候，如果已经获取锁的线程是当前线程的话，则直接再次获取成功；2. 由于锁会被获取 n 次，那么只有锁被释放同样的 n 次之后，才算完全释放成功。</p><p>ReentrantLock 支持两种锁：公平锁与非公平锁。所谓公平锁就是指，锁的获取顺序应该符合请求上的绝对时间顺序，满足 FIFO 。公平锁每次都是从同步队列的第一个节点获取锁，而非公平锁则不一定，有可能刚释放锁的线程能够再次获取锁。</p><h3 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h3><ol><li>公平锁每次获取到锁的是同步队列中的第一个节点，从而保证请求时间上的绝对顺序，而非公平锁则有可能刚释放锁的线程立刻再次获得锁，导致其他线程永远无法得到锁，造成饥饿现象；</li><li>公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁则会降低上下文切换的频率，降低性能开销。因此，ReentrantLock 默认使用非公平锁，从而保证系统更大的吞吐量</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发三-锁</title>
      <link href="/2023/11/16/java-bing-fa-san-suo/"/>
      <url>/2023/11/16/java-bing-fa-san-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。</p><p><img src="https://s2.loli.net/2022/03/06/1udURDqWPFeICtn.png"></p><h1 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h1><p><img src="https://s2.loli.net/2022/03/06/bfryEaMTV35oIhq.png"></p><h1 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h1><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><p><img src="https://s2.loli.net/2022/03/06/o2YGNexwm3tWT84.png"></p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程。</p><p>JDK 6 中引入了自适应自旋锁，所谓的自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><h1 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h1><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p><p>首先为什么Synchronized能实现线程同步？</p><p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><h2 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h2><p>synchronized 是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p><p>以 Hotspot 虚拟机为例，Hotspot 的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><ul><li>Mark Word: 默认存储对象的 HashCode，分代年龄以及锁标志位信息。这些信息都是与对象自身定义无关的数据，因此该 Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存中存储尽量多的数据。 它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</li><li>Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象究竟是哪个类的实例</li></ul><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>Monitor 可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个 Java 对象就有一把看不见的锁，称为内部锁或 Monitor 锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>synchronized 就是通过 Monitor 来实现线程同步的，而 Monitor 是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><p>依赖于操作系统 Mutex Lock所实现的锁我们称之为“重量级锁”，在 JDK 6 之前，synchronized 最初实现同步的方式就是这样的重量级锁，它导致了其效率的下降。</p><p>JDK 6 中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>CAS 机制就是无锁的体现，其特点就是修改操作在循环内进行，线程会不断尝试修改共享资源，如果没有冲突就成功修改，否则就会继续进行循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁是指，一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数的实际情况下，锁总是由一个线程多次获得，并不存在多线程的竞争，因此出现了偏向锁。其目标就是在只有一个线程执行同步代码块的时候，尽可能提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在 Mark Word 中存储锁偏向的线程 ID，这样在该线程进入和退出同步代码块时就不再需要通过 CAS 来加锁和解锁。</p><p>偏向锁只有在其他线程尝试竞争获取锁时，才会释放锁，线程不会主动释放偏向锁。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>当锁是偏向锁时，如果被其他的线程所访问，那么锁就会升级为轻量级锁。其他线程会通过自旋的形式来尝试获取锁，不会发生阻塞，从而进一步提高性能。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>等待锁的线程会进入阻塞状态</p><p>整体的锁状态升级流程如下：</p><p><img src="https://s2.loli.net/2022/03/07/DqP13aonhVUJ6Ze.png"></p><p>综上，偏向锁通过 Mark Word 来解决加锁问题，避免执行 CAS 操作。轻量级锁通过用 CAS 操作与自旋来解决加锁问题，避免线程阻塞与唤醒。重量级锁则将除了拥有锁之外的线程都阻塞。</p><h1 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h1><p><img src="https://s2.loli.net/2022/03/07/Ou4JxV8myTQvgie.png"></p><p><img src="https://s2.loli.net/2022/03/07/kshS7CmT4QgNzUX.png"></p><h1 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h1><p>可重入锁又名递归锁，是指同一个线程在外层方法获取到锁的时候，再进入该线程的内层方法会自动获取锁，不会因为之前已经获取过的锁还没释放而阻塞。</p><p>ReentrantLock 和 Synchronized 都是可重入锁，其优点在于可以在一定程度上避免死锁。例如：</p><p><img src="https://s2.loli.net/2022/03/07/f8xkhtgqGmN9dPY.png"></p><p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p><p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p>示意图如下：</p><p><img src="https://s2.loli.net/2022/03/07/YoRzlfcra7hBETP.png"></p><p><img src="https://s2.loli.net/2022/03/07/QGpWoFiRayJ2IHt.png"></p><h1 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h1><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程 T 对数据 A 加上排他锁之后，则其他线程就不能再对 A 加任何类型的锁。获得排他锁的线程既能读数据又能修改数据，JDK 中的 synchronized 和 JUC 中的 Lock 的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发二-底层原理</title>
      <link href="/2023/11/16/java-bing-fa-er-di-ceng-yuan-li/"/>
      <url>/2023/11/16/java-bing-fa-er-di-ceng-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Synchronized-关键字"><a href="#Synchronized-关键字" class="headerlink" title="Synchronized 关键字"></a>Synchronized 关键字</h1><p>synchronized 关键字解决的是多个线程之间访问资源的同步性，该关键字能够保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="修饰实例方法"><a href="#修饰实例方法" class="headerlink" title="修饰实例方法"></a>修饰实例方法</h3><p>作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">//业务代码</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h3><p>即给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。因为静态成员不属于任何一个实例对象，是类成员。所以，如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，这种情况是允许的，并不会发生互斥。这是因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态synchronized 方法占用的锁是当前实例对象锁。</p><blockquote><p>静态方法和非静态方法的一个主要区别就是，静态方法属于类，可以直接通过类名调用，而非静态方法则属于该类的实例化对象，只能通过对象来调用</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">//业务代码</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h3><p>指定加锁对象，对给定对象/类加锁。synchronized(this|object) 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。synchronized(类.class) 表示进入同步代码前要获得 <strong>当前 class</strong> 的锁</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) {<br>    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) {<br>    <span class="hljs-comment">//业务代码</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是给 Class 类上锁。</li><li>synchronized 关键字加到实例方法上是给对象实例上锁。</li></ul><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><h3 id="双重检验锁方式实现单例模式"><a href="#双重检验锁方式实现单例模式" class="headerlink" title="双重检验锁方式实现单例模式"></a>双重检验锁方式实现单例模式</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> {<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> {<br>        <span class="hljs-comment">// 判断对象是否已经实例化，若未实例化，则进入加锁代码</span><br>        <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-literal">null</span>) {<br>            <span class="hljs-comment">// 类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) {<br>                <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-literal">null</span>) {<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> {<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> {<br>        <span class="hljs-comment">// 判断对象是否已经实例化，若未实例化，则进入加锁代码</span><br>        <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-literal">null</span>) {<br>            <span class="hljs-comment">// 类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) {<br>                <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-literal">null</span>) {<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>双重检验锁方法实现单例模式，先判断实例是否已经存在，若已经存在了，则不会执行判断方法内的有锁方法了。而如果对象尚未实例化，多个线程通过了第一层检验，内部方法仍然有锁，只会让一个线程进入最内层方法并实例化实例。由此一来就解决了线程阻塞的问题。</p><p>需要注意的是，uniqueInstance 采用 volatile 关键字修饰也是很有必要的，uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><blockquote><p>volatile 被称之为轻量级的 synchronized，和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。</p></blockquote><h2 id="构造方法可以使用-synchronized-关键字修饰吗？"><a href="#构造方法可以使用-synchronized-关键字修饰吗？" class="headerlink" title="构造方法可以使用 synchronized 关键字修饰吗？"></a>构造方法可以使用 synchronized 关键字修饰吗？</h2><p>构造方法不能使用 synchronized 关键字修饰，因为构造方法本身就是线程安全的，因此不需要用 synchronized 修饰。</p><h2 id="synchronized-关键字的基本原理"><a href="#synchronized-关键字的基本原理" class="headerlink" title="synchronized 关键字的基本原理"></a>synchronized 关键字的基本原理</h2><h3 id="synchronized-修饰代码块的情况"><a href="#synchronized-修饰代码块的情况" class="headerlink" title="synchronized 修饰代码块的情况"></a>synchronized 修饰代码块的情况</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {<br>            System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {<br>            System.out.println(<span class="hljs-string">"synchronized 代码块"</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>synchronized 同步代码块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</p><p>当执行 monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。</p><p>在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220224181133.png"></p><p>对象锁的的拥有者线程才可以执行 monitorexit 指令来释放锁。在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220224182301.png"></p><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h3 id="synchronized-修饰方法的情况"><a href="#synchronized-修饰方法的情况" class="headerlink" title="synchronized 修饰方法的情况"></a>synchronized 修饰方法的情况</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo2</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo2</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>        System.out.println(<span class="hljs-string">"synchronized 方法"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 </p><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。</p><p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p><h2 id="synchronized-和-ReentrantLock-的联系与区别"><a href="#synchronized-和-ReentrantLock-的联系与区别" class="headerlink" title="synchronized 和 ReentrantLock 的联系与区别"></a>synchronized 和 ReentrantLock 的联系与区别</h2><h3 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h3><p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。 就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p><h3 id="synchronized-依赖于-JVM，-而-ReentrantLock-依赖于-API"><a href="#synchronized-依赖于-JVM，-而-ReentrantLock-依赖于-API" class="headerlink" title="synchronized 依赖于 JVM， 而 ReentrantLock 依赖于 API"></a>synchronized 依赖于 JVM， 而 ReentrantLock 依赖于 API</h3><p>synchronized 是依赖于 JVM 实现的，而ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><h3 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h3><p>主要有三点：</p><ul><li>等待可中断: ReentrantLock提供了一种能够中断等待锁的线程的机制，也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li>可实现公平锁: ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓公平锁指的是先等待的线程先获得锁。</li><li>可实现选择性通知（锁可以绑定多个条件）</li></ul><h1 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h1><h2 id="volatile-实现可见性"><a href="#volatile-实现可见性" class="headerlink" title="volatile 实现可见性"></a>volatile 实现可见性</h2><p>volatile 变量每次被线程访问时，都强迫线程从主内存中读取该变量的最新指，而当该变量发送修改变化时，也会强迫线程将最新值刷新回主内存中。这样一来，不同线程都能及时看到该变量的最新值。</p><p>但是 volatile 变量不能保证变量更改的原子性。</p><h2 id="volatile-能否保证线程安全？"><a href="#volatile-能否保证线程安全？" class="headerlink" title="volatile 能否保证线程安全？"></a>volatile 能否保证线程安全？</h2><p>在某些特定的情况下能。</p><ol><li>需要 volatile 保证线程安全，那么必须满足两个条件：对变量的写操作不依赖于当前值，也就是确保只有单个线程更新变量的值；该变量没有包含在具有其他变量的不变式中。</li><li>不能保证上述条件，那么 volatile 变量就不是线程安全的，因为不能保证原子性。</li></ol><h2 id="CPU-缓存模型"><a href="#CPU-缓存模型" class="headerlink" title="CPU 缓存模型"></a>CPU 缓存模型</h2><p>类似在开发网站后台系统时所采用的如 Redis 等内存数据库是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题，<strong>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</strong></p><p>CPU Cache 缓存的是内存数据，用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220224204048.png"></p><p><strong>CPU Cache 的工作方式：</strong></p><p>先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样就会存在 <strong>内存缓存不一致的问题</strong>。比如执行一个 i++ 操作，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++ 运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。</p><p>CPU 为了解决内存与缓存的一致性问题可以通过制定 缓存一致协议 或者其他手段来解决</p><h2 id="JMM（Java-内存模型）"><a href="#JMM（Java-内存模型）" class="headerlink" title="JMM（Java 内存模型）"></a>JMM（Java 内存模型）</h2><p>Java 内存模型抽象了线程和主内存之间的关系，例如线程之间的共享变量必须存储在主内存中。Java 内存模型的主要目的是为了屏蔽系统和硬件的差异，避免一套代码在不同的平台下产生不一致的效果。</p><p>在 JDK 1.2 之前，Java 的内存模型实现总是从主存（即共享内存）读取变量。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成 <strong>数据的不一致</strong>。</p><blockquote><p>主内存 ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</p><p>本地内存 ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。</p></blockquote><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220224205919.png"></p><p>要想解决本地内存与主存中数据不一致的问题，就需要把变量声明为 volatile。这就指示了 JVM，这个变量是共享且不稳定的，每次使用到它时都必须从主存中读取。</p><p>所以，volatile 关键字 <strong>除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。</strong></p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220224210223.png"></p><h2 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h2><ul><li><p>原子性: 与数据库的原子性类型，指一个操作或多个操作，这些操作要么全部执行并且不会因为任何干扰而中断，要么就都不执行。synchronized 可以保证代码片段的原子性。</p></li><li><p>可见性：当一个线程对共享变量做了修改后，其余的线程都能够立即看到修改后的最新值。volatile 能够保证共享变量的可见性</p></li><li><p>有序性：代码在执行过程中要保证先后顺序。JVM 会对代码的执行顺序进行优化，从而导致代码的执行顺序未必是编写的顺序。volatile 能够禁止指令进行重排优化。</p></li></ul><h2 id="synchronized-关键字和-volatile-关键字的区别"><a href="#synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="synchronized 关键字和 volatile 关键字的区别"></a>synchronized 关键字和 volatile 关键字的区别</h2><p>这两个关键字的互补的存在，而非对立的存在</p><ul><li>volatile 关键字是线程同步的轻量级实现，因此其性能要比 synchronized 关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。</li><li>volatile 关键字只能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</li></ul><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="ThreadLocal-简介"><a href="#ThreadLocal-简介" class="headerlink" title="ThreadLocal 简介"></a>ThreadLocal 简介</h2><p>通常情况下所创建的变量是可以被任一个线程所访问并修改的，而如果想实现每个线程拥有自己的专属本地变量，就需要用到 ThreadLocal 类。ThreadLocal 类主要解决的就是让每个线程绑定自己的值，可以将 ThreadLocal 类形象地比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><p>如果创建了一个 ThreadLocal 变量，那么访问这个变量的每个线程都会持有这个变量的本地副本，这些线程可以使用 get() 和 set() 方法来获取默认值或将该值修改为当前线程所存的副本的值，从而避免了线程安全问题。</p><h2 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h2><p>从 Thread 类源代码入手。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> {<br>    <span class="hljs-comment">//......</span><br>    <span class="hljs-comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> {<br>    <span class="hljs-comment">//......</span><br>    <span class="hljs-comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//......</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>从上面 Thread 类的源代码可以看出，Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为 ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是 null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。</p><p>ThreadLocal 类的 set() 方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> {<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>}<br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> {<br>    <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> {<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>}<br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> {<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过上面这些内容，我们足以通过猜测得出结论：最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。</p><p>每个Thread中都具备一个 ThreadLocalMap，而 ThreadLocalMap 可以存储以 ThreadLocal 为 key ，Object 对象为 value 的键值对。即相当于是每个线程对应于一个操作的副本。</p><p>比如我们在同一个线程中声明了两个 ThreadLocal 对象的话， Thread内部都是使用仅有的那个ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal对象，value 就是 ThreadLocal 对象调用set方法设置的值。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220224220551.png"></p><h2 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal 内存泄露问题"></a>ThreadLocal 内存泄露问题</h2><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。</p><blockquote><p>弱引用：如果一个对象只具有弱引用，那就类似于可有可无的生活用品。</p><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。而如果一个对象只具有软引用，则内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足时，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p></blockquote><p>所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p><p>ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁创建和销毁线程的时候，就可以考虑使用线程池来提升系统的性能。</p><h2 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h2><p>Java中有三个比较常用的线程池，分别是 FixedThreadPool，SingleThreadExecutor，CachedThreadPool。</p><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>是一个线程数固定的线程池，当这个线程池被创建的时候，池里的线程数就已经固定了。当需要运行的线程数量大体上变化不大时，适合使用这种线程池。固定数量还有一个好处，它可以一次性支付高昂的创建线程的开销，之后再使用的时候就不再需要这种开销。</p><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>是一个线程数量为1的线程池，所有提交的这个线程池的任务都会按照提交的先后顺序排队执行。单个线程执行有个好处：由于任务之间没有并发执行，因此提交到线程池种的任务之间不会相互干扰。程序执行的结果更具有确定性。</p><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>是一个和缓存有关的线程池，每次有任务提交到线程池的时候，如果池中没有空闲的线程，线程池就会为这个任务创建一个线程，如果有空闲的线程，就会使用已有的空闲线程执行任务。为了防止线程越来越多，这个线程池还有一个销毁机制，如果一个线程60秒之内没有被使用过，这个线程就会被销毁，这样就节省了很多资源。CachedThreadPool是一个比较通用的线程池，它在多数情况下都能表现出优良的性能。</p><h3 id="newScheduleThreadPool"><a href="#newScheduleThreadPool" class="headerlink" title="newScheduleThreadPool"></a>newScheduleThreadPool</h3><p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p><h2 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h2><blockquote><p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p></blockquote><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。使用线程池的好处主要有：</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h2 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h2><p>线程池的创建方法总共有 7 种，但总体来说可分为 2 类，一类是通过 ThreadPoolExecutor 创建的线程池；另一个类是通过 Executors 创建的线程池。然而，在阿里巴巴的 Java 开发手册中明确规定，线程池不允许使用 Executors 去创建，而只能通过 ThreadPoolExecutor 的方式创建，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><blockquote><p>Executors 返回线程池对象的弊端如下：</p><p>FixedThreadPool 和 SingleThreadExecutor： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM;<br>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</p></blockquote><h3 id="方式一：通过构造方法实现"><a href="#方式一：通过构造方法实现" class="headerlink" title="方式一：通过构造方法实现"></a>方式一：通过构造方法实现</h3><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220224225752.png"></p><p>7 个参数代表的含义如下：</p><p>参数 1：corePoolSize，核心线程数，线程池中始终存活的线程数。</p><p>参数 2：maximumPoolSize，最大线程数，线程池中允许的最大线程数，当线程池的任务队列满了之后可以创建的最大线程数。</p><p>参数 3：keepAliveTime，最大线程数可以存活的时间，当线程中没有任务执行时，最大线程就会销毁一部分，最终保持核心线程数量的线程。</p><p>参数 4：unit，时间单位，是和参数 3 存活时间配合使用的，合在一起用于设定线程的存活时间</p><p>参数 5：workQueue，一个阻塞队列，用来存储线程池等待执行的任务，均为线程安全，它包含 7 种类型</p><p>参数 6：threadFactory，线程工厂，主要用来创建线程，默认为正常优先级、非守护线程</p><p>参数 7：handler，拒绝策略，拒绝处理任务时的策略，系统提供了 4 种可选，默认策略为 AbortPolicy。</p><h3 id="方式二：通过-Executor-框架的工具类-Executors-来实现"><a href="#方式二：通过-Executor-框架的工具类-Executors-来实现" class="headerlink" title="方式二：通过 Executor 框架的工具类 Executors 来实现"></a>方式二：通过 Executor 框架的工具类 Executors 来实现</h3><p>我们可以创建三种类型的 ThreadPoolExecutor： </p><ul><li><p>FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。 </p></li><li><p>SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。 </p></li><li><p>CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p></li></ul><h1 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h1><h2 id="什么是-Atomic-原子类"><a href="#什么是-Atomic-原子类" class="headerlink" title="什么是 Atomic 原子类"></a>什么是 Atomic 原子类</h2><p>Atomic 是指一个操作是不可中断的，即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他的线程干扰。因此，所谓原子类说简单点就是具有原子/原子操作特征的类。</p><h2 id="JUC-包中的原子类是哪-4-类？"><a href="#JUC-包中的原子类是哪-4-类？" class="headerlink" title="JUC 包中的原子类是哪 4 类？"></a>JUC 包中的原子类是哪 4 类？</h2><ul><li>基本类型：使用原子的方式更新基本类型</li><li>数组类型：使用原子方式更新数组中的某个元素</li><li>引用类型</li><li>对象的属性修改类型</li></ul><h1 id="AQS-简介"><a href="#AQS-简介" class="headerlink" title="AQS 简介"></a>AQS 简介</h1><h2 id="什么是-AQS"><a href="#什么是-AQS" class="headerlink" title="什么是 AQS"></a>什么是 AQS</h2><p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出大量应用广泛的同步器。该部分会单独进行介绍。</p><h1 id="线程池补充"><a href="#线程池补充" class="headerlink" title="线程池补充"></a>线程池补充</h1><h2 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h2><p>池化技术是一个常见的技术，主要目的是为了避免对象的频繁创建和销毁所带来的额外性能损耗。</p><p>线程池的目的就是为了减少频繁创建线程和销毁线程所带来的性能损耗，通过利用线程池中已经存在的线程来接收新的任务，能够有效提升性能。</p><h2 id="线程池核心参数"><a href="#线程池核心参数" class="headerlink" title="线程池核心参数"></a>线程池核心参数</h2><p>线程池的构造函数共有 7 个参数</p><h3 id="corePoolSize：核心线程数"><a href="#corePoolSize：核心线程数" class="headerlink" title="corePoolSize：核心线程数"></a>corePoolSize：核心线程数</h3><p>默认情况下，线程池中的线程数量即使 &lt;= corePoolSize，那么即使这些线程处于空闲状态，也不会被销毁</p><h3 id="maxPoolSize：最大线程数"><a href="#maxPoolSize：最大线程数" class="headerlink" title="maxPoolSize：最大线程数"></a>maxPoolSize：最大线程数</h3><p>线程池中最多可容纳的线程数量。当一个新任务交给线程池，如果此时线程池中有空闲的线程，就会直接执行，如果没有空闲线程，并且当前线程池的线程数量小于 corePoolSize，那么就会创建新线程来执行任务，否则就会将该任务加入到阻塞队列中。如果阻塞队列也满了，就会常见一个新线程，从阻塞队列头部取出一个任务进行执行，并且将新任务加入到阻塞队列的末尾。</p><p>如果在此过程中，当前线程池中线程数量等于 maximumPoolSize，就不会创建新线程，而是去执行拒绝策略。</p><h3 id="keepAliveTime-时间单位：空闲线程的存活时间"><a href="#keepAliveTime-时间单位：空闲线程的存活时间" class="headerlink" title="keepAliveTime + 时间单位：空闲线程的存活时间"></a>keepAliveTime + 时间单位：空闲线程的存活时间</h3><p>当线程池中线程数量大于 corePoolSize，并且某个线程的空闲时间超过了 keepAliveTime，那么这个线程就会被销毁</p><h3 id="ThreadFactory：线程工厂，用于创建新线程"><a href="#ThreadFactory：线程工厂，用于创建新线程" class="headerlink" title="ThreadFactory：线程工厂，用于创建新线程"></a>ThreadFactory：线程工厂，用于创建新线程</h3><h3 id="workQueue：用于存放任务的队列"><a href="#workQueue：用于存放任务的队列" class="headerlink" title="workQueue：用于存放任务的队列"></a>workQueue：用于存放任务的队列</h3><p>当没有空闲线程来执行新任务时，该任务就会被放入工作队列，等待执行。</p><p>有四种工作队列：</p><ul><li>ArrayBlockingQueue：数组阻塞队列，FIFO 排序，可以指定队列大小，可以防止内存溢出（OOM）</li><li>LinkedBlockingQueue：链表阻塞队列，FIFO 排序，队列默认容量为 Integer.MAX_VALUE，由于容量过大，可能导致 OOM</li><li>SynchronousQueue：同步队列，每次向该队列放入一个任务，必须有空闲线程去领走，若没有空闲线程则进行创建，无法创建更多线程则执行拒绝策略</li><li>PriorityBlockingQueue：带优先级的阻塞队列，可以自定义容量以及自定义排序</li></ul><h3 id="handler：拒绝策略"><a href="#handler：拒绝策略" class="headerlink" title="handler：拒绝策略"></a>handler：拒绝策略</h3><p>当一个新任务交给线程池，如果此时线程池中有空闲的线程，就会直接执行，若没有，则将该任务加入阻塞队列中，如果阻塞队列满了，就会创建一个新线程，从阻塞队列头部取出一个任务执行，并将新任务加入队列末尾。如果线程池中线程数量等于 maximumPoolSize，就会执行拒绝策略。</p><h2 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h2><p>线程池共有四个拒绝策略</p><h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p>调用者执行策略，就是调用者线程直接执行被拒绝任务的 run 方法，除非线程池已经被关闭。若线程池被关闭，则直接丢弃该任务。</p><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p>终止策略，即不执行任务，并抛出 RejectedExecutionException 异常</p><h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p>抛弃策略，即不执行任务，并不进行任何活动</p><h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p>抛弃最老策略，即抛弃队列中最早的那个任务，并将新任务加入队列</p><h2 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h2><ol><li><p>创建线程池后，等待提交过来的任务请求</p></li><li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断</p><ol><li>如果正在运行的线程池数量小于核心线程数，那么马上创建线程运行这个任务</li><li>如果正在运行的线程数量大于或等于核心线程数，那么将这个任务放入队列</li><li>如果这时候队列满了，并且正在运行的线程数量还小于最大线程数，那么还是创建非核心线程like运行这个任务</li><li>如果队列满了并且正在运行的线程数量大于或等于最大线程数，那么线程池会启动饱和拒绝策略来执行</li></ol></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p></li><li><p>当一个线程无事可做操作一定的时间(keepAliveTime)时，线程池会判断：</p><ol><li>如果当前运行的线程数大于核心线程数，那么这个线程就被停掉</li><li>所以线程池的所有任务完成后，它会最终收缩到核心线程数的大小</li></ol></li></ol><h1 id="如何解决线程池的惊群问题"><a href="#如何解决线程池的惊群问题" class="headerlink" title="如何解决线程池的惊群问题"></a>如何解决线程池的惊群问题</h1><p>所谓惊群效应指的是，对于操作系统而言，多个线程/进程在等待同一资源，每当资源可用，所有的线程都来竞争，最终造成后果是：</p><ol><li>系统对于用户线程进行频繁的无效调度与上下文切换，系统性能下降</li><li>为了确保只有一个线程能够获取资源，用户必须对资源操作进行加锁保护，从而进一步加大了系统开销</li></ol><p>操作系统中的惊群效应，最常见的是 socket 描述符的 accept 操作，当多个线程监听同一个端口时，实际上只会 accept 一次，因此会产生惊群。但是目前的操作系统内核已经基本解决了这一问题，当一个链接过来时，内核只会唤醒一个子进程出来 accept。</p><p>在线程池中，一个基本的线程池框架是基于生产者消费者模型的。生产者负责向队列中添加任务，消费者则负责取任务并执行。当一个线程执行完毕、解锁之后，并通知了其他的等待线程，就会出现惊群的现象。</p><p>线程池中的 pthread_cond_signal 是由生产者线程通知线程池中的某个或一些消费者线程，来接收并处理任务的。在调用此函数之后，系统会唤醒相同条件变量上等待的一个或多个线程，可能造成惊群。</p><p>为此，可以解决的方法是，让所有线程共用一个锁，每个线程都有自己的条件变量。当 pthread_cond_signal 进行通知时，定向通知到某个线程的条件变量，从而防止惊群。</p><h1 id="三个线程循环打印-ABC"><a href="#三个线程循环打印-ABC" class="headerlink" title="三个线程循环打印 ABC"></a>三个线程循环打印 ABC</h1><h2 id="Lock-锁方法"><a href="#Lock-锁方法" class="headerlink" title="Lock 锁方法"></a>Lock 锁方法</h2><p>使用 ReentrantLock 进行显式的锁操作，对于同一个对象锁而言，同一时刻只可能有一个线程拿到了这个锁，其他线程通过 lock.lock() 获取对象锁时都会被阻塞，直到这个线程通过 lock.unlock() 操作释放锁之后其他线程才能拿到锁。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABC_lock</span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(); <span class="hljs-comment">// 创建 Lock 锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// state 用于确定当前状态，是否需要打印</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>            <span class="hljs-comment">// 打印 10 次</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;) {<br>                lock.lock(); <span class="hljs-comment">// lock.lock() 放在 try 外面，防止在加锁之前出现异常，不执行加锁而直接执行 finally 语句</span><br>                <span class="hljs-keyword">try</span>{<br>                    <span class="hljs-comment">// 多线程并发，为了防止虚假唤醒，不能用 if，必须用循环测试等待条件</span><br>                    <span class="hljs-keyword">while</span>(state % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {<br>                        System.out.print(<span class="hljs-string">"A"</span>);<br>                        state++;<br>                        i++;<br>                    }<br>                } <span class="hljs-keyword">finally</span> {<br>                    lock.unlock();<br>                    <span class="hljs-comment">// unlock 操作必须放入 finally 块中</span><br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;) {<br>                lock.lock();<br>                <span class="hljs-keyword">try</span>{<br>                    <span class="hljs-keyword">while</span>(state % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) {<br>                        System.out.print(<span class="hljs-string">"B"</span>);<br>                        state++;<br>                        i++;<br>                    }<br>                } <span class="hljs-keyword">finally</span> {<br>                    lock.unlock();<br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;) {<br>                lock.lock();<br>                <span class="hljs-keyword">try</span>{<br>                    System.out.print(<span class="hljs-string">"C"</span>);<br>                    state++;<br>                    i++;<br>                }<br>            } <span class="hljs-keyword">finally</span> {<br>                lock.unlock();<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABC_lock</span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(); <span class="hljs-comment">// 创建 Lock 锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// state 用于确定当前状态，是否需要打印</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>            <span class="hljs-comment">// 打印 10 次</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;) {<br>                lock.lock(); <span class="hljs-comment">// lock.lock() 放在 try 外面，防止在加锁之前出现异常，不执行加锁而直接执行 finally 语句</span><br>                <span class="hljs-keyword">try</span>{<br>                    <span class="hljs-comment">// 多线程并发，为了防止虚假唤醒，不能用 if，必须用循环测试等待条件</span><br>                    <span class="hljs-keyword">while</span>(state % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {<br>                        System.out.print(<span class="hljs-string">"A"</span>);<br>                        state++;<br>                        i++;<br>                    }<br>                } <span class="hljs-keyword">finally</span> {<br>                    lock.unlock();<br>                    <span class="hljs-comment">// unlock 操作必须放入 finally 块中</span><br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;) {<br>                lock.lock();<br>                <span class="hljs-keyword">try</span>{<br>                    <span class="hljs-keyword">while</span>(state % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) {<br>                        System.out.print(<span class="hljs-string">"B"</span>);<br>                        state++;<br>                        i++;<br>                    }<br>                } <span class="hljs-keyword">finally</span> {<br>                    lock.unlock();<br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;) {<br>                lock.lock();<br>                <span class="hljs-keyword">try</span>{<br>                    System.out.print(<span class="hljs-string">"C"</span>);<br>                    state++;<br>                    i++;<br>                }<br>            } <span class="hljs-keyword">finally</span> {<br>                lock.unlock();<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadC</span>().start();        <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="使用三个线程循环打印-1-100"><a href="#使用三个线程循环打印-1-100" class="headerlink" title="使用三个线程循环打印 1~100"></a>使用三个线程循环打印 1~100</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABC_lock</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">// 通过JDK5中的Lock锁来保证线程的访问的互斥</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//通过state的值来确定是否打印</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">33</span>;) {<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> {<br><br>                    <span class="hljs-keyword">while</span> (state % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {<span class="hljs-comment">// 多线程并发，不能用if，必须用循环测试等待条件，避免虚假唤醒</span><br>                        System.out.println(state);<br>                        state++;<br>                        i++;<br>                    }<br>                } <span class="hljs-keyword">finally</span> {<br>                    lock.unlock();<span class="hljs-comment">// unlock()操作必须放在finally块中</span><br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">34</span>;) {<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> {<br><br>                    <span class="hljs-keyword">while</span> (state % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) {<span class="hljs-comment">// 多线程并发，不能用if，必须用循环测试等待条件，避免虚假唤醒</span><br>                        System.out.println(state);<br>                        state++;<br>                        i++;<br>                    }<br>                } <span class="hljs-keyword">finally</span> {<br>                    lock.unlock();<span class="hljs-comment">// unlock()操作必须放在finally块中</span><br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">33</span>;) {<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> {<br><br>                    <span class="hljs-keyword">while</span> (state % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>) {<span class="hljs-comment">// 多线程并发，不能用if，必须用循环测试等待条件，避免虚假唤醒</span><br>                        System.out.println(state);<br>                        state++;<br>                        i++;<br>                    }<br>                } <span class="hljs-keyword">finally</span> {<br>                    lock.unlock();<span class="hljs-comment">// unlock()操作必须放在finally块中</span><br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_"><code class="language-hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABC_lock</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<span class="hljs-comment">// 通过JDK5中的Lock锁来保证线程的访问的互斥</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//通过state的值来确定是否打印</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">33</span>;) {<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> {<br><br>                    <span class="hljs-keyword">while</span> (state % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {<span class="hljs-comment">// 多线程并发，不能用if，必须用循环测试等待条件，避免虚假唤醒</span><br>                        System.out.println(state);<br>                        state++;<br>                        i++;<br>                    }<br>                } <span class="hljs-keyword">finally</span> {<br>                    lock.unlock();<span class="hljs-comment">// unlock()操作必须放在finally块中</span><br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">34</span>;) {<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> {<br><br>                    <span class="hljs-keyword">while</span> (state % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) {<span class="hljs-comment">// 多线程并发，不能用if，必须用循环测试等待条件，避免虚假唤醒</span><br>                        System.out.println(state);<br>                        state++;<br>                        i++;<br>                    }<br>                } <span class="hljs-keyword">finally</span> {<br>                    lock.unlock();<span class="hljs-comment">// unlock()操作必须放在finally块中</span><br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">33</span>;) {<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> {<br><br>                    <span class="hljs-keyword">while</span> (state % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>) {<span class="hljs-comment">// 多线程并发，不能用if，必须用循环测试等待条件，避免虚假唤醒</span><br>                        System.out.println(state);<br>                        state++;<br>                        i++;<br>                    }<br>                } <span class="hljs-keyword">finally</span> {<br>                    lock.unlock();<span class="hljs-comment">// unlock()操作必须放在finally块中</span><br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadC</span>().start();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发一-基础知识</title>
      <link href="/2023/11/16/java-bing-fa-yi-ji-chu-zhi-shi/"/>
      <url>/2023/11/16/java-bing-fa-yi-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是线程和进程？"><a href="#什么是线程和进程？" class="headerlink" title="什么是线程和进程？"></a>什么是线程和进程？</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是程序的一次执行过程，是系统运行程序的基本单位，是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>.</p><p><strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行.</strong></p><h2 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h2><p>程序计数器主要有下面两个作用： </p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 </li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p><h2 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h2><ul><li><p><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p></li><li><p><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p></li></ul><p>为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p><h2 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h2><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h1 id="为什么需要多线程？"><a href="#为什么需要多线程？" class="headerlink" title="为什么需要多线程？"></a>为什么需要多线程？</h1><p>CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；// 导致 <code>可见性</code> 问题</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 <code>原子性</code> 问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 <code>有序性</code> 问题</li></ul><p>从计算机底层来说，线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。多核 CPU 时代意味着多个线程可以同时运行，减少了线程上下文切换的开销。</p><h1 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h1><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220207135926.png"></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>当线程执行 <code>wait()</code> 方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code> 方法或 <code>wait（long millis）</code> 方法可以将 Java 线程置于 TIMED_WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的run()方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h1 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h1><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了<code> sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong> 。</p><h1 id="什么是线程死锁？"><a href="#什么是线程死锁？" class="headerlink" title="什么是线程死锁？"></a>什么是线程死锁？</h1><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>例如，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220207145159.png"></p><p>产生死锁必须具备以下四个条件：</p><ul><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><h1 id="如何预防和避免线程死锁？"><a href="#如何预防和避免线程死锁？" class="headerlink" title="如何预防和避免线程死锁？"></a>如何预防和避免线程死锁？</h1><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p><ul><li>破坏请求与保持条件：所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。</li><li>破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ul><p><strong>如何避免死锁？</strong></p><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><p>安全状态 指的是系统能够按照某种进程推进顺序（P1、P2、P3…..Pn）来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。</p><h1 id="sleep-方法和-wait-方法的区别和共同点"><a href="#sleep-方法和-wait-方法的区别和共同点" class="headerlink" title="sleep() 方法和 wait() 方法的区别和共同点"></a>sleep() 方法和 wait() 方法的区别和共同点</h1><ul><li><strong>两者最主要的区别在于：</strong> <code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁。</li><li>两者都可以暂停线程的执行。</li><li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code> 或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒。</li></ul><h1 id="为什么调用-start-方法时自动会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么调用-start-方法时自动会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么调用 start() 方法时自动会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么调用 start() 方法时自动会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h1><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code> 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<code>start()</code> 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这才是真正的多线程工作。但是，如果我们直接调用子线程的<code>run()</code>方法，其方法还是运行在主线程中，代码在程序中是顺序执行的，所以不会解决耗时操作的问题。</p><h1 id="并发出现问题的根源-并发三要素"><a href="#并发出现问题的根源-并发三要素" class="headerlink" title="并发出现问题的根源: 并发三要素"></a>并发出现问题的根源: 并发三要素</h1><h2 id="可见性-CPU缓存引起"><a href="#可见性-CPU缓存引起" class="headerlink" title="可见性: CPU缓存引起"></a>可见性: CPU缓存引起</h2><p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p><p>例如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-comment">//线程1执行的代码</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>i = <span class="hljs-number">10</span>;<br> <br><span class="hljs-comment"><code class="language-hljs java"><span class="hljs-comment">//线程1执行的代码</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>i = <span class="hljs-number">10</span>;<br> <br><span class="hljs-comment">//线程2执行的代码</span><br>j = i;<br></code></pre></td></tr></tbody></table></figure><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。 </p><p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。</p><p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><h2 id="原子性-分时复用引起"><a href="#原子性-分时复用引起" class="headerlink" title="原子性: 分时复用引起"></a>原子性: 分时复用引起</h2><p>原子性：指操作是不可分的。即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>例如a++，对于共享变量a的操作，实际上会执行三个步骤：</p><ol><li>读取变量a的值  </li><li>a的值+1  </li><li>将值赋予变量a</li></ol><p>这三个操作中任何一个操作过程中a的值被人篡改，那么都会出现我们不希望出现的结果。所以我们必须保证这是原子性的。Java中的锁的机制解决了原子性的问题。</p><h2 id="有序性-重排序引起"><a href="#有序性-重排序引起" class="headerlink" title="有序性: 重排序引起"></a>有序性: 重排序引起</h2><p>有序性：即程序执行的顺序按照代码的先后顺序执行。例如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;              <br><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>i = <span class="hljs-number">1</span>;                <span class="hljs-comment">//语句1  </span><br>flag = <span class="hljs-literal">true</span>;          <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;              <br><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>i = <span class="hljs-number">1</span>;                <span class="hljs-comment">//语句1  </span><br>flag = <span class="hljs-literal">true</span>;          <span class="hljs-comment">//语句2</span><br></code></pre></td></tr></tbody></table></figure><p>代码中定义了一个int型变量和一个boolean类型变量，并分别对这两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，但是JVM在真正执行这段代码的时候并不会保证语句1一定会在语句2前面执行。这是因为这里可能会发生指令重排序（Instruction Reorder）。</p><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 </li><li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220206135229.png"></p><h1 id="Java-是怎么解决并发问题的————JMM（JAVA-内存模型）"><a href="#Java-是怎么解决并发问题的————JMM（JAVA-内存模型）" class="headerlink" title="Java 是怎么解决并发问题的————JMM（JAVA 内存模型）"></a>Java 是怎么解决并发问题的————JMM（JAVA 内存模型）</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：</p><ul><li>volatile、synchronized 和 final 三个关键字</li><li>Happens-Before 规则</li></ul><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 </p><p>例如下面的语句中，只有语句一具备原子性：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">x = <span class="hljs-number">10</span>;        <span class="hljs-comment">//语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span><br>y = x;         <span class="hljs-comment">//语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span><br>x++;           <span class="hljs-comment">//语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span><br>x = x + <span class="hljs-number">1</span>;     <span class="hljs-comment"><code class="language-hljs java">x = <span class="hljs-number">10</span>;        <span class="hljs-comment">//语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span><br>y = x;         <span class="hljs-comment">//语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span><br>x++;           <span class="hljs-comment">//语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span><br>x = x + <span class="hljs-number">1</span>;     <span class="hljs-comment">//语句4： 同语句3</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就保证了原子性。</p></blockquote><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>Java提供了volatile关键字来保证可见性。</p><p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><blockquote><p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p></blockquote><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>一个类在可以被多个线程安全调用时就是线程安全的。</p><p>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。</p><p>不可变的类型:</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li></ul><h2 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h2><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p><h2 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h2><p>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><p>在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p><p>例如对于下面的代码，如果删除元素的线程删除了 Vector 的一个元素，而获取元素的线程试图访问一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VectorUnsafeExample</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Vector&lt;Integer&gt; vector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {<br>                vector.add(i);<br>            }<br>            <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>            executorService.execute(() -&gt; {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vector.size(); i++) {<br>                    vector.remove(i);<br>                }<br>            });<br>            executorService.execute(() -&gt; {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VectorUnsafeExample</span> {<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Vector&lt;Integer&gt; vector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {<br>                vector.add(i);<br>            }<br>            <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>            executorService.execute(() -&gt; {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vector.size(); i++) {<br>                    vector.remove(i);<br>                }<br>            });<br>            executorService.execute(() -&gt; {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i < vector.size(); i++) {<br>                    vector.get(i);<br>                }<br>            });<br>            executorService.shutdown();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs java">Exception in thread <span class="hljs-string">"Thread-159738"</span> java.lang.ArrayIndexOutOfBoundsException: Array index out of range: <span class="hljs-number">3</span><br>    at java.util.Vector.remove(Vector.java:<span class="hljs-number">831</span>)<br>    at VectorUnsafeExample.lambda$main$<span class="hljs-number">0</span>(VectorUnsafeExample.java:<span class="hljs-number">14</span>)<br>    at VectorUnsafeExample$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">713338599.</span>run(Unknown Source)<br>    at java.lang.Thread.run(Thread.java:<span class="hljs-number"><code class="language-hljs java">Exception in thread <span class="hljs-string">"Thread-159738"</span> java.lang.ArrayIndexOutOfBoundsException: Array index out of range: <span class="hljs-number">3</span><br>    at java.util.Vector.remove(Vector.java:<span class="hljs-number">831</span>)<br>    at VectorUnsafeExample.lambda$main$<span class="hljs-number">0</span>(VectorUnsafeExample.java:<span class="hljs-number">14</span>)<br>    at VectorUnsafeExample$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">713338599.</span>run(Unknown Source)<br>    at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)<br></code></pre></td></tr></tbody></table></figure><p>如果要保证上面的代码能正确执行下去，就需要对删除元素和获取元素的代码进行同步。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs java">executorService.execute(() -&gt; {<br>    <span class="hljs-keyword">synchronized</span> (vector) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vector.size(); i++) {<br>            vector.remove(i);<br>        }<br>    }<br>});<br>executorService.execute(() -&gt; {<br>    <span class="hljs-keyword">synchronized</span> (vector) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number"><code class="language-hljs java">executorService.execute(() -&gt; {<br>    <span class="hljs-keyword">synchronized</span> (vector) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vector.size(); i++) {<br>            vector.remove(i);<br>        }<br>    }<br>});<br>executorService.execute(() -&gt; {<br>    <span class="hljs-keyword">synchronized</span> (vector) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i < vector.size(); i++) {<br>            vector.get(i);<br>        }<br>    }<br>});<br></code></pre></td></tr></tbody></table></figure><h2 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h2><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。</p><p>Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。</p><h2 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h2><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。</p><h1 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h1><h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>互斥同步是指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。</p><p>synchronized 和 ReentrantLock。</p><h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><p>随着硬件指令集的发展，我们有了另外的一个选择：基于冲突检测的乐观并发策略。也就是先进行操作，如果没有其它线程使用共享数据，那就操作成功；如果有，那就再采取补偿措施。这种方式不需要把线程挂起，因此称为：非阻塞同步(Non-Blocking Synchronization)。</p><h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>要保证线程安全，并不一定要进行同步。两者之间没有因果关系。同步只是一种保证共享数据争用时正确性的手段而已。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM二-垃圾回收</title>
      <link href="/2023/11/16/jvm-er-la-ji-hui-shou/"/>
      <url>/2023/11/16/jvm-er-la-ji-hui-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-内存分配与回收简介"><a href="#JVM-内存分配与回收简介" class="headerlink" title="JVM 内存分配与回收简介"></a>JVM 内存分配与回收简介</h1><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代，再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p>堆空间的基本结构：</p><p><img src="https://s2.loli.net/2022/02/28/VRPeGFLQyXAdajo.png"></p><p>大部分情况，对象都会首先在 Eden 区域进行分配，在一次新生代垃圾回收之后，如果对象还有存活，则会进入 s0 或 s1，并且对象的年龄将会增加 1 (Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当对象年龄增加到一定程度后（默认为15岁），就会被晋升到老年代中。</p><h2 id="对象优先在-eden-区分配"><a href="#对象优先在-eden-区分配" class="headerlink" title="对象优先在 eden 区分配"></a>对象优先在 eden 区分配</h2><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中会优先在 eden 区分配，当 endn 区没有足够的空间时，会进行一次 Minor GC</p><blockquote><p>Minor GC / Young GC</p></blockquote><p>新生代（Young Gen）也可以称之为年轻代，这两个名词是等价的。那么在年轻代中的 Eden 内存区域被占满之后，实际上就需要触发年轻代的 GC，或者是新生代的 GC。此时这个新生代 GC，其实就是所谓的 Minor GC，也可以称之为 Young GC。</p><p><strong>内存担保机制：</strong></p><p>当在新生代无法分配内存时，把新生代的对象转移到老年代，再将新对象放入已经腾空的新生代。</p><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>大对象就是指需要大量连续内存空间的对象，例如字符串、数组等。使创建的大对象直接进入老年代，是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h2 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h2><p>既然虚拟机采用了分代收集的思想管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。</p><h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1 (Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。当对象的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。</p><h2 id="主要进行-GC-的区域"><a href="#主要进行-GC-的区域" class="headerlink" title="主要进行 GC 的区域"></a>主要进行 GC 的区域</h2><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集（Partial GC）：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p><p>只要老年代的连续空间大于新生代对象总大小或者历次代际晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p><h1 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h1><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</p><p>例如下面代码所示，除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceCountingGc</span> {<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br><span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br><span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br>objA.instance = objB;<br>objB.instance = objA;<br>objA = <span class="hljs-literal">null</span>;<br>objB = <span class="hljs-literal"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceCountingGc</span> {<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br><span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br><span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br>objA.instance = objB;<br>objB.instance = objA;<br>objA = <span class="hljs-literal">null</span>;<br>objB = <span class="hljs-literal">null</span>;<br><br>}<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始通过对象间的引用关系向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p>例如下图所示，尽管对象 5、6、7 相互引用，但是它们与 GC Roots 没有相连，因此是可回收的。</p><p><img src="https://s2.loli.net/2022/02/28/dOeW6YPcIk2lbwT.png"></p><p>可作为 GC Roots 的对象包括下面几种:</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>目前，Java 中的引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><h3 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h3><p>最传统的引用的定义，是指在程序代码之中普遍存在的引用赋值，即类似 <code>Object obj = new Object()</code> 这样的引用。</p><p>如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><h3 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h3><p>软引用是用来描述一些还有用、但是非必须的对象，如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h3 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h3><p>弱引用同样用来描述非必须的对象，但是它的强度比软引用更弱，弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。</p><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><blockquote><p>引用队列 ReferenceQueue 是用来配合引用工作的，没有 ReferenceQueue 一样可以运行。创建引用的时候可以指定关联的队列，当GC释放对象内存的时候，会将引用加入到引用队列的队列末尾，这相当于是一种通知机制。当关联的引用队列中有数据的时候，意味着引用指向的堆内存中的对象被回收。</p></blockquote><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>也称为“幽灵引用”或者“幻影引用”，是最弱的一种引用关系，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动，其唯一目的就是在这个对象被回收时收到一个系统通知。</strong></p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>需要注意的是，程序设计中使用软引用的情况居多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</strong></p><h2 id="如何判断一个常量是废弃常量"><a href="#如何判断一个常量是废弃常量" class="headerlink" title="如何判断一个常量是废弃常量"></a>如何判断一个常量是废弃常量</h2><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p>回收废弃常量与回收 Java 堆中的对象非常类似。假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面三个条件才算是无用的类。</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例；</li><li>加载该类的类加载器已经被回收，该条件很难达成；</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>垃圾收集算法包括：标记-清除算法、标记-复制算法、标记-整理算法和分代收集算法</p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象，也可以反过来，标记被回收的对象并统一回收。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。</p><p>该算法带来两个明显的问题：</p><ul><li>执行效率不稳定：如果大部分对象是需要回收的，就需要进行大量标记和清除的动作，导致执行效率随着对象数量的增长而降低；</li><li>内存空间的碎片化问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致未来在程序运行过程中需要分配较大对象时无法找到足够的连续内存。</li></ul><p><img src="https://s2.loli.net/2022/02/28/bx8W2OqiVKL56c4.png"></p><h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>为了解决执行效率不稳定的问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次仅使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p>如果内存中的多数对象都是存活的，该方法会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，该方法则只需要复制少数的存活对象。同时，由于每次都是针对半区进行内存回收，分配内存时也不需要再考虑空间碎片的复杂情况，只需要移动堆顶指针，按顺序分配即可。</p><p>该方法的缺席也显而易见，就是使得可用内存缩小为一半。</p><p><img src="https://s2.loli.net/2022/02/28/MegjkL6Ea39Tyqb.png"></p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记-复制算法在存活对象较多时需要进行较多的复制操作，降低了效率。同时，如果不想浪费一半空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都存活的极端情况。因此，在老年代一般不能直接选用该算法。</p><p>标记-整理算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://s2.loli.net/2022/02/28/nrXYzoW3JcmVT12.png"></p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><p>这也是为什么 HotSpot 需要分新生代和老年代</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器，大家看名字就知道这个收集器是一个单线程收集器。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://s2.loli.net/2022/02/28/BCJjnt62Uwp5fRu.png"></p><p>Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://s2.loli.net/2022/02/28/5XHRAP7VzuJB4fI.png"></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><blockquote><p>复习并发与并行</p><p>并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；<br>并发：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行）</p></blockquote><h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><p>Parallel Scavenge 收集器的主要关注点是吞吐量（即高效率地利用 CPU），而 CMS 等收集器的关注点更多的是用户线程的停顿时间，从而提升用户体验。</p><p>所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</p><p>新生代采用标记-复制算法，老年代采用标记-整理算法。</p><p>该收集器是 JDK 1.8 的默认收集器</p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p>Serial 收集器的老年代版本，它同样是一个单线程收集器。采用标记-整理算法。</p><p>它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用；另一种用途是作为 CMS 收集器的后备方案。</p><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><p>Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。</p><p>在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以 <strong>获取最短回收停顿时间</strong> 为目标的收集器。它非常符合在注重用户体验的应用上使用。</p><p>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p><p>从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的。其运作过程更为复杂，整个过程分为四步：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 GC Roots 相连的对象，速度很快；</li><li><strong>并发标记：</strong>  同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断地更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="https://s2.loli.net/2022/02/28/ge1WZfGUX5MOqLn.png"></p><p>主要优点：并发收集、低停顿</p><p>主要缺点：</p><ul><li>对 CPU 资源敏感；</li><li>无法处理浮动垃圾；</li><li>使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生</li></ul><h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器。该收集器能够在以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</p><p>具备以下特点：</p><ul><li><strong>并发：</strong> G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集：</strong> 虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合：</strong> 与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿：</strong> 是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>运作过程：</p><ul><li><strong>初始标记：</strong> 仅仅标记 GC Roots 能直接关联到的对象，该阶段需要停顿线程，但是时间很短。</li><li><strong>并发标记：</strong> 从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆中的对象图，找出要回收的对象。该阶段耗时较长，但能够与用户线程并发执行。</li><li><strong>最终标记：</strong> 对用户线程做另一个短暂暂停，用于处理并发阶段结束后仍遗留下来的最后少量的 SATB 记录。</li><li><strong>筛选回收：</strong> 制定回收计划，把决定回收的那一部分 Rigion 中的存活对象移动到空的 Rigion 中，再清理掉整个旧 Rigion 的全部空间。必须暂停用户线程，由多条收集器线程并行完成。</li></ul><p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h2 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h2><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><h1 id="系统频繁发生-FullGC-的原因与定位"><a href="#系统频繁发生-FullGC-的原因与定位" class="headerlink" title="系统频繁发生 FullGC 的原因与定位"></a>系统频繁发生 FullGC 的原因与定位</h1><ol><li>机器 CPU 负载过高</li><li>频繁 FullGC</li><li>系统无法请求处理/过慢，与接口无关，是全面性的</li></ol><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>FullGC 的触发条件：老年代空间不足，原因一般在于大量对象频繁进入老年代 + 老年代空间释放不掉</p><ol><li>系统并发量大、执行时间长，或者数据量过大，导致 young gc 频繁，且 GC 后存活对象太多，但是 survivor 区放不下导致对象快速进入老年代，老年代迅速堆满。</li><li>程序一次性加载对象过多、过大，导致频繁有大对象进入老年代，造成 Full GC</li><li>存在内存溢出，老年代驻留了大量释放不掉的对象，只要一点对象进入老年代就会引发 Full GC</li><li>元数据区加载了太多类，满了会引发 Full GC</li><li>堆外内存使用不当</li><li>代码错误：System.gc()</li></ol><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ol><li>观察年轻代 GC 的情况，多久执行一次、每次 GC 后存活对象有多少、survivor 区有多大，若存活对象较多超过 survivor 区大小，则调整内存分配比例</li><li>观察老年代内存情况：水位情况、多久回收一次、耗时多少、回收掉多少内存，如果持续上涨且回收效果不好，那么很可能是内存溢出了</li><li>如果年轻代与老年代都没问题，有可能是元数据区加载东西太多了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
            <tag> 垃圾收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM一-内存结构</title>
      <link href="/2023/11/16/jvm-yi-nei-cun-jie-gou/"/>
      <url>/2023/11/16/jvm-yi-nei-cun-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>对于 Java 程序而言，在虚拟机自动内存管理机制下，不再需要像 C/C++ 那样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出的问题。正是因为 Java 程序把内存控制权力交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>JDK 1.8 ：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210161135.png"></p><p>线程私有的：程序计数器、虚拟机栈、本地方法栈</p><p>线程共享的：堆、方法区、直接内存</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>综上，程序计数器有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</p><p>Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。局部变量表主要存放了编译期可知的各种数据类型、对象引用</p><p>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p><ul><li><code>StackOverFlowError</code>：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出该错误。</li><li><code>OutOfMemoryError</code>： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出该错误</li></ul><blockquote><p>方法/函数如何调用？<br>Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>Java 方法有两种返回方式：return 语句、抛出异常</p></blockquote><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</p><blockquote><p>本地方法：一个native method就是一个Java调用非Java代码的接口。本地方法是这样的一种方法：该方法的实现由非Java语言实现的，比如C。</p></blockquote><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）。</strong> 从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代。在之前的版本中，堆内存被划分为以下的三个部分：新生代、老生代和永生代。JDK 1.8 之后，永生代被移除了，取而代之的是元空间，元空间使用的是直接内存。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220211104844.png"></p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><blockquote><p>方法区和永久代的关系：方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。也就是说，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是 HotSpot 的一种实现。</p></blockquote><h3 id="为什么放弃永久代？"><a href="#为什么放弃永久代？" class="headerlink" title="为什么放弃永久代？"></a>为什么放弃永久代？</h3><ol><li>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li><li>元空间里面存放的是类的元数据，数量由系统的实际可用空间来控制，这样能加载的类就更多了。</li></ol><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分，常量池中主要存放有两大类常量：字面量和符号引用。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。符号引用顾名思义，就是引用；</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</p><h1 id="HotSpot-虚拟机对象"><a href="#HotSpot-虚拟机对象" class="headerlink" title="HotSpot 虚拟机对象"></a>HotSpot 虚拟机对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220211110709.png"></p><h3 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h3><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式有 “指针碰撞” 和 “空闲列表” 两种</strong>。选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220211111630.png"></p><p><strong>内存分配并发问题：</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li>CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li><li>TLAB：为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。</li></ul><h3 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象头中。</p><h3 id="执行-init-方法"><a href="#执行-init-方法" class="headerlink" title="执行 init 方法"></a>执行 init 方法</h3><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。</p><p>Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（例如哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</p><p>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>对象的访问方式由虚拟机实现而定，目前主流的访问方式有 ① 使用句柄和 ② 直接指针两种。</p><blockquote><p>句柄：一个数字，一般和当前系统下的整数的位数一样，比如32bit系统下就是4个字节。该数字是一个对象的唯一标示，和对象一一对应。</p></blockquote><h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220211113850.png"></p><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220211113909.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识三</title>
      <link href="/2023/11/16/java-ji-chu-zhi-shi-san/"/>
      <url>/2023/11/16/java-ji-chu-zhi-shi-san/</url>
      
        <content type="html"><![CDATA[<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>类的加载过程包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>共五个阶段，加载完成之后还有使用和卸载两个阶段。在进行类加载的五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，而解析阶段则不一定，该阶段在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220131111329.png"></p><h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><p>这是类加载过程的第一个阶段，在该阶段，JVM 需要查找并加载类的二进制数据，主要需要完成以下三件事情:</p><ul><li>通过全类名获取定义此类的二进制字节流（将 class 文件加载到内存）</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。（将静态数据结构转化成方法区中运行时的数据结构）</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li></ul><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220131113438.png"></p><p>相对于类加载的其他阶段而言，加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的 二进制字节流 就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><blockquote><p>加载.class文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul></blockquote><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><h2 id="验证：确保被加载的类的正确性"><a href="#验证：确保被加载的类的正确性" class="headerlink" title="验证：确保被加载的类的正确性"></a>验证：确保被加载的类的正确性</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><blockquote><p>确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查。</p></blockquote><p>验证阶段大致会完成4个阶段的检验动作:</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范；</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的；</li><li>符号引用验证：确保解析动作能正确执行。</li></ul><blockquote><p>验证阶段是非常重要的，但不是必需的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p></blockquote><h2 id="准备：为类的静态变量分配内存，并将其初始化为默认值"><a href="#准备：为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="准备：为类的静态变量分配内存，并将其初始化为默认值"></a>准备：为类的静态变量分配内存，并将其初始化为默认值</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。需要注意以下几点：</p><ul><li>这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中；</li><li>这里所设置的初始值通常情况下是数据类型默认的零值(如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在Java代码中被显式地赋予的值。</li></ul><p>假设一个类变量的定义为: <code>public static int value = 3；</code>那么变量value在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何Java方法，而把value赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p><h2 id="解析：把类中的符号引用转换为直接引用"><a href="#解析：把类中的符号引用转换为直接引用" class="headerlink" title="解析：把类中的符号引用转换为直接引用"></a>解析：把类中的符号引用转换为直接引用</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点限定符</code>7类符号引用进行。</p><p>符号引用是指一组符号来描述目标，可以是任何字面量，例如<code>import java.util.ArrayList</code>；直接引用是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄，引用对象一定在内存进行。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><blockquote><p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 s<code>tatic int value</code> 由默认初始化的0变成了显式初始化的3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p></blockquote><blockquote><p>字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，这些方法都是字节码文件中只能给JVM识别的特殊方法。</p></blockquote><h2 id="初始化步骤"><a href="#初始化步骤" class="headerlink" title="初始化步骤"></a>初始化步骤</h2><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类；</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类；</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><p>只有当对类的主动使用的时候才会导致类的初始化，主动使用包括以下六种：</p><ul><li>创建类的实例，也就是new的方式 </li><li>访问某个类或接口的静态变量，或者对该静态变量赋值 </li><li>调用类的静态方法 </li><li>反射(如Class.forName(“com.pdai.jvm.Test”)) </li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>类访问方法区内的数据结构的接口， 对象是Heap区的数据。</p><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>GC将无用对象从内存中卸载</p><p>结束生命周期的几种情况：</p><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h1 id="类加载器的加载顺序（层次）"><a href="#类加载器的加载顺序（层次）" class="headerlink" title="类加载器的加载顺序（层次）"></a>类加载器的加载顺序（层次）</h1><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220206154019.png"></p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220206154839.png"></p><h1 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h1><ul><li><p>全盘负责：</p><p>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p></li><li><p>父类委托：</p><p>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p></li><li><p>缓存机制：</p><p>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p></li><li><p>双亲委派机制</p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></li></ul><h2 id="双亲委派机制的过程"><a href="#双亲委派机制的过程" class="headerlink" title="双亲委派机制的过程"></a>双亲委派机制的过程</h2><ol><li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>如果BootStrapClassLoader加载失败(例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该class)，会使用ExtClassLoader来尝试加载；</li><li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li></ol><h2 id="双亲委派的优势"><a href="#双亲委派的优势" class="headerlink" title="双亲委派的优势"></a>双亲委派的优势</h2><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证Java程序安全稳定运行</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识二</title>
      <link href="/2023/11/16/java-ji-chu-zhi-shi-er/"/>
      <url>/2023/11/16/java-ji-chu-zhi-shi-er/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-集合概述"><a href="#Java-集合概述" class="headerlink" title="Java 集合概述"></a>Java 集合概述</h1><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code> 接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于 <code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220207220515.png"></p><h2 id="List-Set-Queue-Map-四者的区别"><a href="#List-Set-Queue-Map-四者的区别" class="headerlink" title="List, Set, Queue, Map 四者的区别"></a>List, Set, Queue, Map 四者的区别</h2><ul><li>List：存储的元素是有序的、可重复的。</li><li>Set：存储的元素是无序的、不可重复的。</li><li>Queue：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li>Map：使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h2 id="底层数据结构总结"><a href="#底层数据结构总结" class="headerlink" title="底层数据结构总结"></a>底层数据结构总结</h2><p>List</p><ul><li>ArrayList：<code>object[]</code> 数组</li><li>Vector：<code>object[]</code> 数组</li><li>LinkedList：双向链表</li></ul><p>Set</p><ul><li>HashSet：无序、唯一，基于 <code>HashMap</code> 实现，底层采用 <code>HashMap</code> 保存元素</li><li>LinkedHashSet：是 <code>HashSet</code>的子类，并且内部是通过 <code>LinkedHashMap</code> 实现的</li><li>TreeSet：有序、唯一、自平衡的排序二叉树 (红黑树)</li></ul><p>Queue</p><ul><li>PriorityQueue：<code>object[]</code> 数组实现二叉堆</li><li>ArrayQueue：<code>object[]</code> 数组+双指针</li></ul><p>Map</p><ul><li>HashMap：JDK1.8之前，<code>HashMap</code> 由数组 + 链表组成，数组是主体，链表则是为了解决哈希冲突存在的（拉链法解决冲突）。JDK1.8之后，解决哈希冲突有了较大的变化，链表长度大于阈值时（默认为8），将链表转换为红黑树，以减少搜索时间。</li><li>LinkedHashMap：继承自<code>HashMap</code>，底层也由数组和链表或红黑树组成，并在此基础上增加了一条双向链表，使得该结构能够保持键值对的插入顺序。同时通过对链表进行相应操作，实现了访问顺序的相关逻辑。</li><li>Hashtable：数组 + 链表组成，数组为主体，链表主要为了防止哈希冲突。</li><li>TreeMap：红黑树</li></ul><h2 id="如何选用集合？"><a href="#如何选用集合？" class="headerlink" title="如何选用集合？"></a>如何选用集合？</h2><ul><li>ArrayList：动态数组，与普通数组的区别就是它是没有固定大小的限制，可以添加或删除元素。</li><li>LinkedList：链表，增加和删除的操作效率更高，而查找和修改的操作效率较低。其实现了 Queue、Deque 接口，能够作为队列使用，还实现了List 接口，可进行列表的相关操作。</li><li>Vector：线程安全的 ArrayList</li><li>HashSet：实现了 Set 接口，是一个不允许有重复元素的集合。</li><li>LinkedHashSet：有序的 HashSet，使用链表维护元素的次序。当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</li><li>TreeSet：SortedSet 接口的唯一实现类，可以确保集合元素处于排序状态。</li><li>PriorityQueue：优先级队列，它的出队顺序与元素的优先级有关，对 PriorityQueue 调用 remove() 或 poll() 方法，返回的总是优先级最高的元素。</li><li>ArrayQueue：循环队列</li><li>HashMap：普通的哈希表，是无序的</li><li>LinkedHashMap：有序的 HashMap，通过维护一个运行于所有条目的双向链表，LinkedHashMap 保证了元素迭代的顺序。</li><li>Hashtable：线程安全的 HashMap，一次仅允许一个线程对其进行更改。</li><li>TreeMap：能够将内部元素按照键值进行排序，默认为升序。而 LinkedHashMap 则仅仅是记录了插入的顺序。</li></ul><h1 id="Collection-子接口之-List"><a href="#Collection-子接口之-List" class="headerlink" title="Collection 子接口之 List"></a>Collection 子接口之 List</h1><h2 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别"></a>Arraylist 和 Vector 的区别</h2><ul><li>ArrayList 是 List 的主要实现类，底层使用 Object[] 存储，适用于频繁的查找工作，线程不安全；</li><li>Vector 是 List 的古老实现类，底层使用Object[] 存储，线程安全。</li></ul><h2 id="Arraylist-与-LinkedList-的区别"><a href="#Arraylist-与-LinkedList-的区别" class="headerlink" title="Arraylist 与 LinkedList 的区别"></a>Arraylist 与 LinkedList 的区别</h2><ul><li>ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li><li>Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构</li><li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响；LinkedList 采用链表存储，所以如果是在头尾插入或者删除元素不受元素位置的影响</li><li>LinkedList 不支持高效的随机元素访问，而 ArrayList 支持</li><li>ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）</li></ul><h2 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h2><p>在JDK1.8中，如果通过无参构造的话，初始数组容量为0，当真正对数组进行添加时（即添加第一个元素时），才真正分配容量，默认分配容量为10；当容量不足时（容量为size，添加第size+1个元素时），先判断按照1.5倍（位运算）的比例扩容能否满足最低容量要求，若能，则以1.5倍扩容，否则以最低容量要求进行扩容。</p><p>执行add(E e)方法时，先判断ArrayList当前容量是否满足size+1的容量；</p><p>在判断是否满足size+1的容量时，先判断ArrayList是否为空，若为空，则先初始化ArrayList初始容量为10，再判断初始容量是否满足最低容量要求；若不为空，则直接判断当前容量是否满足最低容量要求；</p><p>若满足最低容量要求，则直接添加；若不满足，则先扩容，再添加。</p><h1 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h1><h2 id="无序性和不可重复性的含义"><a href="#无序性和不可重复性的含义" class="headerlink" title="无序性和不可重复性的含义"></a>无序性和不可重复性的含义</h2><ul><li>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>不可重复性是指添加的元素按照 equals() 判断时 ，返回 false，需要同时重写 equals() 方法和 HashCode() 方法。</li></ul><h2 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul><li>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。</li></ul><h1 id="Collection-子接口之-Queue"><a href="#Collection-子接口之-Queue" class="headerlink" title="Collection 子接口之 Queue"></a>Collection 子接口之 Queue</h1><h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><p>Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。 </p><p>Queue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220208111612.png"></p><p>Deque 是双端队列，在队列的两端均可以插入或删除元素。</p><p>Deque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220208111633.png"></p><h2 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h2><p>ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能，两者的主要区别为：</p><ul><li>ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。</li><li>ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。</li><li>ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈。</p><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><ul><li>利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li>通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li>是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。</li><li>默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。</li></ul><h1 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h1><h2 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h2><p>HashSet 底层就是基于 HashMap 实现的。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220208113020.png"></p><h2 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h2><p>TreeMap 和HashMap 都继承自AbstractMap ，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。</p><p>实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。</p><p>实现SortedMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p><p><strong>相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p><h2 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h2><p>当把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置（通过 hashCode 直接计算出存储的位置），同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。</p><p>如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</p><h3 id="hashcode-与-equals-的相关规定"><a href="#hashcode-与-equals-的相关规定" class="headerlink" title="hashcode 与 equals() 的相关规定"></a>hashcode 与 equals() 的相关规定</h3><ul><li>如果两个对象相等，那么 hashcode 一定相同</li><li>两个对象相等，则 equals() 方法一定返回 true</li><li>hashcode 相同，两个对象不一定相等<blockquote><p>这是因为 hashcode 是用算法计算出来的</p></blockquote></li><li>equals() 方法被覆盖过，则 hashCode() 方法也必须被覆盖</li></ul><h3 id="与-equals-的区别"><a href="#与-equals-的区别" class="headerlink" title="== 与 equals 的区别"></a>== 与 equals 的区别</h3><p>最大的区别：一个是运算符一个是方法</p><p>==：对于基本类型，比较的是值是否相同；对于引用类型，比较的是引用是否相同</p><p>例如：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210104615.png"></p><p><strong>解读：</strong> 因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p><p>equals 本质上就是 == ，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。</p><p>例如：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210104840.png"></p><p>最后结果仍然返回 false，说明其和 == 相同，都是比较了引用是否相同。</p><p>但是对于 String 类型，则有：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210105423.png"></p><p>这是因为如 String、Integer、Data 等类型重写了 equals 方法，把它变成了值比较</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>底层实现是 <strong>数组+链表+红黑树</strong> 的形式的，同时它的数组的<strong>默认初始容量是16</strong>、<strong>扩容因子为0.75</strong>，<strong>每次采用2倍的扩容</strong>。</p><blockquote><p>也就是说，每当我们数组中的存储容量达到75%的时候，就需要对数组容量进行2倍的扩容。</p></blockquote><h3 id="HashMap-的-put-过程"><a href="#HashMap-的-put-过程" class="headerlink" title="HashMap 的 put 过程"></a>HashMap 的 put 过程</h3><p>在 HashMap 中，使用数组+链表的实现方式来存储键值对，在 HashMap 的上层使用数组的形式对“相同”的 key 进行存储，下层对相应的 key 和 value 使用链表的形式进行链接和存储。</p><p>HashMap 把将要存储的值按照 key 计算其对应的数组下标。如果对应的数组下标的位置上是没有元素的，那么就将存储的元素存放上去，但是如果该位置上已经存在元素了，那么这就需要用到我们上面所说的链表存储了，将数据按照链表的存储顺序依次向下存储就可以了。这就是put的简单过程，存储结果如下：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210112530.png"></p><p>但是我们有时候存储的数据会很多，那么如果一直使用链表的形式进行数据的存储的话就或造成我们的链表的长度非常大，这样无论在进行删除还是在进行插入操作都是十分麻烦的，因此对于这种情况应该怎么办呢？</p><p>这里就涉及到了一个链表中数据存储时，进行 <strong>“树化”和“链化”</strong> 的一个过程，那么什么是“树化”和“链化”呢？</p><p>当我们在对键值对进行存储的时候，如果我们在同一个数组下标下存储的数据过多的话，就会造成我们的链表长度过长，导致进行删除和插入操作比较麻烦，所以在java中规定，<strong>当链表长度大于8时，我们会对链表进行“树化”操作</strong>，将其转换成一颗红黑树。这样我们在对元素进行查找时，就类似于进行二分查找了，这样的查找效率就会大大增加。</p><blockquote><p>红黑树：一种二叉树，左边节点的值小于根节点，右边节点的值大于根节点</p></blockquote><p>但是当我们进行删除操作，将其中的某些节点删除了之后，链表的长度不再大于8了，此时并不是立刻把红黑树退化为链表，而是<strong>只有当链表的长度小于6</strong>的时候才会重新进行链化。</p><blockquote><p>反复的进行“链化”和“树化”操作特别的消耗时间，而且也比较麻烦。所以程序就规定，只有当当链表长度大于等于8的时候才进行“树化”，而长度小于6的时候才进行“链化”。</p></blockquote><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210114851.png"></p><h3 id="链表中是按照怎样的顺序存放数据的"><a href="#链表中是按照怎样的顺序存放数据的" class="headerlink" title="链表中是按照怎样的顺序存放数据的"></a>链表中是按照怎样的顺序存放数据的</h3><p>对于HashMap中链表元素的存储，<strong>在JDK1.7及之前前是在头结点插入的，在JDK1.8之后是在尾节点插入的。</strong></p><h3 id="按照-key-计算其对应的数组下标-（即-hash-key-方法）"><a href="#按照-key-计算其对应的数组下标-（即-hash-key-方法）" class="headerlink" title="按照 key 计算其对应的数组下标 （即 hash(key) 方法）"></a>按照 key 计算其对应的数组下标 （即 hash(key) 方法）</h3><p>HashMap的初始容量是16位，那么对于初始的16个数据位，如果将数据按照key的值进行计算存储，一般最简单的方法就是根据key值获取到一个int值。通常是先利用 hashCode() 方法获得一个 hashcode，再将该 hashcode 与 16 进行取余运算。这样所得的结果永远在 0-15 范围内。</p><p>但是为了使得计算结果尽可能离散，现在计算数组下标最常用的方法是：</p><p>先根据 key 的值计算到一个 hashCode ，将 hashCode 的高16位二进制和低16位二进制进行异或运算，得到的结果再与当前数组长度减一进行与运算，最终得到一个数组下标。</p><blockquote><p>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作</p></blockquote><p><strong>JDK1.8时，计算hash(key)进行了两次扰动</strong></p><h3 id="为什么HashMap的容量一直是2的幂"><a href="#为什么HashMap的容量一直是2的幂" class="headerlink" title="为什么HashMap的容量一直是2的幂"></a>为什么HashMap的容量一直是2的幂</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。只有参与hash(key)的算法的（n-1）的值尽可能都是1的时候，得到的值才是离散的。所以只有当数组的容量长度是2的倍数的时候，计算得到的hash(key)的值才有可能是相对离散的。</p><h3 id="Hash冲突如何解决"><a href="#Hash冲突如何解决" class="headerlink" title="Hash冲突如何解决"></a>Hash冲突如何解决</h3><p>Hash 冲突，即当我计算到某一个数组下标的时候，该下标上已经存放元素了，这就叫 Hash 冲突。很显然，如果计算数组下标的算法不够优秀的时候，很容易将存储的数据积累到同一个下标上面，造成过多的Hash冲突。</p><p>因此，解决哈希冲突的本质就是让存储的key计算得到的数组下标尽可能的离散，也就是尽可能优化 hash(key)</p><h3 id="HashMap-是如何扩容的"><a href="#HashMap-是如何扩容的" class="headerlink" title="HashMap 是如何扩容的"></a>HashMap 是如何扩容的</h3><p><strong>扩容因子：</strong> 在HashMap中“扩容因子”的大小是0.75，对于初始长度为16的数组，当其中存储的数据长度等于16*0.75=12时。就会对数组元素进行扩容，扩容量是原来数组容量的2倍。</p><blockquote><p>扩容因子 0.75 是出于空间换时间的考虑，扩容因子越大，put 一个数据发生碰撞的概率就越大，因此 0.75 的一个合适的范围</p></blockquote><h3 id="扩容后元素怎么存放的"><a href="#扩容后元素怎么存放的" class="headerlink" title="扩容后元素怎么存放的"></a>扩容后元素怎么存放的</h3><p>在HashMap的数组扩容之后，原先HashMap数组中存放的数据元素会进行重新的位置分配，重新将元素在新数组中进行存储。以充分利用数组空间。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210153243.png"></p><p>在JDK1.8之后，扩容后的元素存放就是对原来的数据下标进行了两次for循环。计算出新下标位置只能是在原下标位置或者在原下标位置加上原容量位置。</p><h2 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h2><p>区别主要体现在实现线程安全的方式上不同</p><ul><li>底层数据结构：<code>ConcurrentHashMap</code> JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。Hashtable 采用数组 + 链表的数据结构，</li><li>实现线程安全的方式：<code>ConcurrentHashMap</code> 在 JDK1.8 中直接用 Node 数组+链表+红黑树 的数据结构来实现线程安全（Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode），并发控制使用 synchronized 和 CAS 来操作。整个看起来就像是优化过且线程安全的 HashMap；<code>Hashtable</code>使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><h1 id="Collection-工具类"><a href="#Collection-工具类" class="headerlink" title="Collection 工具类"></a>Collection 工具类</h1><p>常用方法包括：排序、查找/替换、同步控制</p><h1 id="解决哈希冲突的方式"><a href="#解决哈希冲突的方式" class="headerlink" title="解决哈希冲突的方式"></a>解决哈希冲突的方式</h1><p>开放定址、链地址、再哈希、建立公共溢出区</p><h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p>从发生冲突的单元起，按照一定的次序，在哈希表中找到空闲的单元，然后将发生冲突的元素放入该单元。</p><p>主要有三种探查方式：线性探查、平方探查、双散列函数探查</p><p>缺点在于删除元素时不能真的删除（因为发生哈希冲突的后续元素与该元素有关），只能打上一个特殊标记。</p><h3 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h3><p>最简单，从发生冲突的单元起依次判断下一个元素是否为空，若到达队尾则回到队首继续判断</p><h3 id="平方探查"><a href="#平方探查" class="headerlink" title="平方探查"></a>平方探查</h3><p>用发生冲突的单元加上 1的平方、2的平方等，直到找到空闲</p><h3 id="双散列函数"><a href="#双散列函数" class="headerlink" title="双散列函数"></a>双散列函数</h3><p>通过另一散列函数来生成探查步长值</p><h2 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h2><p>同时构造多个不同的哈希函数，当一个哈希函数产生冲突时，用另一个哈希函数计算，缺点在于增加了计算时间</p><h2 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h2><p>当发生哈希冲突时，将所有冲突数据统一放入溢出区</p><h1 id="ConcurrentHashMap是如何保证线程安全的"><a href="#ConcurrentHashMap是如何保证线程安全的" class="headerlink" title="ConcurrentHashMap是如何保证线程安全的"></a>ConcurrentHashMap是如何保证线程安全的</h1><h2 id="ConcurrentHashMap-1-7"><a href="#ConcurrentHashMap-1-7" class="headerlink" title="ConcurrentHashMap 1.7"></a>ConcurrentHashMap 1.7</h2><p>在 Java 1.7 中，ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦初始化就不能改变，默认 Segment 的个数是 16 个，也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><ol><li><p>计算要 put 的 key 的位置，获取指定位置的 segment</p></li><li><p>如果指定位置 segment 为空，则初始化这个 segment</p><p>初始化流程：</p><ol><li>检查计算得到的位置的 Segment 是否为null.</li><li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li><li>再次检查计算得到的指定位置的 Segment 是否为null.</li><li>使用创建的 HashEntry 数组初始化这个 Segment.</li><li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li></ol></li><li><p>segment.put 插入 key，value 值</p></li></ol><p>由于Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li>tryLock() 获取锁，获取不到使用 scanAndLockForPut 方法继续获取。</li><li>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。</li><li>如果 HashEntry 不存在，则判断是否需要扩容，然后头插法直接插入</li><li>如果 HashEntry 存在，则判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值，不一致则说明发生哈希冲突，需要挂载到链表上</li></ol><h3 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容 rehash"></a>扩容 rehash</h3><p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表头插法插入到指定位置。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><ol><li>计算得到 key 的存放位置</li><li>遍历指定位置查找相同 key 的 value 值</li></ol><h2 id="ConcurrentHashMap-1-8"><a href="#ConcurrentHashMap-1-8" class="headerlink" title="ConcurrentHashMap 1.8"></a>ConcurrentHashMap 1.8</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。其抛弃了原有的 segment 分段锁实现，而是采用了 CAS + synchronized 来保证并发的安全性</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>保证线程安全的措施主要有三个：</p><ol><li>使用 volatile 保证当前 Node 中的值变化对于其他线程来说是可见的</li><li>使用 table 数组的头结点作为 synchronized 的锁来保证写操作的安全</li><li>当头结点为 null 时，使用 CAS 操作来保证数据的正确写入</li></ol><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><ol><li>判断 key、value 是否为空，若为空则抛出异常</li><li>判断容器数组是否为空，若为空则进行初始化</li><li>判断要插入的元素是否是第一次插入，若是则通过 CAS 插入</li><li>判断是否有其他线程正在扩容，若有则一起进行扩容操作</li><li>若发生哈希冲突，将新的 Node 节点按照链表或红黑树的方式插入合适位置</li><li>判断是否需要树化，即链表数量是否超过 8 个</li><li>插入完成之后，进行扩容判断</li></ol><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>不涉及并发操作，直接查询</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>与 put 类似</p><ol><li>循环遍历数组，接着校验参数</li><li>判断是否有别的线程正在扩容，如果是则一起扩容</li><li>用 synchronized 同步锁，保证并发时元素的移除安全</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识一</title>
      <link href="/2023/11/16/java-ji-chu-zhi-shi-yi/"/>
      <url>/2023/11/16/java-ji-chu-zhi-shi-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h2><p>Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p><p>Java 程序从源代码到运行过程：<br><img src="https://s2.loli.net/2021/12/09/wZPW9xvfyqXrL6H.png" alt="1"></p><p>在 <strong>.class -&gt; 字节码</strong> 这一步，JVM 类加载器首先加载字节码文件，之后通过解释器解释执行，执行速度慢。同时由于有些方法和代码块是经常需要被调用的，因此引入了 <strong>JIT</strong> 编译器，属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><h2 id="Java-与-C-的区别？"><a href="#Java-与-C-的区别？" class="headerlink" title="Java 与 C++ 的区别？"></a>Java 与 C++ 的区别？</h2><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h2 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h2><ul><li><p>生命周期</p><p>  静态方法（Static Method）与静态成员变量一样，属于类本身，在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到JVM关闭。</p><p>  非静态方法（Non-Static Method）又叫实例化方法，属于实例对象，实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。 </p></li><li><p>调用方式</p><p>  外部调用静态方法，可用 <strong>类名.方法名</strong> 的方式，也可用 <strong>对象.方法名</strong> 的方式，实例方法则只能用后者。</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>      <span class="hljs-comment">//......</span><br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staicMethod</span><span class="hljs-params">()</span>{<br>      <span class="hljs-comment">//......</span><br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-comment">// 调用实例方法</span><br>        person.method();<br>        <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>      <span class="hljs-comment">//......</span><br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staicMethod</span><span class="hljs-params">()</span>{<br>      <span class="hljs-comment">//......</span><br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-comment">// 调用实例方法</span><br>        person.method();<br>        <span class="hljs-comment">// 调用静态方法</span><br>        Person.staicMethod()<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><p>访问类成员是否存在限制</p><p>  静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p></li><li><p>总结</p><p>如果静态方法在系统中定义太多，会占用大量的资源，最后造成内存溢出，所以静态方法不能滥用。如果从线程安全、性能、兼容性上来看，选用实例化方法为宜。</p></li></ul><h2 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h2><ul><li>静态方法是属于类的，在类加载时会分配内存，可以通过类名直接访问。非静态成员属于实例对象，只有对象实例化之后才能存在，需要通过类的实例对象去访问。</li><li>类的非静态成员不存在时，静态成员就已经存在了，此时调用不存在的静态成员，属于非法操作<br>·</li></ul><h2 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h2><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p><img src="https://s2.loli.net/2021/12/09/yvjJ2NuVDZp6L3m.png" alt="2"></p><p>综上：<strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ul><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ul><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><p><img src="https://s2.loli.net/2021/12/09/r1wLcCBjFGvYfu5.png" alt="3"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Java 泛型（generics） 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><h3 id="什么是类型擦除？"><a href="#什么是类型擦除？" class="headerlink" title="什么是类型擦除？"></a>什么是类型擦除？</h3><p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除。</p><p>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。</p><p><strong>例子：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">List&lt;String&gt; l1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>List&lt;Integer&gt; l2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_"><code class="language-hljs java">List&lt;String&gt; l1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>List&lt;Integer&gt; l2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span><Integer>();<br><br>System.out.println(l1.getClass() == l2.getClass());<br></code></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-literal"><code class="language-hljs java"><span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><p>这因为 <strong>List&lt; String &gt;</strong> 和 <strong>List&lt; Integer &gt;</strong> 在 jvm 中的 Class 都是 List.class。</p><p>而类型 String 和类型 Integer 被泛型转译了。</p><h3 id="常用的通配符"><a href="#常用的通配符" class="headerlink" title="常用的通配符"></a>常用的通配符</h3><p>T，E，K，V，？</p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals() 的区别"></a>== 和 equals() 的区别</h2><p>== 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，== 比较的是值。</li><li>对于引用数据类型来说，== 比较的是对象的内存地址。</li></ul><p>equals() 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类。</p><p>equals() 方法存在两种使用情况：</p><ul><li>类没有覆盖 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。</li><li>类覆盖了 equals()方法 ：一般我们都覆盖 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><p>例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// a 为一个引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// b为另一个引用,对象的内容一样</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 放在常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 从常量池中查找</span><br>System.out.println(aa == bb);<span class="hljs-comment">// true</span><br>System.out.println(a == b);<span class="hljs-comment">// false</span><br>System.out.println(a.equals(b));<span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-number">42</span> == <span class="hljs-number">42.0</span>);<span class="hljs-comment"><code class="language-hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// a 为一个引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// b为另一个引用,对象的内容一样</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 放在常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 从常量池中查找</span><br>System.out.println(aa == bb);<span class="hljs-comment">// true</span><br>System.out.println(a == b);<span class="hljs-comment">// false</span><br>System.out.println(a.equals(b));<span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-number">42</span> == <span class="hljs-number">42.0</span>);<span class="hljs-comment">// true</span><br></code></pre></td></tr></tbody></table></figure><p>String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</p><p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</p><p>String 类中的 equals()方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object anObject)</span> {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == anObject) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">anotherString</span> <span class="hljs-operator">=</span> (String)anObject;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> value.length;<br>        <span class="hljs-keyword">if</span> (n == anotherString.value.length) {<br>            <span class="hljs-type">char</span> v1[] = value;<br>            <span class="hljs-type">char</span> v2[] = anotherString.value;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                i++;<br>            }<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object anObject)</span> {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == anObject) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">anotherString</span> <span class="hljs-operator">=</span> (String)anObject;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> value.length;<br>        <span class="hljs-keyword">if</span> (n == anotherString.value.length) {<br>            <span class="hljs-type">char</span> v1[] = value;<br>            <span class="hljs-type">char</span> v2[] = anotherString.value;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                i++;<br>            }<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h2><p>为什么重写 equals() 时必须重写 hashCode() 方法？</p><h3 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode() 介绍"></a>hashCode() 介绍</h3><p>hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p><h3 id="为什么要有-hashCode-？"><a href="#为什么要有-hashCode-？" class="headerlink" title="为什么要有 hashCode() ？"></a>为什么要有 hashCode() ？</h3><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等。</p><p>即：如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</p><h3 id="为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？"><a href="#为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？" class="headerlink" title="为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？"></a>为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</h3><p>因为 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode )。</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><img src="https://s2.loli.net/2021/12/09/mvNc95ky3BWH8Xe.png"></p><p><strong>注意</strong></p><ul><li>Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析。</li><li>这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean。</li><li>基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><h3 id="包装类型的常量池技术"><a href="#包装类型的常量池技术" class="headerlink" title="包装类型的常量池技术"></a>包装类型的常量池技术</h3><p>Java 基本类型的包装类的大部分都实现了常量池技术。</p><p><img src="https://s2.loli.net/2021/12/09/fU2Gvy4t5qxHPeT.png"></p><p>例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">40</span>);<br>System.out.println(i1==i2);<br></code></pre></td></tr></tbody></table></figure><p>Integer i1=40 这一行代码会发生装箱，也就是说这行代码等价于 Integer i1=Integer.valueOf(40) 。因此，i1 直接使用的是常量池中的对象。而Integer i1 = new Integer(40) 会直接创建新的对象。</p><p>因此输出结果为 false</p><h3 id="自动装拆箱"><a href="#自动装拆箱" class="headerlink" title="自动装拆箱"></a>自动装拆箱</h3><ul><li><strong>装箱：</strong> 将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱：</strong> 将包装类型转换为基本数据类型；</li></ul><p>举例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱</span><br></code></pre></td></tr></tbody></table></figure><ul><li>Integer i = 10 等价于 Integer i = Integer.valueOf(10)</li><li>int n = i 等价于 int n = i.intValue()</li></ul><h2 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h2><h3 id="成员变量、局部变量和静态变量"><a href="#成员变量、局部变量和静态变量" class="headerlink" title="成员变量、局部变量和静态变量"></a>成员变量、局部变量和静态变量</h3><ul><li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；</li><li>从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。</li><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><p>三者的对比图如下：</p><p><img src="https://s2.loli.net/2021/12/09/KlpcAYfnBSuhbWU.png"></p><h3 id="对象实体和对象引用"><a href="#对象实体和对象引用" class="headerlink" title="对象实体和对象引用"></a>对象实体和对象引用</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">Vehicle</span> <span class="hljs-variable">veh1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <br><span class="hljs-comment">//拆分</span><br>Vehicle veh1; <span class="hljs-comment">//对象引用变量</span><br>veh1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-type">Vehicle</span> <span class="hljs-variable">veh1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <br><span class="hljs-comment">//拆分</span><br>Vehicle veh1; <span class="hljs-comment">//对象引用变量</span><br>veh1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <span class="hljs-comment">//对象实体</span><br></code></pre></td></tr></tbody></table></figure><p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>特点：</strong></p><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><p><strong>作用：</strong></p><p>构造方法主要作用是完成对类对象的初始化工作</p><p><strong>若一个类没有声明构造方法，该程序能正确执行吗?</strong></p><p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h3 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h3><p>多态的特点：</p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系； </li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定； </li><li>多态不能调用“只在子类存在但在父类不存在”的方法； </li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h3 id="StringBuffer-和-StringBuilder"><a href="#StringBuffer-和-StringBuilder" class="headerlink" title="StringBuffer 和 StringBuilder"></a>StringBuffer 和 StringBuilder</h3><p><strong>可变性</strong></p><p>String 是不可变的</p><p><strong>线程安全性</strong></p><p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<br>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="深拷贝、浅拷贝和引用拷贝"><a href="#深拷贝、浅拷贝和引用拷贝" class="headerlink" title="深拷贝、浅拷贝和引用拷贝"></a>深拷贝、浅拷贝和引用拷贝</h3><p>拷贝分为两大类：引用拷贝和对象拷贝，深拷贝和浅拷贝属于对象拷贝</p><ul><li><p>引用拷贝</p><p>对引用地址的拷贝，说明引用地址一样，指向堆中的对象也是同一个对象。如果对一个对象进行改变，其他对象也会跟着改变。</p></li><li><p>对象拷贝</p><p>指 对某一对象进行拷贝，是创建了一个全新的对象，也就是内存中存在二个不同地址的对象，这二个对象的基本数据类型变量的内容值都是一样的，但<font color="red">所包含的对象变量的地址可能一样可能不一样</font>，浅拷贝与深拷贝的区别就在这里。</p></li></ul><p>浅拷贝：</p><p>当前对象里包含有对象变量，如果<font color="red">复制的对象中的对象变量和原对象里的对象地址值是相同的</font>，即引用拷贝，则称之为浅拷贝。我们也可以称之为部分拷贝，即拷贝的不彻底。</p><p>深拷贝：</p><p>当前对象里包含有对象变量，如果复制的对象中的对象变量和原对象里的对象地址值是不同的，即<font color="red">创建了一个新的对象</font>，则称之为深拷贝。我们也可以称之为完全拷贝，内部进行了彻底拷贝。</p><p>引用拷贝例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">"Taylor"</span>,<span class="hljs-number">26</span>);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">otherteacher</span> <span class="hljs-operator"><code class="language-hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">"Taylor"</span>,<span class="hljs-number">26</span>);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">otherteacher</span> <span class="hljs-operator">=</span> teacher;<br>System.out.println(teacher);<br>System.out.println(otherteacher);<br></code></pre></td></tr></tbody></table></figure><p>输出结果：</p><pre><code>blog.Teacher@355da254 blog.Teacher@355da254</code></pre><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p><p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(try-catch)， <code>Error</code> 是无法处理的(只能尽量避免)。</p><ul><li><p><code>Exception</code>：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</p></li><li><p><code>Error</code>：Error 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p></li></ul><p>注：出现Error错误一般不是由于你编写的代码出现问题，而是由于JVM运行你这段代码出现了问题，比如堆溢出，配置文件出错等，这些你是无法人为的在你代码里可以保证的，必须要额外的去操作，重新配置虚拟机，修改配置文件等等。</p><p>异常类层次结构图：</p><p><img src="https://s2.loli.net/2021/12/10/lG6yZWUqdOTXDL5.png"></p><p><img src="https://s2.loli.net/2021/12/10/bLONmCSnFTlsG93.png"></p><h3 id="受检查异常-checked-exceptions"><a href="#受检查异常-checked-exceptions" class="headerlink" title="受检查异常(checked exceptions)"></a>受检查异常(checked exceptions)</h3><p>编译器要求你必须处置的异常。如某段代码，编译器要求必须对这段代码try…catch，或者throws exception。也就是说，代码还未运行，编译器就会检查该代码，会不会出现异常，要求你对可能出现的异常必须做出相应的处理。</p><p>又被称为非运行时异常</p><p><strong>几种处理方式：</strong></p><ul><li>继续抛出，消极的方法，一直抛到 Java 虚拟机处理</li><li>用try…catch捕获</li></ul><p>例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> IOException<br>   {<br>      <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"B:/myfile.txt"</span>); <br>      <span class="hljs-type">int</span> k; <br> <br>      <span class="hljs-keyword">while</span>(( k = fis.read() ) != -<span class="hljs-number">1</span>) <br>      { <br>   System.out.print((<span class="hljs-type"><code class="language-hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> IOException<br>   {<br>      <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"B:/myfile.txt"</span>); <br>      <span class="hljs-type">int</span> k; <br> <br>      <span class="hljs-keyword">while</span>(( k = fis.read() ) != -<span class="hljs-number">1</span>) <br>      { <br>   System.out.print((<span class="hljs-type">char</span>)k); <br>      } <br>      fis.close(); <br>   }<br>}<br></code></pre></td></tr></tbody></table></figure><p>若要给出关于异常的具体信息，可以采用 try…catch ：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span><br>   {<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>{<br>    fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"B:/myfile.txt"</span>); <br>}<span class="hljs-keyword">catch</span>(FileNotFoundException fnfe){<br>            System.out.println(<span class="hljs-string">"The specified file is not "</span> +<br><span class="hljs-string">"present at the given path"</span>);<br> }<br><span class="hljs-type">int</span> k; <br><span class="hljs-keyword">try</span>{<br>    <span class="hljs-keyword">while</span>(( k = fis.read() ) != -<span class="hljs-number">1</span>) <br>    { <br>System.out.print((<span class="hljs-type">char</span>)k); <br>    } <br>    fis.close(); <br>}<span class="hljs-keyword">catch</span>(IOException ioe){<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span><br>   {<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>{<br>    fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"B:/myfile.txt"</span>); <br>}<span class="hljs-keyword">catch</span>(FileNotFoundException fnfe){<br>            System.out.println(<span class="hljs-string">"The specified file is not "</span> +<br><span class="hljs-string">"present at the given path"</span>);<br> }<br><span class="hljs-type">int</span> k; <br><span class="hljs-keyword">try</span>{<br>    <span class="hljs-keyword">while</span>(( k = fis.read() ) != -<span class="hljs-number">1</span>) <br>    { <br>System.out.print((<span class="hljs-type">char</span>)k); <br>    } <br>    fis.close(); <br>}<span class="hljs-keyword">catch</span>(IOException ioe){<br>    System.out.println(<span class="hljs-string">"I/O error occurred: "</span>+ioe);<br> }<br>   }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>如何区分？</strong></p><p>除了RuntimeException与其子类，以及错误（Error），其他的都是检查异常（绝对的大家族）。</p><h3 id="不受检查异常-unchecked-exceptions"><a href="#不受检查异常-unchecked-exceptions" class="headerlink" title="不受检查异常(unchecked exceptions)"></a>不受检查异常(unchecked exceptions)</h3><p>编译器不要求强制处置的异常，虽然有可能出错，但不会在编译时检查。</p><p>如NullPointerException，IndexOutOfBoundsException，VirtualMachineError等，又被称为运行时异常</p><p><strong>处理方式：</strong> 捕获、继续抛出、不处理，通常不处理</p><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><ul><li><p><code>try </code>块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 </p></li><li><p><code>catch </code>块： 用于处理 try 捕获到的异常。 </p></li><li><p><code>finally </code>块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行</p></li></ul><p><strong>在以下三种特殊情况下，<code>finally </code>块不会被执行：</strong></p><ul><li><p>在 try 或 finally块中用了 System.exit(int)退出程序。但是，如果 System.exit(int) 在异常语句之后，finally 还是会被执行 </p></li><li><p>程序所在的线程死亡。 </p></li><li><p>关闭 CPU。</p></li></ul><p><strong>注意：</strong><br>当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">return</span> value * value;<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-keyword">if</span> (value == <span class="hljs-number">2</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">return</span> value * value;<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-keyword">if</span> (value == <span class="hljs-number">2</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h2><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><ul><li>序列化：将数据结构或对象转换成二进制字节流的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><h3 id="Java-序列化中避免部分字段序列化"><a href="#Java-序列化中避免部分字段序列化" class="headerlink" title="Java 序列化中避免部分字段序列化"></a>Java 序列化中避免部分字段序列化</h3><p>对于不想序列化的变量，使用<code>transient</code>修饰</p><p>注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。 </li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。 </li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h3 id="I-O-流分类"><a href="#I-O-流分类" class="headerlink" title="I/O 流分类"></a>I/O 流分类</h3><p>按操作方式分类结构图：</p><p><img src="https://s2.loli.net/2021/12/10/JndGwQpU615z94S.png"></p><p>按操作对象分类结构图：</p><p><img src="https://s2.loli.net/2021/12/10/g4FIGOQBqwlmdbs.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/14/hello-world/"/>
      <url>/2023/11/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash">$ hexo new <span class="hljs-string"><code class="language-hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo server<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo generate<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo deploy<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
