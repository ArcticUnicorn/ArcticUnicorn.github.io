<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础知识三</title>
      <link href="/2023/11/16/java-ji-chu-zhi-shi-san/"/>
      <url>/2023/11/16/java-ji-chu-zhi-shi-san/</url>
      
        <content type="html"><![CDATA[<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>类的加载过程包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>共五个阶段，加载完成之后还有使用和卸载两个阶段。在进行类加载的五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，而解析阶段则不一定，该阶段在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220131111329.png"></p><h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><p>这是类加载过程的第一个阶段，在该阶段，JVM 需要查找并加载类的二进制数据，主要需要完成以下三件事情:</p><ul><li>通过全类名获取定义此类的二进制字节流（将 class 文件加载到内存）</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。（将静态数据结构转化成方法区中运行时的数据结构）</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li></ul><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220131113438.png"></p><p>相对于类加载的其他阶段而言，加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的 二进制字节流 就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><blockquote><p>加载.class文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul></blockquote><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><h2 id="验证：确保被加载的类的正确性"><a href="#验证：确保被加载的类的正确性" class="headerlink" title="验证：确保被加载的类的正确性"></a>验证：确保被加载的类的正确性</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><blockquote><p>确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查。</p></blockquote><p>验证阶段大致会完成4个阶段的检验动作:</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范；</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的；</li><li>符号引用验证：确保解析动作能正确执行。</li></ul><blockquote><p>验证阶段是非常重要的，但不是必需的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p></blockquote><h2 id="准备：为类的静态变量分配内存，并将其初始化为默认值"><a href="#准备：为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="准备：为类的静态变量分配内存，并将其初始化为默认值"></a>准备：为类的静态变量分配内存，并将其初始化为默认值</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。需要注意以下几点：</p><ul><li>这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中；</li><li>这里所设置的初始值通常情况下是数据类型默认的零值(如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在Java代码中被显式地赋予的值。</li></ul><p>假设一个类变量的定义为: <code>public static int value = 3；</code>那么变量value在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何Java方法，而把value赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p><h2 id="解析：把类中的符号引用转换为直接引用"><a href="#解析：把类中的符号引用转换为直接引用" class="headerlink" title="解析：把类中的符号引用转换为直接引用"></a>解析：把类中的符号引用转换为直接引用</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点限定符</code>7类符号引用进行。</p><p>符号引用是指一组符号来描述目标，可以是任何字面量，例如<code>import java.util.ArrayList</code>；直接引用是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄，引用对象一定在内存进行。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><blockquote><p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 s<code>tatic int value</code> 由默认初始化的0变成了显式初始化的3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p></blockquote><blockquote><p>字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，这些方法都是字节码文件中只能给JVM识别的特殊方法。</p></blockquote><h2 id="初始化步骤"><a href="#初始化步骤" class="headerlink" title="初始化步骤"></a>初始化步骤</h2><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类；</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类；</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><p>只有当对类的主动使用的时候才会导致类的初始化，主动使用包括以下六种：</p><ul><li>创建类的实例，也就是new的方式 </li><li>访问某个类或接口的静态变量，或者对该静态变量赋值 </li><li>调用类的静态方法 </li><li>反射(如Class.forName(“com.pdai.jvm.Test”)) </li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>类访问方法区内的数据结构的接口， 对象是Heap区的数据。</p><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>GC将无用对象从内存中卸载</p><p>结束生命周期的几种情况：</p><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h1 id="类加载器的加载顺序（层次）"><a href="#类加载器的加载顺序（层次）" class="headerlink" title="类加载器的加载顺序（层次）"></a>类加载器的加载顺序（层次）</h1><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220206154019.png"></p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220206154839.png"></p><h1 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h1><ul><li><p>全盘负责：</p><p>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p></li><li><p>父类委托：</p><p>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p></li><li><p>缓存机制：</p><p>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p></li><li><p>双亲委派机制</p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></li></ul><h2 id="双亲委派机制的过程"><a href="#双亲委派机制的过程" class="headerlink" title="双亲委派机制的过程"></a>双亲委派机制的过程</h2><ol><li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>如果BootStrapClassLoader加载失败(例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该class)，会使用ExtClassLoader来尝试加载；</li><li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li></ol><h2 id="双亲委派的优势"><a href="#双亲委派的优势" class="headerlink" title="双亲委派的优势"></a>双亲委派的优势</h2><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证Java程序安全稳定运行</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识二</title>
      <link href="/2023/11/16/java-ji-chu-zhi-shi-er/"/>
      <url>/2023/11/16/java-ji-chu-zhi-shi-er/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-集合概述"><a href="#Java-集合概述" class="headerlink" title="Java 集合概述"></a>Java 集合概述</h1><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code> 接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于 <code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220207220515.png"></p><h2 id="List-Set-Queue-Map-四者的区别"><a href="#List-Set-Queue-Map-四者的区别" class="headerlink" title="List, Set, Queue, Map 四者的区别"></a>List, Set, Queue, Map 四者的区别</h2><ul><li>List：存储的元素是有序的、可重复的。</li><li>Set：存储的元素是无序的、不可重复的。</li><li>Queue：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li>Map：使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h2 id="底层数据结构总结"><a href="#底层数据结构总结" class="headerlink" title="底层数据结构总结"></a>底层数据结构总结</h2><p>List</p><ul><li>ArrayList：<code>object[]</code> 数组</li><li>Vector：<code>object[]</code> 数组</li><li>LinkedList：双向链表</li></ul><p>Set</p><ul><li>HashSet：无序、唯一，基于 <code>HashMap</code> 实现，底层采用 <code>HashMap</code> 保存元素</li><li>LinkedHashSet：是 <code>HashSet</code>的子类，并且内部是通过 <code>LinkedHashMap</code> 实现的</li><li>TreeSet：有序、唯一、自平衡的排序二叉树 (红黑树)</li></ul><p>Queue</p><ul><li>PriorityQueue：<code>object[]</code> 数组实现二叉堆</li><li>ArrayQueue：<code>object[]</code> 数组+双指针</li></ul><p>Map</p><ul><li>HashMap：JDK1.8之前，<code>HashMap</code> 由数组 + 链表组成，数组是主体，链表则是为了解决哈希冲突存在的（拉链法解决冲突）。JDK1.8之后，解决哈希冲突有了较大的变化，链表长度大于阈值时（默认为8），将链表转换为红黑树，以减少搜索时间。</li><li>LinkedHashMap：继承自<code>HashMap</code>，底层也由数组和链表或红黑树组成，并在此基础上增加了一条双向链表，使得该结构能够保持键值对的插入顺序。同时通过对链表进行相应操作，实现了访问顺序的相关逻辑。</li><li>Hashtable：数组 + 链表组成，数组为主体，链表主要为了防止哈希冲突。</li><li>TreeMap：红黑树</li></ul><h2 id="如何选用集合？"><a href="#如何选用集合？" class="headerlink" title="如何选用集合？"></a>如何选用集合？</h2><ul><li>ArrayList：动态数组，与普通数组的区别就是它是没有固定大小的限制，可以添加或删除元素。</li><li>LinkedList：链表，增加和删除的操作效率更高，而查找和修改的操作效率较低。其实现了 Queue、Deque 接口，能够作为队列使用，还实现了List 接口，可进行列表的相关操作。</li><li>Vector：线程安全的 ArrayList</li><li>HashSet：实现了 Set 接口，是一个不允许有重复元素的集合。</li><li>LinkedHashSet：有序的 HashSet，使用链表维护元素的次序。当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</li><li>TreeSet：SortedSet 接口的唯一实现类，可以确保集合元素处于排序状态。</li><li>PriorityQueue：优先级队列，它的出队顺序与元素的优先级有关，对 PriorityQueue 调用 remove() 或 poll() 方法，返回的总是优先级最高的元素。</li><li>ArrayQueue：循环队列</li><li>HashMap：普通的哈希表，是无序的</li><li>LinkedHashMap：有序的 HashMap，通过维护一个运行于所有条目的双向链表，LinkedHashMap 保证了元素迭代的顺序。</li><li>Hashtable：线程安全的 HashMap，一次仅允许一个线程对其进行更改。</li><li>TreeMap：能够将内部元素按照键值进行排序，默认为升序。而 LinkedHashMap 则仅仅是记录了插入的顺序。</li></ul><h1 id="Collection-子接口之-List"><a href="#Collection-子接口之-List" class="headerlink" title="Collection 子接口之 List"></a>Collection 子接口之 List</h1><h2 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别"></a>Arraylist 和 Vector 的区别</h2><ul><li>ArrayList 是 List 的主要实现类，底层使用 Object[] 存储，适用于频繁的查找工作，线程不安全；</li><li>Vector 是 List 的古老实现类，底层使用Object[] 存储，线程安全。</li></ul><h2 id="Arraylist-与-LinkedList-的区别"><a href="#Arraylist-与-LinkedList-的区别" class="headerlink" title="Arraylist 与 LinkedList 的区别"></a>Arraylist 与 LinkedList 的区别</h2><ul><li>ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li><li>Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构</li><li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响；LinkedList 采用链表存储，所以如果是在头尾插入或者删除元素不受元素位置的影响</li><li>LinkedList 不支持高效的随机元素访问，而 ArrayList 支持</li><li>ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）</li></ul><h2 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h2><p>在JDK1.8中，如果通过无参构造的话，初始数组容量为0，当真正对数组进行添加时（即添加第一个元素时），才真正分配容量，默认分配容量为10；当容量不足时（容量为size，添加第size+1个元素时），先判断按照1.5倍（位运算）的比例扩容能否满足最低容量要求，若能，则以1.5倍扩容，否则以最低容量要求进行扩容。</p><p>执行add(E e)方法时，先判断ArrayList当前容量是否满足size+1的容量；</p><p>在判断是否满足size+1的容量时，先判断ArrayList是否为空，若为空，则先初始化ArrayList初始容量为10，再判断初始容量是否满足最低容量要求；若不为空，则直接判断当前容量是否满足最低容量要求；</p><p>若满足最低容量要求，则直接添加；若不满足，则先扩容，再添加。</p><h1 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h1><h2 id="无序性和不可重复性的含义"><a href="#无序性和不可重复性的含义" class="headerlink" title="无序性和不可重复性的含义"></a>无序性和不可重复性的含义</h2><ul><li>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>不可重复性是指添加的元素按照 equals() 判断时 ，返回 false，需要同时重写 equals() 方法和 HashCode() 方法。</li></ul><h2 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul><li>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。</li></ul><h1 id="Collection-子接口之-Queue"><a href="#Collection-子接口之-Queue" class="headerlink" title="Collection 子接口之 Queue"></a>Collection 子接口之 Queue</h1><h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><p>Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。 </p><p>Queue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220208111612.png"></p><p>Deque 是双端队列，在队列的两端均可以插入或删除元素。</p><p>Deque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220208111633.png"></p><h2 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h2><p>ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能，两者的主要区别为：</p><ul><li>ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。</li><li>ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。</li><li>ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈。</p><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><ul><li>利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li>通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li>是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。</li><li>默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。</li></ul><h1 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h1><h2 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h2><p>HashSet 底层就是基于 HashMap 实现的。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220208113020.png"></p><h2 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h2><p>TreeMap 和HashMap 都继承自AbstractMap ，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。</p><p>实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。</p><p>实现SortedMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p><p><strong>相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p><h2 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h2><p>当把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置（通过 hashCode 直接计算出存储的位置），同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。</p><p>如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</p><h3 id="hashcode-与-equals-的相关规定"><a href="#hashcode-与-equals-的相关规定" class="headerlink" title="hashcode 与 equals() 的相关规定"></a>hashcode 与 equals() 的相关规定</h3><ul><li>如果两个对象相等，那么 hashcode 一定相同</li><li>两个对象相等，则 equals() 方法一定返回 true</li><li>hashcode 相同，两个对象不一定相等<blockquote><p>这是因为 hashcode 是用算法计算出来的</p></blockquote></li><li>equals() 方法被覆盖过，则 hashCode() 方法也必须被覆盖</li></ul><h3 id="与-equals-的区别"><a href="#与-equals-的区别" class="headerlink" title="== 与 equals 的区别"></a>== 与 equals 的区别</h3><p>最大的区别：一个是运算符一个是方法</p><p>==：对于基本类型，比较的是值是否相同；对于引用类型，比较的是引用是否相同</p><p>例如：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210104615.png"></p><p><strong>解读：</strong> 因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p><p>equals 本质上就是 == ，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。</p><p>例如：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210104840.png"></p><p>最后结果仍然返回 false，说明其和 == 相同，都是比较了引用是否相同。</p><p>但是对于 String 类型，则有：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210105423.png"></p><p>这是因为如 String、Integer、Data 等类型重写了 equals 方法，把它变成了值比较</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>底层实现是 <strong>数组+链表+红黑树</strong> 的形式的，同时它的数组的<strong>默认初始容量是16</strong>、<strong>扩容因子为0.75</strong>，<strong>每次采用2倍的扩容</strong>。</p><blockquote><p>也就是说，每当我们数组中的存储容量达到75%的时候，就需要对数组容量进行2倍的扩容。</p></blockquote><h3 id="HashMap-的-put-过程"><a href="#HashMap-的-put-过程" class="headerlink" title="HashMap 的 put 过程"></a>HashMap 的 put 过程</h3><p>在 HashMap 中，使用数组+链表的实现方式来存储键值对，在 HashMap 的上层使用数组的形式对“相同”的 key 进行存储，下层对相应的 key 和 value 使用链表的形式进行链接和存储。</p><p>HashMap 把将要存储的值按照 key 计算其对应的数组下标。如果对应的数组下标的位置上是没有元素的，那么就将存储的元素存放上去，但是如果该位置上已经存在元素了，那么这就需要用到我们上面所说的链表存储了，将数据按照链表的存储顺序依次向下存储就可以了。这就是put的简单过程，存储结果如下：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210112530.png"></p><p>但是我们有时候存储的数据会很多，那么如果一直使用链表的形式进行数据的存储的话就或造成我们的链表的长度非常大，这样无论在进行删除还是在进行插入操作都是十分麻烦的，因此对于这种情况应该怎么办呢？</p><p>这里就涉及到了一个链表中数据存储时，进行 <strong>“树化”和“链化”</strong> 的一个过程，那么什么是“树化”和“链化”呢？</p><p>当我们在对键值对进行存储的时候，如果我们在同一个数组下标下存储的数据过多的话，就会造成我们的链表长度过长，导致进行删除和插入操作比较麻烦，所以在java中规定，<strong>当链表长度大于8时，我们会对链表进行“树化”操作</strong>，将其转换成一颗红黑树。这样我们在对元素进行查找时，就类似于进行二分查找了，这样的查找效率就会大大增加。</p><blockquote><p>红黑树：一种二叉树，左边节点的值小于根节点，右边节点的值大于根节点</p></blockquote><p>但是当我们进行删除操作，将其中的某些节点删除了之后，链表的长度不再大于8了，此时并不是立刻把红黑树退化为链表，而是<strong>只有当链表的长度小于6</strong>的时候才会重新进行链化。</p><blockquote><p>反复的进行“链化”和“树化”操作特别的消耗时间，而且也比较麻烦。所以程序就规定，只有当当链表长度大于等于8的时候才进行“树化”，而长度小于6的时候才进行“链化”。</p></blockquote><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210114851.png"></p><h3 id="链表中是按照怎样的顺序存放数据的"><a href="#链表中是按照怎样的顺序存放数据的" class="headerlink" title="链表中是按照怎样的顺序存放数据的"></a>链表中是按照怎样的顺序存放数据的</h3><p>对于HashMap中链表元素的存储，<strong>在JDK1.7及之前前是在头结点插入的，在JDK1.8之后是在尾节点插入的。</strong></p><h3 id="按照-key-计算其对应的数组下标-（即-hash-key-方法）"><a href="#按照-key-计算其对应的数组下标-（即-hash-key-方法）" class="headerlink" title="按照 key 计算其对应的数组下标 （即 hash(key) 方法）"></a>按照 key 计算其对应的数组下标 （即 hash(key) 方法）</h3><p>HashMap的初始容量是16位，那么对于初始的16个数据位，如果将数据按照key的值进行计算存储，一般最简单的方法就是根据key值获取到一个int值。通常是先利用 hashCode() 方法获得一个 hashcode，再将该 hashcode 与 16 进行取余运算。这样所得的结果永远在 0-15 范围内。</p><p>但是为了使得计算结果尽可能离散，现在计算数组下标最常用的方法是：</p><p>先根据 key 的值计算到一个 hashCode ，将 hashCode 的高16位二进制和低16位二进制进行异或运算，得到的结果再与当前数组长度减一进行与运算，最终得到一个数组下标。</p><blockquote><p>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作</p></blockquote><p><strong>JDK1.8时，计算hash(key)进行了两次扰动</strong></p><h3 id="为什么HashMap的容量一直是2的幂"><a href="#为什么HashMap的容量一直是2的幂" class="headerlink" title="为什么HashMap的容量一直是2的幂"></a>为什么HashMap的容量一直是2的幂</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。只有参与hash(key)的算法的（n-1）的值尽可能都是1的时候，得到的值才是离散的。所以只有当数组的容量长度是2的倍数的时候，计算得到的hash(key)的值才有可能是相对离散的。</p><h3 id="Hash冲突如何解决"><a href="#Hash冲突如何解决" class="headerlink" title="Hash冲突如何解决"></a>Hash冲突如何解决</h3><p>Hash 冲突，即当我计算到某一个数组下标的时候，该下标上已经存放元素了，这就叫 Hash 冲突。很显然，如果计算数组下标的算法不够优秀的时候，很容易将存储的数据积累到同一个下标上面，造成过多的Hash冲突。</p><p>因此，解决哈希冲突的本质就是让存储的key计算得到的数组下标尽可能的离散，也就是尽可能优化 hash(key)</p><h3 id="HashMap-是如何扩容的"><a href="#HashMap-是如何扩容的" class="headerlink" title="HashMap 是如何扩容的"></a>HashMap 是如何扩容的</h3><p><strong>扩容因子：</strong> 在HashMap中“扩容因子”的大小是0.75，对于初始长度为16的数组，当其中存储的数据长度等于16*0.75=12时。就会对数组元素进行扩容，扩容量是原来数组容量的2倍。</p><blockquote><p>扩容因子 0.75 是出于空间换时间的考虑，扩容因子越大，put 一个数据发生碰撞的概率就越大，因此 0.75 的一个合适的范围</p></blockquote><h3 id="扩容后元素怎么存放的"><a href="#扩容后元素怎么存放的" class="headerlink" title="扩容后元素怎么存放的"></a>扩容后元素怎么存放的</h3><p>在HashMap的数组扩容之后，原先HashMap数组中存放的数据元素会进行重新的位置分配，重新将元素在新数组中进行存储。以充分利用数组空间。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210153243.png"></p><p>在JDK1.8之后，扩容后的元素存放就是对原来的数据下标进行了两次for循环。计算出新下标位置只能是在原下标位置或者在原下标位置加上原容量位置。</p><h2 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h2><p>区别主要体现在实现线程安全的方式上不同</p><ul><li>底层数据结构：<code>ConcurrentHashMap</code> JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。Hashtable 采用数组 + 链表的数据结构，</li><li>实现线程安全的方式：<code>ConcurrentHashMap</code> 在 JDK1.8 中直接用 Node 数组+链表+红黑树 的数据结构来实现线程安全（Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode），并发控制使用 synchronized 和 CAS 来操作。整个看起来就像是优化过且线程安全的 HashMap；<code>Hashtable</code>使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><h1 id="Collection-工具类"><a href="#Collection-工具类" class="headerlink" title="Collection 工具类"></a>Collection 工具类</h1><p>常用方法包括：排序、查找/替换、同步控制</p><h1 id="解决哈希冲突的方式"><a href="#解决哈希冲突的方式" class="headerlink" title="解决哈希冲突的方式"></a>解决哈希冲突的方式</h1><p>开放定址、链地址、再哈希、建立公共溢出区</p><h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p>从发生冲突的单元起，按照一定的次序，在哈希表中找到空闲的单元，然后将发生冲突的元素放入该单元。</p><p>主要有三种探查方式：线性探查、平方探查、双散列函数探查</p><p>缺点在于删除元素时不能真的删除（因为发生哈希冲突的后续元素与该元素有关），只能打上一个特殊标记。</p><h3 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h3><p>最简单，从发生冲突的单元起依次判断下一个元素是否为空，若到达队尾则回到队首继续判断</p><h3 id="平方探查"><a href="#平方探查" class="headerlink" title="平方探查"></a>平方探查</h3><p>用发生冲突的单元加上 1的平方、2的平方等，直到找到空闲</p><h3 id="双散列函数"><a href="#双散列函数" class="headerlink" title="双散列函数"></a>双散列函数</h3><p>通过另一散列函数来生成探查步长值</p><h2 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h2><p>同时构造多个不同的哈希函数，当一个哈希函数产生冲突时，用另一个哈希函数计算，缺点在于增加了计算时间</p><h2 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h2><p>当发生哈希冲突时，将所有冲突数据统一放入溢出区</p><h1 id="ConcurrentHashMap是如何保证线程安全的"><a href="#ConcurrentHashMap是如何保证线程安全的" class="headerlink" title="ConcurrentHashMap是如何保证线程安全的"></a>ConcurrentHashMap是如何保证线程安全的</h1><h2 id="ConcurrentHashMap-1-7"><a href="#ConcurrentHashMap-1-7" class="headerlink" title="ConcurrentHashMap 1.7"></a>ConcurrentHashMap 1.7</h2><p>在 Java 1.7 中，ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦初始化就不能改变，默认 Segment 的个数是 16 个，也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><ol><li><p>计算要 put 的 key 的位置，获取指定位置的 segment</p></li><li><p>如果指定位置 segment 为空，则初始化这个 segment</p><p>初始化流程：</p><ol><li>检查计算得到的位置的 Segment 是否为null.</li><li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li><li>再次检查计算得到的指定位置的 Segment 是否为null.</li><li>使用创建的 HashEntry 数组初始化这个 Segment.</li><li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li></ol></li><li><p>segment.put 插入 key，value 值</p></li></ol><p>由于Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li>tryLock() 获取锁，获取不到使用 scanAndLockForPut 方法继续获取。</li><li>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。</li><li>如果 HashEntry 不存在，则判断是否需要扩容，然后头插法直接插入</li><li>如果 HashEntry 存在，则判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值，不一致则说明发生哈希冲突，需要挂载到链表上</li></ol><h3 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容 rehash"></a>扩容 rehash</h3><p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表头插法插入到指定位置。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><ol><li>计算得到 key 的存放位置</li><li>遍历指定位置查找相同 key 的 value 值</li></ol><h2 id="ConcurrentHashMap-1-8"><a href="#ConcurrentHashMap-1-8" class="headerlink" title="ConcurrentHashMap 1.8"></a>ConcurrentHashMap 1.8</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。其抛弃了原有的 segment 分段锁实现，而是采用了 CAS + synchronized 来保证并发的安全性</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>保证线程安全的措施主要有三个：</p><ol><li>使用 volatile 保证当前 Node 中的值变化对于其他线程来说是可见的</li><li>使用 table 数组的头结点作为 synchronized 的锁来保证写操作的安全</li><li>当头结点为 null 时，使用 CAS 操作来保证数据的正确写入</li></ol><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><ol><li>判断 key、value 是否为空，若为空则抛出异常</li><li>判断容器数组是否为空，若为空则进行初始化</li><li>判断要插入的元素是否是第一次插入，若是则通过 CAS 插入</li><li>判断是否有其他线程正在扩容，若有则一起进行扩容操作</li><li>若发生哈希冲突，将新的 Node 节点按照链表或红黑树的方式插入合适位置</li><li>判断是否需要树化，即链表数量是否超过 8 个</li><li>插入完成之后，进行扩容判断</li></ol><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>不涉及并发操作，直接查询</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>与 put 类似</p><ol><li>循环遍历数组，接着校验参数</li><li>判断是否有别的线程正在扩容，如果是则一起扩容</li><li>用 synchronized 同步锁，保证并发时元素的移除安全</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 集合 </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识一</title>
      <link href="/2023/11/16/java-ji-chu-zhi-shi-yi/"/>
      <url>/2023/11/16/java-ji-chu-zhi-shi-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h2><p>Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p><p>Java 程序从源代码到运行过程：<br><img src="https://s2.loli.net/2021/12/09/wZPW9xvfyqXrL6H.png" alt="1"></p><p>在 <strong>.class -&gt; 字节码</strong> 这一步，JVM 类加载器首先加载字节码文件，之后通过解释器解释执行，执行速度慢。同时由于有些方法和代码块是经常需要被调用的，因此引入了 <strong>JIT</strong> 编译器，属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><h2 id="Java-与-C-的区别？"><a href="#Java-与-C-的区别？" class="headerlink" title="Java 与 C++ 的区别？"></a>Java 与 C++ 的区别？</h2><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h2 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h2><ul><li><p>生命周期</p><p>  静态方法（Static Method）与静态成员变量一样，属于类本身，在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到JVM关闭。</p><p>  非静态方法（Non-Static Method）又叫实例化方法，属于实例对象，实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。 </p></li><li><p>调用方式</p><p>  外部调用静态方法，可用 <strong>类名.方法名</strong> 的方式，也可用 <strong>对象.方法名</strong> 的方式，实例方法则只能用后者。</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>      <span class="hljs-comment">//......</span><br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staicMethod</span><span class="hljs-params">()</span>{<br>      <span class="hljs-comment">//......</span><br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-comment">// 调用实例方法</span><br>        person.method();<br>        <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>      <span class="hljs-comment">//......</span><br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staicMethod</span><span class="hljs-params">()</span>{<br>      <span class="hljs-comment">//......</span><br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-comment">// 调用实例方法</span><br>        person.method();<br>        <span class="hljs-comment">// 调用静态方法</span><br>        Person.staicMethod()<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><p>访问类成员是否存在限制</p><p>  静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p></li><li><p>总结</p><p>如果静态方法在系统中定义太多，会占用大量的资源，最后造成内存溢出，所以静态方法不能滥用。如果从线程安全、性能、兼容性上来看，选用实例化方法为宜。</p></li></ul><h2 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h2><ul><li>静态方法是属于类的，在类加载时会分配内存，可以通过类名直接访问。非静态成员属于实例对象，只有对象实例化之后才能存在，需要通过类的实例对象去访问。</li><li>类的非静态成员不存在时，静态成员就已经存在了，此时调用不存在的静态成员，属于非法操作<br>·</li></ul><h2 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h2><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p><img src="https://s2.loli.net/2021/12/09/yvjJ2NuVDZp6L3m.png" alt="2"></p><p>综上：<strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ul><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ul><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><p><img src="https://s2.loli.net/2021/12/09/r1wLcCBjFGvYfu5.png" alt="3"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Java 泛型（generics） 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><h3 id="什么是类型擦除？"><a href="#什么是类型擦除？" class="headerlink" title="什么是类型擦除？"></a>什么是类型擦除？</h3><p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除。</p><p>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。</p><p><strong>例子：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">List&lt;String&gt; l1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>List&lt;Integer&gt; l2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_"><code class="language-hljs java">List&lt;String&gt; l1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>List&lt;Integer&gt; l2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span><Integer>();<br><br>System.out.println(l1.getClass() == l2.getClass());<br></code></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-literal"><code class="language-hljs java"><span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><p>这因为 <strong>List&lt; String &gt;</strong> 和 <strong>List&lt; Integer &gt;</strong> 在 jvm 中的 Class 都是 List.class。</p><p>而类型 String 和类型 Integer 被泛型转译了。</p><h3 id="常用的通配符"><a href="#常用的通配符" class="headerlink" title="常用的通配符"></a>常用的通配符</h3><p>T，E，K，V，？</p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals() 的区别"></a>== 和 equals() 的区别</h2><p>== 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，== 比较的是值。</li><li>对于引用数据类型来说，== 比较的是对象的内存地址。</li></ul><p>equals() 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类。</p><p>equals() 方法存在两种使用情况：</p><ul><li>类没有覆盖 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。</li><li>类覆盖了 equals()方法 ：一般我们都覆盖 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><p>例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// a 为一个引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// b为另一个引用,对象的内容一样</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 放在常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 从常量池中查找</span><br>System.out.println(aa == bb);<span class="hljs-comment">// true</span><br>System.out.println(a == b);<span class="hljs-comment">// false</span><br>System.out.println(a.equals(b));<span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-number">42</span> == <span class="hljs-number">42.0</span>);<span class="hljs-comment"><code class="language-hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// a 为一个引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// b为另一个引用,对象的内容一样</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 放在常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 从常量池中查找</span><br>System.out.println(aa == bb);<span class="hljs-comment">// true</span><br>System.out.println(a == b);<span class="hljs-comment">// false</span><br>System.out.println(a.equals(b));<span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-number">42</span> == <span class="hljs-number">42.0</span>);<span class="hljs-comment">// true</span><br></code></pre></td></tr></tbody></table></figure><p>String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</p><p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</p><p>String 类中的 equals()方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object anObject)</span> {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == anObject) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">anotherString</span> <span class="hljs-operator">=</span> (String)anObject;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> value.length;<br>        <span class="hljs-keyword">if</span> (n == anotherString.value.length) {<br>            <span class="hljs-type">char</span> v1[] = value;<br>            <span class="hljs-type">char</span> v2[] = anotherString.value;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                i++;<br>            }<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object anObject)</span> {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == anObject) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">anotherString</span> <span class="hljs-operator">=</span> (String)anObject;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> value.length;<br>        <span class="hljs-keyword">if</span> (n == anotherString.value.length) {<br>            <span class="hljs-type">char</span> v1[] = value;<br>            <span class="hljs-type">char</span> v2[] = anotherString.value;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                i++;<br>            }<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h2><p>为什么重写 equals() 时必须重写 hashCode() 方法？</p><h3 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode() 介绍"></a>hashCode() 介绍</h3><p>hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p><h3 id="为什么要有-hashCode-？"><a href="#为什么要有-hashCode-？" class="headerlink" title="为什么要有 hashCode() ？"></a>为什么要有 hashCode() ？</h3><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等。</p><p>即：如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</p><h3 id="为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？"><a href="#为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？" class="headerlink" title="为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？"></a>为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</h3><p>因为 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode )。</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><img src="https://s2.loli.net/2021/12/09/mvNc95ky3BWH8Xe.png"></p><p><strong>注意</strong></p><ul><li>Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析。</li><li>这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean。</li><li>基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><h3 id="包装类型的常量池技术"><a href="#包装类型的常量池技术" class="headerlink" title="包装类型的常量池技术"></a>包装类型的常量池技术</h3><p>Java 基本类型的包装类的大部分都实现了常量池技术。</p><p><img src="https://s2.loli.net/2021/12/09/fU2Gvy4t5qxHPeT.png"></p><p>例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">40</span>);<br>System.out.println(i1==i2);<br></code></pre></td></tr></tbody></table></figure><p>Integer i1=40 这一行代码会发生装箱，也就是说这行代码等价于 Integer i1=Integer.valueOf(40) 。因此，i1 直接使用的是常量池中的对象。而Integer i1 = new Integer(40) 会直接创建新的对象。</p><p>因此输出结果为 false</p><h3 id="自动装拆箱"><a href="#自动装拆箱" class="headerlink" title="自动装拆箱"></a>自动装拆箱</h3><ul><li><strong>装箱：</strong> 将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱：</strong> 将包装类型转换为基本数据类型；</li></ul><p>举例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱</span><br></code></pre></td></tr></tbody></table></figure><ul><li>Integer i = 10 等价于 Integer i = Integer.valueOf(10)</li><li>int n = i 等价于 int n = i.intValue()</li></ul><h2 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h2><h3 id="成员变量、局部变量和静态变量"><a href="#成员变量、局部变量和静态变量" class="headerlink" title="成员变量、局部变量和静态变量"></a>成员变量、局部变量和静态变量</h3><ul><li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；</li><li>从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。</li><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><p>三者的对比图如下：</p><p><img src="https://s2.loli.net/2021/12/09/KlpcAYfnBSuhbWU.png"></p><h3 id="对象实体和对象引用"><a href="#对象实体和对象引用" class="headerlink" title="对象实体和对象引用"></a>对象实体和对象引用</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">Vehicle</span> <span class="hljs-variable">veh1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <br><span class="hljs-comment">//拆分</span><br>Vehicle veh1; <span class="hljs-comment">//对象引用变量</span><br>veh1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-type">Vehicle</span> <span class="hljs-variable">veh1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <br><span class="hljs-comment">//拆分</span><br>Vehicle veh1; <span class="hljs-comment">//对象引用变量</span><br>veh1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <span class="hljs-comment">//对象实体</span><br></code></pre></td></tr></tbody></table></figure><p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>特点：</strong></p><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><p><strong>作用：</strong></p><p>构造方法主要作用是完成对类对象的初始化工作</p><p><strong>若一个类没有声明构造方法，该程序能正确执行吗?</strong></p><p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h3 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h3><p>多态的特点：</p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系； </li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定； </li><li>多态不能调用“只在子类存在但在父类不存在”的方法； </li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h3 id="StringBuffer-和-StringBuilder"><a href="#StringBuffer-和-StringBuilder" class="headerlink" title="StringBuffer 和 StringBuilder"></a>StringBuffer 和 StringBuilder</h3><p><strong>可变性</strong></p><p>String 是不可变的</p><p><strong>线程安全性</strong></p><p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<br>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="深拷贝、浅拷贝和引用拷贝"><a href="#深拷贝、浅拷贝和引用拷贝" class="headerlink" title="深拷贝、浅拷贝和引用拷贝"></a>深拷贝、浅拷贝和引用拷贝</h3><p>拷贝分为两大类：引用拷贝和对象拷贝，深拷贝和浅拷贝属于对象拷贝</p><ul><li><p>引用拷贝</p><p>对引用地址的拷贝，说明引用地址一样，指向堆中的对象也是同一个对象。如果对一个对象进行改变，其他对象也会跟着改变。</p></li><li><p>对象拷贝</p><p>指 对某一对象进行拷贝，是创建了一个全新的对象，也就是内存中存在二个不同地址的对象，这二个对象的基本数据类型变量的内容值都是一样的，但<font color="red">所包含的对象变量的地址可能一样可能不一样</font>，浅拷贝与深拷贝的区别就在这里。</p></li></ul><p>浅拷贝：</p><p>当前对象里包含有对象变量，如果<font color="red">复制的对象中的对象变量和原对象里的对象地址值是相同的</font>，即引用拷贝，则称之为浅拷贝。我们也可以称之为部分拷贝，即拷贝的不彻底。</p><p>深拷贝：</p><p>当前对象里包含有对象变量，如果复制的对象中的对象变量和原对象里的对象地址值是不同的，即<font color="red">创建了一个新的对象</font>，则称之为深拷贝。我们也可以称之为完全拷贝，内部进行了彻底拷贝。</p><p>引用拷贝例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">"Taylor"</span>,<span class="hljs-number">26</span>);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">otherteacher</span> <span class="hljs-operator"><code class="language-hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">"Taylor"</span>,<span class="hljs-number">26</span>);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">otherteacher</span> <span class="hljs-operator">=</span> teacher;<br>System.out.println(teacher);<br>System.out.println(otherteacher);<br></code></pre></td></tr></tbody></table></figure><p>输出结果：</p><pre><code>blog.Teacher@355da254 blog.Teacher@355da254</code></pre><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p><p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(try-catch)， <code>Error</code> 是无法处理的(只能尽量避免)。</p><ul><li><p><code>Exception</code>：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</p></li><li><p><code>Error</code>：Error 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p></li></ul><p>注：出现Error错误一般不是由于你编写的代码出现问题，而是由于JVM运行你这段代码出现了问题，比如堆溢出，配置文件出错等，这些你是无法人为的在你代码里可以保证的，必须要额外的去操作，重新配置虚拟机，修改配置文件等等。</p><p>异常类层次结构图：</p><p><img src="https://s2.loli.net/2021/12/10/lG6yZWUqdOTXDL5.png"></p><p><img src="https://s2.loli.net/2021/12/10/bLONmCSnFTlsG93.png"></p><h3 id="受检查异常-checked-exceptions"><a href="#受检查异常-checked-exceptions" class="headerlink" title="受检查异常(checked exceptions)"></a>受检查异常(checked exceptions)</h3><p>编译器要求你必须处置的异常。如某段代码，编译器要求必须对这段代码try…catch，或者throws exception。也就是说，代码还未运行，编译器就会检查该代码，会不会出现异常，要求你对可能出现的异常必须做出相应的处理。</p><p>又被称为非运行时异常</p><p><strong>几种处理方式：</strong></p><ul><li>继续抛出，消极的方法，一直抛到 Java 虚拟机处理</li><li>用try…catch捕获</li></ul><p>例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> IOException<br>   {<br>      <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"B:/myfile.txt"</span>); <br>      <span class="hljs-type">int</span> k; <br> <br>      <span class="hljs-keyword">while</span>(( k = fis.read() ) != -<span class="hljs-number">1</span>) <br>      { <br>   System.out.print((<span class="hljs-type"><code class="language-hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> IOException<br>   {<br>      <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"B:/myfile.txt"</span>); <br>      <span class="hljs-type">int</span> k; <br> <br>      <span class="hljs-keyword">while</span>(( k = fis.read() ) != -<span class="hljs-number">1</span>) <br>      { <br>   System.out.print((<span class="hljs-type">char</span>)k); <br>      } <br>      fis.close(); <br>   }<br>}<br></code></pre></td></tr></tbody></table></figure><p>若要给出关于异常的具体信息，可以采用 try…catch ：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span><br>   {<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>{<br>    fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"B:/myfile.txt"</span>); <br>}<span class="hljs-keyword">catch</span>(FileNotFoundException fnfe){<br>            System.out.println(<span class="hljs-string">"The specified file is not "</span> +<br><span class="hljs-string">"present at the given path"</span>);<br> }<br><span class="hljs-type">int</span> k; <br><span class="hljs-keyword">try</span>{<br>    <span class="hljs-keyword">while</span>(( k = fis.read() ) != -<span class="hljs-number">1</span>) <br>    { <br>System.out.print((<span class="hljs-type">char</span>)k); <br>    } <br>    fis.close(); <br>}<span class="hljs-keyword">catch</span>(IOException ioe){<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span><br>   {<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>{<br>    fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"B:/myfile.txt"</span>); <br>}<span class="hljs-keyword">catch</span>(FileNotFoundException fnfe){<br>            System.out.println(<span class="hljs-string">"The specified file is not "</span> +<br><span class="hljs-string">"present at the given path"</span>);<br> }<br><span class="hljs-type">int</span> k; <br><span class="hljs-keyword">try</span>{<br>    <span class="hljs-keyword">while</span>(( k = fis.read() ) != -<span class="hljs-number">1</span>) <br>    { <br>System.out.print((<span class="hljs-type">char</span>)k); <br>    } <br>    fis.close(); <br>}<span class="hljs-keyword">catch</span>(IOException ioe){<br>    System.out.println(<span class="hljs-string">"I/O error occurred: "</span>+ioe);<br> }<br>   }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>如何区分？</strong></p><p>除了RuntimeException与其子类，以及错误（Error），其他的都是检查异常（绝对的大家族）。</p><h3 id="不受检查异常-unchecked-exceptions"><a href="#不受检查异常-unchecked-exceptions" class="headerlink" title="不受检查异常(unchecked exceptions)"></a>不受检查异常(unchecked exceptions)</h3><p>编译器不要求强制处置的异常，虽然有可能出错，但不会在编译时检查。</p><p>如NullPointerException，IndexOutOfBoundsException，VirtualMachineError等，又被称为运行时异常</p><p><strong>处理方式：</strong> 捕获、继续抛出、不处理，通常不处理</p><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><ul><li><p><code>try </code>块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 </p></li><li><p><code>catch </code>块： 用于处理 try 捕获到的异常。 </p></li><li><p><code>finally </code>块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行</p></li></ul><p><strong>在以下三种特殊情况下，<code>finally </code>块不会被执行：</strong></p><ul><li><p>在 try 或 finally块中用了 System.exit(int)退出程序。但是，如果 System.exit(int) 在异常语句之后，finally 还是会被执行 </p></li><li><p>程序所在的线程死亡。 </p></li><li><p>关闭 CPU。</p></li></ul><p><strong>注意：</strong><br>当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">return</span> value * value;<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-keyword">if</span> (value == <span class="hljs-number">2</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">return</span> value * value;<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-keyword">if</span> (value == <span class="hljs-number">2</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h2><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><ul><li>序列化：将数据结构或对象转换成二进制字节流的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><h3 id="Java-序列化中避免部分字段序列化"><a href="#Java-序列化中避免部分字段序列化" class="headerlink" title="Java 序列化中避免部分字段序列化"></a>Java 序列化中避免部分字段序列化</h3><p>对于不想序列化的变量，使用<code>transient</code>修饰</p><p>注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。 </li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。 </li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h3 id="I-O-流分类"><a href="#I-O-流分类" class="headerlink" title="I/O 流分类"></a>I/O 流分类</h3><p>按操作方式分类结构图：</p><p><img src="https://s2.loli.net/2021/12/10/JndGwQpU615z94S.png"></p><p>按操作对象分类结构图：</p><p><img src="https://s2.loli.net/2021/12/10/g4FIGOQBqwlmdbs.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/14/hello-world/"/>
      <url>/2023/11/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash">$ hexo new <span class="hljs-string"><code class="language-hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo server<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo generate<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo deploy<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
