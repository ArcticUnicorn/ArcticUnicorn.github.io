<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM二-垃圾回收</title>
      <link href="/2023/11/16/jvm-er-la-ji-hui-shou/"/>
      <url>/2023/11/16/jvm-er-la-ji-hui-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-内存分配与回收简介"><a href="#JVM-内存分配与回收简介" class="headerlink" title="JVM 内存分配与回收简介"></a>JVM 内存分配与回收简介</h1><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代，再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p>堆空间的基本结构：</p><p><img src="https://s2.loli.net/2022/02/28/VRPeGFLQyXAdajo.png"></p><p>大部分情况，对象都会首先在 Eden 区域进行分配，在一次新生代垃圾回收之后，如果对象还有存活，则会进入 s0 或 s1，并且对象的年龄将会增加 1 (Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当对象年龄增加到一定程度后（默认为15岁），就会被晋升到老年代中。</p><h2 id="对象优先在-eden-区分配"><a href="#对象优先在-eden-区分配" class="headerlink" title="对象优先在 eden 区分配"></a>对象优先在 eden 区分配</h2><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中会优先在 eden 区分配，当 endn 区没有足够的空间时，会进行一次 Minor GC</p><blockquote><p>Minor GC / Young GC</p></blockquote><p>新生代（Young Gen）也可以称之为年轻代，这两个名词是等价的。那么在年轻代中的 Eden 内存区域被占满之后，实际上就需要触发年轻代的 GC，或者是新生代的 GC。此时这个新生代 GC，其实就是所谓的 Minor GC，也可以称之为 Young GC。</p><p><strong>内存担保机制：</strong></p><p>当在新生代无法分配内存时，把新生代的对象转移到老年代，再将新对象放入已经腾空的新生代。</p><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>大对象就是指需要大量连续内存空间的对象，例如字符串、数组等。使创建的大对象直接进入老年代，是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h2 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h2><p>既然虚拟机采用了分代收集的思想管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。</p><h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1 (Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。当对象的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。</p><h2 id="主要进行-GC-的区域"><a href="#主要进行-GC-的区域" class="headerlink" title="主要进行 GC 的区域"></a>主要进行 GC 的区域</h2><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集（Partial GC）：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p><p>只要老年代的连续空间大于新生代对象总大小或者历次代际晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p><h1 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h1><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</p><p>例如下面代码所示，除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceCountingGc</span> {<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br><span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br><span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br>objA.instance = objB;<br>objB.instance = objA;<br>objA = <span class="hljs-literal">null</span>;<br>objB = <span class="hljs-literal"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceCountingGc</span> {<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br><span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br><span class="hljs-type">ReferenceCountingGc</span> <span class="hljs-variable">objB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceCountingGc</span>();<br>objA.instance = objB;<br>objB.instance = objA;<br>objA = <span class="hljs-literal">null</span>;<br>objB = <span class="hljs-literal">null</span>;<br><br>}<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始通过对象间的引用关系向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p>例如下图所示，尽管对象 5、6、7 相互引用，但是它们与 GC Roots 没有相连，因此是可回收的。</p><p><img src="https://s2.loli.net/2022/02/28/dOeW6YPcIk2lbwT.png"></p><p>可作为 GC Roots 的对象包括下面几种:</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>目前，Java 中的引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><h3 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h3><p>最传统的引用的定义，是指在程序代码之中普遍存在的引用赋值，即类似 <code>Object obj = new Object()</code> 这样的引用。</p><p>如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><h3 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h3><p>软引用是用来描述一些还有用、但是非必须的对象，如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h3 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h3><p>弱引用同样用来描述非必须的对象，但是它的强度比软引用更弱，弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。</p><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><blockquote><p>引用队列 ReferenceQueue 是用来配合引用工作的，没有 ReferenceQueue 一样可以运行。创建引用的时候可以指定关联的队列，当GC释放对象内存的时候，会将引用加入到引用队列的队列末尾，这相当于是一种通知机制。当关联的引用队列中有数据的时候，意味着引用指向的堆内存中的对象被回收。</p></blockquote><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>也称为“幽灵引用”或者“幻影引用”，是最弱的一种引用关系，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动，其唯一目的就是在这个对象被回收时收到一个系统通知。</strong></p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>需要注意的是，程序设计中使用软引用的情况居多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</strong></p><h2 id="如何判断一个常量是废弃常量"><a href="#如何判断一个常量是废弃常量" class="headerlink" title="如何判断一个常量是废弃常量"></a>如何判断一个常量是废弃常量</h2><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p>回收废弃常量与回收 Java 堆中的对象非常类似。假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面三个条件才算是无用的类。</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例；</li><li>加载该类的类加载器已经被回收，该条件很难达成；</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>垃圾收集算法包括：标记-清除算法、标记-复制算法、标记-整理算法和分代收集算法</p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象，也可以反过来，标记被回收的对象并统一回收。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。</p><p>该算法带来两个明显的问题：</p><ul><li>执行效率不稳定：如果大部分对象是需要回收的，就需要进行大量标记和清除的动作，导致执行效率随着对象数量的增长而降低；</li><li>内存空间的碎片化问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致未来在程序运行过程中需要分配较大对象时无法找到足够的连续内存。</li></ul><p><img src="https://s2.loli.net/2022/02/28/bx8W2OqiVKL56c4.png"></p><h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>为了解决执行效率不稳定的问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次仅使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p>如果内存中的多数对象都是存活的，该方法会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，该方法则只需要复制少数的存活对象。同时，由于每次都是针对半区进行内存回收，分配内存时也不需要再考虑空间碎片的复杂情况，只需要移动堆顶指针，按顺序分配即可。</p><p>该方法的缺席也显而易见，就是使得可用内存缩小为一半。</p><p><img src="https://s2.loli.net/2022/02/28/MegjkL6Ea39Tyqb.png"></p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记-复制算法在存活对象较多时需要进行较多的复制操作，降低了效率。同时，如果不想浪费一半空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都存活的极端情况。因此，在老年代一般不能直接选用该算法。</p><p>标记-整理算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://s2.loli.net/2022/02/28/nrXYzoW3JcmVT12.png"></p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><p>这也是为什么 HotSpot 需要分新生代和老年代</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器，大家看名字就知道这个收集器是一个单线程收集器。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://s2.loli.net/2022/02/28/BCJjnt62Uwp5fRu.png"></p><p>Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://s2.loli.net/2022/02/28/5XHRAP7VzuJB4fI.png"></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><blockquote><p>复习并发与并行</p><p>并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；<br>并发：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行）</p></blockquote><h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><p>Parallel Scavenge 收集器的主要关注点是吞吐量（即高效率地利用 CPU），而 CMS 等收集器的关注点更多的是用户线程的停顿时间，从而提升用户体验。</p><p>所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</p><p>新生代采用标记-复制算法，老年代采用标记-整理算法。</p><p>该收集器是 JDK 1.8 的默认收集器</p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p>Serial 收集器的老年代版本，它同样是一个单线程收集器。采用标记-整理算法。</p><p>它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用；另一种用途是作为 CMS 收集器的后备方案。</p><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><p>Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。</p><p>在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以 <strong>获取最短回收停顿时间</strong> 为目标的收集器。它非常符合在注重用户体验的应用上使用。</p><p>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p><p>从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的。其运作过程更为复杂，整个过程分为四步：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 GC Roots 相连的对象，速度很快；</li><li><strong>并发标记：</strong>  同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断地更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="https://s2.loli.net/2022/02/28/ge1WZfGUX5MOqLn.png"></p><p>主要优点：并发收集、低停顿</p><p>主要缺点：</p><ul><li>对 CPU 资源敏感；</li><li>无法处理浮动垃圾；</li><li>使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生</li></ul><h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器。该收集器能够在以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</p><p>具备以下特点：</p><ul><li><strong>并发：</strong> G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集：</strong> 虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合：</strong> 与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿：</strong> 是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>运作过程：</p><ul><li><strong>初始标记：</strong> 仅仅标记 GC Roots 能直接关联到的对象，该阶段需要停顿线程，但是时间很短。</li><li><strong>并发标记：</strong> 从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆中的对象图，找出要回收的对象。该阶段耗时较长，但能够与用户线程并发执行。</li><li><strong>最终标记：</strong> 对用户线程做另一个短暂暂停，用于处理并发阶段结束后仍遗留下来的最后少量的 SATB 记录。</li><li><strong>筛选回收：</strong> 制定回收计划，把决定回收的那一部分 Rigion 中的存活对象移动到空的 Rigion 中，再清理掉整个旧 Rigion 的全部空间。必须暂停用户线程，由多条收集器线程并行完成。</li></ul><p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h2 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h2><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><h1 id="系统频繁发生-FullGC-的原因与定位"><a href="#系统频繁发生-FullGC-的原因与定位" class="headerlink" title="系统频繁发生 FullGC 的原因与定位"></a>系统频繁发生 FullGC 的原因与定位</h1><ol><li>机器 CPU 负载过高</li><li>频繁 FullGC</li><li>系统无法请求处理/过慢，与接口无关，是全面性的</li></ol><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>FullGC 的触发条件：老年代空间不足，原因一般在于大量对象频繁进入老年代 + 老年代空间释放不掉</p><ol><li>系统并发量大、执行时间长，或者数据量过大，导致 young gc 频繁，且 GC 后存活对象太多，但是 survivor 区放不下导致对象快速进入老年代，老年代迅速堆满。</li><li>程序一次性加载对象过多、过大，导致频繁有大对象进入老年代，造成 Full GC</li><li>存在内存溢出，老年代驻留了大量释放不掉的对象，只要一点对象进入老年代就会引发 Full GC</li><li>元数据区加载了太多类，满了会引发 Full GC</li><li>堆外内存使用不当</li><li>代码错误：System.gc()</li></ol><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ol><li>观察年轻代 GC 的情况，多久执行一次、每次 GC 后存活对象有多少、survivor 区有多大，若存活对象较多超过 survivor 区大小，则调整内存分配比例</li><li>观察老年代内存情况：水位情况、多久回收一次、耗时多少、回收掉多少内存，如果持续上涨且回收效果不好，那么很可能是内存溢出了</li><li>如果年轻代与老年代都没问题，有可能是元数据区加载东西太多了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
            <tag> 垃圾收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM一-内存结构</title>
      <link href="/2023/11/16/jvm-yi-nei-cun-jie-gou/"/>
      <url>/2023/11/16/jvm-yi-nei-cun-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>对于 Java 程序而言，在虚拟机自动内存管理机制下，不再需要像 C/C++ 那样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出的问题。正是因为 Java 程序把内存控制权力交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>JDK 1.8 ：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210161135.png"></p><p>线程私有的：程序计数器、虚拟机栈、本地方法栈</p><p>线程共享的：堆、方法区、直接内存</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>综上，程序计数器有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</p><p>Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。局部变量表主要存放了编译期可知的各种数据类型、对象引用</p><p>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p><ul><li><code>StackOverFlowError</code>：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出该错误。</li><li><code>OutOfMemoryError</code>： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出该错误</li></ul><blockquote><p>方法/函数如何调用？<br>Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>Java 方法有两种返回方式：return 语句、抛出异常</p></blockquote><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</p><blockquote><p>本地方法：一个native method就是一个Java调用非Java代码的接口。本地方法是这样的一种方法：该方法的实现由非Java语言实现的，比如C。</p></blockquote><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）。</strong> 从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代。在之前的版本中，堆内存被划分为以下的三个部分：新生代、老生代和永生代。JDK 1.8 之后，永生代被移除了，取而代之的是元空间，元空间使用的是直接内存。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220211104844.png"></p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><blockquote><p>方法区和永久代的关系：方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。也就是说，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是 HotSpot 的一种实现。</p></blockquote><h3 id="为什么放弃永久代？"><a href="#为什么放弃永久代？" class="headerlink" title="为什么放弃永久代？"></a>为什么放弃永久代？</h3><ol><li>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li><li>元空间里面存放的是类的元数据，数量由系统的实际可用空间来控制，这样能加载的类就更多了。</li></ol><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分，常量池中主要存放有两大类常量：字面量和符号引用。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。符号引用顾名思义，就是引用；</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</p><h1 id="HotSpot-虚拟机对象"><a href="#HotSpot-虚拟机对象" class="headerlink" title="HotSpot 虚拟机对象"></a>HotSpot 虚拟机对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220211110709.png"></p><h3 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h3><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式有 “指针碰撞” 和 “空闲列表” 两种</strong>。选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220211111630.png"></p><p><strong>内存分配并发问题：</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li>CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li><li>TLAB：为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。</li></ul><h3 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象头中。</p><h3 id="执行-init-方法"><a href="#执行-init-方法" class="headerlink" title="执行 init 方法"></a>执行 init 方法</h3><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。</p><p>Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（例如哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</p><p>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>对象的访问方式由虚拟机实现而定，目前主流的访问方式有 ① 使用句柄和 ② 直接指针两种。</p><blockquote><p>句柄：一个数字，一般和当前系统下的整数的位数一样，比如32bit系统下就是4个字节。该数字是一个对象的唯一标示，和对象一一对应。</p></blockquote><h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220211113850.png"></p><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220211113909.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识三</title>
      <link href="/2023/11/16/java-ji-chu-zhi-shi-san/"/>
      <url>/2023/11/16/java-ji-chu-zhi-shi-san/</url>
      
        <content type="html"><![CDATA[<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>类的加载过程包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>共五个阶段，加载完成之后还有使用和卸载两个阶段。在进行类加载的五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，而解析阶段则不一定，该阶段在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220131111329.png"></p><h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><p>这是类加载过程的第一个阶段，在该阶段，JVM 需要查找并加载类的二进制数据，主要需要完成以下三件事情:</p><ul><li>通过全类名获取定义此类的二进制字节流（将 class 文件加载到内存）</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。（将静态数据结构转化成方法区中运行时的数据结构）</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li></ul><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220131113438.png"></p><p>相对于类加载的其他阶段而言，加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的 二进制字节流 就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><blockquote><p>加载.class文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul></blockquote><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><h2 id="验证：确保被加载的类的正确性"><a href="#验证：确保被加载的类的正确性" class="headerlink" title="验证：确保被加载的类的正确性"></a>验证：确保被加载的类的正确性</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><blockquote><p>确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查。</p></blockquote><p>验证阶段大致会完成4个阶段的检验动作:</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范；</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的；</li><li>符号引用验证：确保解析动作能正确执行。</li></ul><blockquote><p>验证阶段是非常重要的，但不是必需的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p></blockquote><h2 id="准备：为类的静态变量分配内存，并将其初始化为默认值"><a href="#准备：为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="准备：为类的静态变量分配内存，并将其初始化为默认值"></a>准备：为类的静态变量分配内存，并将其初始化为默认值</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。需要注意以下几点：</p><ul><li>这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中；</li><li>这里所设置的初始值通常情况下是数据类型默认的零值(如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在Java代码中被显式地赋予的值。</li></ul><p>假设一个类变量的定义为: <code>public static int value = 3；</code>那么变量value在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何Java方法，而把value赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p><h2 id="解析：把类中的符号引用转换为直接引用"><a href="#解析：把类中的符号引用转换为直接引用" class="headerlink" title="解析：把类中的符号引用转换为直接引用"></a>解析：把类中的符号引用转换为直接引用</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点限定符</code>7类符号引用进行。</p><p>符号引用是指一组符号来描述目标，可以是任何字面量，例如<code>import java.util.ArrayList</code>；直接引用是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄，引用对象一定在内存进行。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><blockquote><p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 s<code>tatic int value</code> 由默认初始化的0变成了显式初始化的3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p></blockquote><blockquote><p>字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，这些方法都是字节码文件中只能给JVM识别的特殊方法。</p></blockquote><h2 id="初始化步骤"><a href="#初始化步骤" class="headerlink" title="初始化步骤"></a>初始化步骤</h2><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类；</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类；</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><p>只有当对类的主动使用的时候才会导致类的初始化，主动使用包括以下六种：</p><ul><li>创建类的实例，也就是new的方式 </li><li>访问某个类或接口的静态变量，或者对该静态变量赋值 </li><li>调用类的静态方法 </li><li>反射(如Class.forName(“com.pdai.jvm.Test”)) </li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>类访问方法区内的数据结构的接口， 对象是Heap区的数据。</p><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>GC将无用对象从内存中卸载</p><p>结束生命周期的几种情况：</p><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h1 id="类加载器的加载顺序（层次）"><a href="#类加载器的加载顺序（层次）" class="headerlink" title="类加载器的加载顺序（层次）"></a>类加载器的加载顺序（层次）</h1><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220206154019.png"></p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220206154839.png"></p><h1 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h1><ul><li><p>全盘负责：</p><p>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p></li><li><p>父类委托：</p><p>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p></li><li><p>缓存机制：</p><p>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p></li><li><p>双亲委派机制</p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></li></ul><h2 id="双亲委派机制的过程"><a href="#双亲委派机制的过程" class="headerlink" title="双亲委派机制的过程"></a>双亲委派机制的过程</h2><ol><li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>如果BootStrapClassLoader加载失败(例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该class)，会使用ExtClassLoader来尝试加载；</li><li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li></ol><h2 id="双亲委派的优势"><a href="#双亲委派的优势" class="headerlink" title="双亲委派的优势"></a>双亲委派的优势</h2><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证Java程序安全稳定运行</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识二</title>
      <link href="/2023/11/16/java-ji-chu-zhi-shi-er/"/>
      <url>/2023/11/16/java-ji-chu-zhi-shi-er/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-集合概述"><a href="#Java-集合概述" class="headerlink" title="Java 集合概述"></a>Java 集合概述</h1><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code> 接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于 <code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220207220515.png"></p><h2 id="List-Set-Queue-Map-四者的区别"><a href="#List-Set-Queue-Map-四者的区别" class="headerlink" title="List, Set, Queue, Map 四者的区别"></a>List, Set, Queue, Map 四者的区别</h2><ul><li>List：存储的元素是有序的、可重复的。</li><li>Set：存储的元素是无序的、不可重复的。</li><li>Queue：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li>Map：使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h2 id="底层数据结构总结"><a href="#底层数据结构总结" class="headerlink" title="底层数据结构总结"></a>底层数据结构总结</h2><p>List</p><ul><li>ArrayList：<code>object[]</code> 数组</li><li>Vector：<code>object[]</code> 数组</li><li>LinkedList：双向链表</li></ul><p>Set</p><ul><li>HashSet：无序、唯一，基于 <code>HashMap</code> 实现，底层采用 <code>HashMap</code> 保存元素</li><li>LinkedHashSet：是 <code>HashSet</code>的子类，并且内部是通过 <code>LinkedHashMap</code> 实现的</li><li>TreeSet：有序、唯一、自平衡的排序二叉树 (红黑树)</li></ul><p>Queue</p><ul><li>PriorityQueue：<code>object[]</code> 数组实现二叉堆</li><li>ArrayQueue：<code>object[]</code> 数组+双指针</li></ul><p>Map</p><ul><li>HashMap：JDK1.8之前，<code>HashMap</code> 由数组 + 链表组成，数组是主体，链表则是为了解决哈希冲突存在的（拉链法解决冲突）。JDK1.8之后，解决哈希冲突有了较大的变化，链表长度大于阈值时（默认为8），将链表转换为红黑树，以减少搜索时间。</li><li>LinkedHashMap：继承自<code>HashMap</code>，底层也由数组和链表或红黑树组成，并在此基础上增加了一条双向链表，使得该结构能够保持键值对的插入顺序。同时通过对链表进行相应操作，实现了访问顺序的相关逻辑。</li><li>Hashtable：数组 + 链表组成，数组为主体，链表主要为了防止哈希冲突。</li><li>TreeMap：红黑树</li></ul><h2 id="如何选用集合？"><a href="#如何选用集合？" class="headerlink" title="如何选用集合？"></a>如何选用集合？</h2><ul><li>ArrayList：动态数组，与普通数组的区别就是它是没有固定大小的限制，可以添加或删除元素。</li><li>LinkedList：链表，增加和删除的操作效率更高，而查找和修改的操作效率较低。其实现了 Queue、Deque 接口，能够作为队列使用，还实现了List 接口，可进行列表的相关操作。</li><li>Vector：线程安全的 ArrayList</li><li>HashSet：实现了 Set 接口，是一个不允许有重复元素的集合。</li><li>LinkedHashSet：有序的 HashSet，使用链表维护元素的次序。当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</li><li>TreeSet：SortedSet 接口的唯一实现类，可以确保集合元素处于排序状态。</li><li>PriorityQueue：优先级队列，它的出队顺序与元素的优先级有关，对 PriorityQueue 调用 remove() 或 poll() 方法，返回的总是优先级最高的元素。</li><li>ArrayQueue：循环队列</li><li>HashMap：普通的哈希表，是无序的</li><li>LinkedHashMap：有序的 HashMap，通过维护一个运行于所有条目的双向链表，LinkedHashMap 保证了元素迭代的顺序。</li><li>Hashtable：线程安全的 HashMap，一次仅允许一个线程对其进行更改。</li><li>TreeMap：能够将内部元素按照键值进行排序，默认为升序。而 LinkedHashMap 则仅仅是记录了插入的顺序。</li></ul><h1 id="Collection-子接口之-List"><a href="#Collection-子接口之-List" class="headerlink" title="Collection 子接口之 List"></a>Collection 子接口之 List</h1><h2 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别"></a>Arraylist 和 Vector 的区别</h2><ul><li>ArrayList 是 List 的主要实现类，底层使用 Object[] 存储，适用于频繁的查找工作，线程不安全；</li><li>Vector 是 List 的古老实现类，底层使用Object[] 存储，线程安全。</li></ul><h2 id="Arraylist-与-LinkedList-的区别"><a href="#Arraylist-与-LinkedList-的区别" class="headerlink" title="Arraylist 与 LinkedList 的区别"></a>Arraylist 与 LinkedList 的区别</h2><ul><li>ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li><li>Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构</li><li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响；LinkedList 采用链表存储，所以如果是在头尾插入或者删除元素不受元素位置的影响</li><li>LinkedList 不支持高效的随机元素访问，而 ArrayList 支持</li><li>ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）</li></ul><h2 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h2><p>在JDK1.8中，如果通过无参构造的话，初始数组容量为0，当真正对数组进行添加时（即添加第一个元素时），才真正分配容量，默认分配容量为10；当容量不足时（容量为size，添加第size+1个元素时），先判断按照1.5倍（位运算）的比例扩容能否满足最低容量要求，若能，则以1.5倍扩容，否则以最低容量要求进行扩容。</p><p>执行add(E e)方法时，先判断ArrayList当前容量是否满足size+1的容量；</p><p>在判断是否满足size+1的容量时，先判断ArrayList是否为空，若为空，则先初始化ArrayList初始容量为10，再判断初始容量是否满足最低容量要求；若不为空，则直接判断当前容量是否满足最低容量要求；</p><p>若满足最低容量要求，则直接添加；若不满足，则先扩容，再添加。</p><h1 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h1><h2 id="无序性和不可重复性的含义"><a href="#无序性和不可重复性的含义" class="headerlink" title="无序性和不可重复性的含义"></a>无序性和不可重复性的含义</h2><ul><li>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>不可重复性是指添加的元素按照 equals() 判断时 ，返回 false，需要同时重写 equals() 方法和 HashCode() 方法。</li></ul><h2 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul><li>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。</li></ul><h1 id="Collection-子接口之-Queue"><a href="#Collection-子接口之-Queue" class="headerlink" title="Collection 子接口之 Queue"></a>Collection 子接口之 Queue</h1><h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><p>Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。 </p><p>Queue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220208111612.png"></p><p>Deque 是双端队列，在队列的两端均可以插入或删除元素。</p><p>Deque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220208111633.png"></p><h2 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h2><p>ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能，两者的主要区别为：</p><ul><li>ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。</li><li>ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。</li><li>ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈。</p><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><ul><li>利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li>通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li>是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。</li><li>默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。</li></ul><h1 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h1><h2 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h2><p>HashSet 底层就是基于 HashMap 实现的。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220208113020.png"></p><h2 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h2><p>TreeMap 和HashMap 都继承自AbstractMap ，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。</p><p>实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。</p><p>实现SortedMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p><p><strong>相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p><h2 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h2><p>当把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置（通过 hashCode 直接计算出存储的位置），同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。</p><p>如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</p><h3 id="hashcode-与-equals-的相关规定"><a href="#hashcode-与-equals-的相关规定" class="headerlink" title="hashcode 与 equals() 的相关规定"></a>hashcode 与 equals() 的相关规定</h3><ul><li>如果两个对象相等，那么 hashcode 一定相同</li><li>两个对象相等，则 equals() 方法一定返回 true</li><li>hashcode 相同，两个对象不一定相等<blockquote><p>这是因为 hashcode 是用算法计算出来的</p></blockquote></li><li>equals() 方法被覆盖过，则 hashCode() 方法也必须被覆盖</li></ul><h3 id="与-equals-的区别"><a href="#与-equals-的区别" class="headerlink" title="== 与 equals 的区别"></a>== 与 equals 的区别</h3><p>最大的区别：一个是运算符一个是方法</p><p>==：对于基本类型，比较的是值是否相同；对于引用类型，比较的是引用是否相同</p><p>例如：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210104615.png"></p><p><strong>解读：</strong> 因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p><p>equals 本质上就是 == ，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。</p><p>例如：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210104840.png"></p><p>最后结果仍然返回 false，说明其和 == 相同，都是比较了引用是否相同。</p><p>但是对于 String 类型，则有：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210105423.png"></p><p>这是因为如 String、Integer、Data 等类型重写了 equals 方法，把它变成了值比较</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>底层实现是 <strong>数组+链表+红黑树</strong> 的形式的，同时它的数组的<strong>默认初始容量是16</strong>、<strong>扩容因子为0.75</strong>，<strong>每次采用2倍的扩容</strong>。</p><blockquote><p>也就是说，每当我们数组中的存储容量达到75%的时候，就需要对数组容量进行2倍的扩容。</p></blockquote><h3 id="HashMap-的-put-过程"><a href="#HashMap-的-put-过程" class="headerlink" title="HashMap 的 put 过程"></a>HashMap 的 put 过程</h3><p>在 HashMap 中，使用数组+链表的实现方式来存储键值对，在 HashMap 的上层使用数组的形式对“相同”的 key 进行存储，下层对相应的 key 和 value 使用链表的形式进行链接和存储。</p><p>HashMap 把将要存储的值按照 key 计算其对应的数组下标。如果对应的数组下标的位置上是没有元素的，那么就将存储的元素存放上去，但是如果该位置上已经存在元素了，那么这就需要用到我们上面所说的链表存储了，将数据按照链表的存储顺序依次向下存储就可以了。这就是put的简单过程，存储结果如下：</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210112530.png"></p><p>但是我们有时候存储的数据会很多，那么如果一直使用链表的形式进行数据的存储的话就或造成我们的链表的长度非常大，这样无论在进行删除还是在进行插入操作都是十分麻烦的，因此对于这种情况应该怎么办呢？</p><p>这里就涉及到了一个链表中数据存储时，进行 <strong>“树化”和“链化”</strong> 的一个过程，那么什么是“树化”和“链化”呢？</p><p>当我们在对键值对进行存储的时候，如果我们在同一个数组下标下存储的数据过多的话，就会造成我们的链表长度过长，导致进行删除和插入操作比较麻烦，所以在java中规定，<strong>当链表长度大于8时，我们会对链表进行“树化”操作</strong>，将其转换成一颗红黑树。这样我们在对元素进行查找时，就类似于进行二分查找了，这样的查找效率就会大大增加。</p><blockquote><p>红黑树：一种二叉树，左边节点的值小于根节点，右边节点的值大于根节点</p></blockquote><p>但是当我们进行删除操作，将其中的某些节点删除了之后，链表的长度不再大于8了，此时并不是立刻把红黑树退化为链表，而是<strong>只有当链表的长度小于6</strong>的时候才会重新进行链化。</p><blockquote><p>反复的进行“链化”和“树化”操作特别的消耗时间，而且也比较麻烦。所以程序就规定，只有当当链表长度大于等于8的时候才进行“树化”，而长度小于6的时候才进行“链化”。</p></blockquote><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210114851.png"></p><h3 id="链表中是按照怎样的顺序存放数据的"><a href="#链表中是按照怎样的顺序存放数据的" class="headerlink" title="链表中是按照怎样的顺序存放数据的"></a>链表中是按照怎样的顺序存放数据的</h3><p>对于HashMap中链表元素的存储，<strong>在JDK1.7及之前前是在头结点插入的，在JDK1.8之后是在尾节点插入的。</strong></p><h3 id="按照-key-计算其对应的数组下标-（即-hash-key-方法）"><a href="#按照-key-计算其对应的数组下标-（即-hash-key-方法）" class="headerlink" title="按照 key 计算其对应的数组下标 （即 hash(key) 方法）"></a>按照 key 计算其对应的数组下标 （即 hash(key) 方法）</h3><p>HashMap的初始容量是16位，那么对于初始的16个数据位，如果将数据按照key的值进行计算存储，一般最简单的方法就是根据key值获取到一个int值。通常是先利用 hashCode() 方法获得一个 hashcode，再将该 hashcode 与 16 进行取余运算。这样所得的结果永远在 0-15 范围内。</p><p>但是为了使得计算结果尽可能离散，现在计算数组下标最常用的方法是：</p><p>先根据 key 的值计算到一个 hashCode ，将 hashCode 的高16位二进制和低16位二进制进行异或运算，得到的结果再与当前数组长度减一进行与运算，最终得到一个数组下标。</p><blockquote><p>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作</p></blockquote><p><strong>JDK1.8时，计算hash(key)进行了两次扰动</strong></p><h3 id="为什么HashMap的容量一直是2的幂"><a href="#为什么HashMap的容量一直是2的幂" class="headerlink" title="为什么HashMap的容量一直是2的幂"></a>为什么HashMap的容量一直是2的幂</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。只有参与hash(key)的算法的（n-1）的值尽可能都是1的时候，得到的值才是离散的。所以只有当数组的容量长度是2的倍数的时候，计算得到的hash(key)的值才有可能是相对离散的。</p><h3 id="Hash冲突如何解决"><a href="#Hash冲突如何解决" class="headerlink" title="Hash冲突如何解决"></a>Hash冲突如何解决</h3><p>Hash 冲突，即当我计算到某一个数组下标的时候，该下标上已经存放元素了，这就叫 Hash 冲突。很显然，如果计算数组下标的算法不够优秀的时候，很容易将存储的数据积累到同一个下标上面，造成过多的Hash冲突。</p><p>因此，解决哈希冲突的本质就是让存储的key计算得到的数组下标尽可能的离散，也就是尽可能优化 hash(key)</p><h3 id="HashMap-是如何扩容的"><a href="#HashMap-是如何扩容的" class="headerlink" title="HashMap 是如何扩容的"></a>HashMap 是如何扩容的</h3><p><strong>扩容因子：</strong> 在HashMap中“扩容因子”的大小是0.75，对于初始长度为16的数组，当其中存储的数据长度等于16*0.75=12时。就会对数组元素进行扩容，扩容量是原来数组容量的2倍。</p><blockquote><p>扩容因子 0.75 是出于空间换时间的考虑，扩容因子越大，put 一个数据发生碰撞的概率就越大，因此 0.75 的一个合适的范围</p></blockquote><h3 id="扩容后元素怎么存放的"><a href="#扩容后元素怎么存放的" class="headerlink" title="扩容后元素怎么存放的"></a>扩容后元素怎么存放的</h3><p>在HashMap的数组扩容之后，原先HashMap数组中存放的数据元素会进行重新的位置分配，重新将元素在新数组中进行存储。以充分利用数组空间。</p><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220210153243.png"></p><p>在JDK1.8之后，扩容后的元素存放就是对原来的数据下标进行了两次for循环。计算出新下标位置只能是在原下标位置或者在原下标位置加上原容量位置。</p><h2 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h2><p>区别主要体现在实现线程安全的方式上不同</p><ul><li>底层数据结构：<code>ConcurrentHashMap</code> JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。Hashtable 采用数组 + 链表的数据结构，</li><li>实现线程安全的方式：<code>ConcurrentHashMap</code> 在 JDK1.8 中直接用 Node 数组+链表+红黑树 的数据结构来实现线程安全（Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode），并发控制使用 synchronized 和 CAS 来操作。整个看起来就像是优化过且线程安全的 HashMap；<code>Hashtable</code>使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><h1 id="Collection-工具类"><a href="#Collection-工具类" class="headerlink" title="Collection 工具类"></a>Collection 工具类</h1><p>常用方法包括：排序、查找/替换、同步控制</p><h1 id="解决哈希冲突的方式"><a href="#解决哈希冲突的方式" class="headerlink" title="解决哈希冲突的方式"></a>解决哈希冲突的方式</h1><p>开放定址、链地址、再哈希、建立公共溢出区</p><h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p>从发生冲突的单元起，按照一定的次序，在哈希表中找到空闲的单元，然后将发生冲突的元素放入该单元。</p><p>主要有三种探查方式：线性探查、平方探查、双散列函数探查</p><p>缺点在于删除元素时不能真的删除（因为发生哈希冲突的后续元素与该元素有关），只能打上一个特殊标记。</p><h3 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h3><p>最简单，从发生冲突的单元起依次判断下一个元素是否为空，若到达队尾则回到队首继续判断</p><h3 id="平方探查"><a href="#平方探查" class="headerlink" title="平方探查"></a>平方探查</h3><p>用发生冲突的单元加上 1的平方、2的平方等，直到找到空闲</p><h3 id="双散列函数"><a href="#双散列函数" class="headerlink" title="双散列函数"></a>双散列函数</h3><p>通过另一散列函数来生成探查步长值</p><h2 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h2><p>同时构造多个不同的哈希函数，当一个哈希函数产生冲突时，用另一个哈希函数计算，缺点在于增加了计算时间</p><h2 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h2><p>当发生哈希冲突时，将所有冲突数据统一放入溢出区</p><h1 id="ConcurrentHashMap是如何保证线程安全的"><a href="#ConcurrentHashMap是如何保证线程安全的" class="headerlink" title="ConcurrentHashMap是如何保证线程安全的"></a>ConcurrentHashMap是如何保证线程安全的</h1><h2 id="ConcurrentHashMap-1-7"><a href="#ConcurrentHashMap-1-7" class="headerlink" title="ConcurrentHashMap 1.7"></a>ConcurrentHashMap 1.7</h2><p>在 Java 1.7 中，ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦初始化就不能改变，默认 Segment 的个数是 16 个，也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><ol><li><p>计算要 put 的 key 的位置，获取指定位置的 segment</p></li><li><p>如果指定位置 segment 为空，则初始化这个 segment</p><p>初始化流程：</p><ol><li>检查计算得到的位置的 Segment 是否为null.</li><li>为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。</li><li>再次检查计算得到的指定位置的 Segment 是否为null.</li><li>使用创建的 HashEntry 数组初始化这个 Segment.</li><li>自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.</li></ol></li><li><p>segment.put 插入 key，value 值</p></li></ol><p>由于Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。</p><ol><li>tryLock() 获取锁，获取不到使用 scanAndLockForPut 方法继续获取。</li><li>计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。</li><li>如果 HashEntry 不存在，则判断是否需要扩容，然后头插法直接插入</li><li>如果 HashEntry 存在，则判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值，不一致则说明发生哈希冲突，需要挂载到链表上</li></ol><h3 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容 rehash"></a>扩容 rehash</h3><p>ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表头插法插入到指定位置。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><ol><li>计算得到 key 的存放位置</li><li>遍历指定位置查找相同 key 的 value 值</li></ol><h2 id="ConcurrentHashMap-1-8"><a href="#ConcurrentHashMap-1-8" class="headerlink" title="ConcurrentHashMap 1.8"></a>ConcurrentHashMap 1.8</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。其抛弃了原有的 segment 分段锁实现，而是采用了 CAS + synchronized 来保证并发的安全性</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>保证线程安全的措施主要有三个：</p><ol><li>使用 volatile 保证当前 Node 中的值变化对于其他线程来说是可见的</li><li>使用 table 数组的头结点作为 synchronized 的锁来保证写操作的安全</li><li>当头结点为 null 时，使用 CAS 操作来保证数据的正确写入</li></ol><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><ol><li>判断 key、value 是否为空，若为空则抛出异常</li><li>判断容器数组是否为空，若为空则进行初始化</li><li>判断要插入的元素是否是第一次插入，若是则通过 CAS 插入</li><li>判断是否有其他线程正在扩容，若有则一起进行扩容操作</li><li>若发生哈希冲突，将新的 Node 节点按照链表或红黑树的方式插入合适位置</li><li>判断是否需要树化，即链表数量是否超过 8 个</li><li>插入完成之后，进行扩容判断</li></ol><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>不涉及并发操作，直接查询</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>与 put 类似</p><ol><li>循环遍历数组，接着校验参数</li><li>判断是否有别的线程正在扩容，如果是则一起扩容</li><li>用 synchronized 同步锁，保证并发时元素的移除安全</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 集合 </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识一</title>
      <link href="/2023/11/16/java-ji-chu-zhi-shi-yi/"/>
      <url>/2023/11/16/java-ji-chu-zhi-shi-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h2><p>Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p><p>Java 程序从源代码到运行过程：<br><img src="https://s2.loli.net/2021/12/09/wZPW9xvfyqXrL6H.png" alt="1"></p><p>在 <strong>.class -&gt; 字节码</strong> 这一步，JVM 类加载器首先加载字节码文件，之后通过解释器解释执行，执行速度慢。同时由于有些方法和代码块是经常需要被调用的，因此引入了 <strong>JIT</strong> 编译器，属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><h2 id="Java-与-C-的区别？"><a href="#Java-与-C-的区别？" class="headerlink" title="Java 与 C++ 的区别？"></a>Java 与 C++ 的区别？</h2><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h2 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h2><ul><li><p>生命周期</p><p>  静态方法（Static Method）与静态成员变量一样，属于类本身，在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到JVM关闭。</p><p>  非静态方法（Non-Static Method）又叫实例化方法，属于实例对象，实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。 </p></li><li><p>调用方式</p><p>  外部调用静态方法，可用 <strong>类名.方法名</strong> 的方式，也可用 <strong>对象.方法名</strong> 的方式，实例方法则只能用后者。</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>      <span class="hljs-comment">//......</span><br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staicMethod</span><span class="hljs-params">()</span>{<br>      <span class="hljs-comment">//......</span><br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-comment">// 调用实例方法</span><br>        person.method();<br>        <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> {<br>      <span class="hljs-comment">//......</span><br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staicMethod</span><span class="hljs-params">()</span>{<br>      <span class="hljs-comment">//......</span><br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-comment">// 调用实例方法</span><br>        person.method();<br>        <span class="hljs-comment">// 调用静态方法</span><br>        Person.staicMethod()<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><p>访问类成员是否存在限制</p><p>  静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p></li><li><p>总结</p><p>如果静态方法在系统中定义太多，会占用大量的资源，最后造成内存溢出，所以静态方法不能滥用。如果从线程安全、性能、兼容性上来看，选用实例化方法为宜。</p></li></ul><h2 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h2><ul><li>静态方法是属于类的，在类加载时会分配内存，可以通过类名直接访问。非静态成员属于实例对象，只有对象实例化之后才能存在，需要通过类的实例对象去访问。</li><li>类的非静态成员不存在时，静态成员就已经存在了，此时调用不存在的静态成员，属于非法操作<br>·</li></ul><h2 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h2><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p><img src="https://s2.loli.net/2021/12/09/yvjJ2NuVDZp6L3m.png" alt="2"></p><p>综上：<strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ul><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ul><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><p><img src="https://s2.loli.net/2021/12/09/r1wLcCBjFGvYfu5.png" alt="3"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Java 泛型（generics） 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><h3 id="什么是类型擦除？"><a href="#什么是类型擦除？" class="headerlink" title="什么是类型擦除？"></a>什么是类型擦除？</h3><p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除。</p><p>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。</p><p><strong>例子：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java">List&lt;String&gt; l1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>List&lt;Integer&gt; l2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_"><code class="language-hljs java">List&lt;String&gt; l1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>List&lt;Integer&gt; l2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span><Integer>();<br><br>System.out.println(l1.getClass() == l2.getClass());<br></code></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-literal"><code class="language-hljs java"><span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><p>这因为 <strong>List&lt; String &gt;</strong> 和 <strong>List&lt; Integer &gt;</strong> 在 jvm 中的 Class 都是 List.class。</p><p>而类型 String 和类型 Integer 被泛型转译了。</p><h3 id="常用的通配符"><a href="#常用的通配符" class="headerlink" title="常用的通配符"></a>常用的通配符</h3><p>T，E，K，V，？</p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals() 的区别"></a>== 和 equals() 的区别</h2><p>== 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，== 比较的是值。</li><li>对于引用数据类型来说，== 比较的是对象的内存地址。</li></ul><p>equals() 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类。</p><p>equals() 方法存在两种使用情况：</p><ul><li>类没有覆盖 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。</li><li>类覆盖了 equals()方法 ：一般我们都覆盖 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><p>例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// a 为一个引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// b为另一个引用,对象的内容一样</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 放在常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 从常量池中查找</span><br>System.out.println(aa == bb);<span class="hljs-comment">// true</span><br>System.out.println(a == b);<span class="hljs-comment">// false</span><br>System.out.println(a.equals(b));<span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-number">42</span> == <span class="hljs-number">42.0</span>);<span class="hljs-comment"><code class="language-hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// a 为一个引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"ab"</span>); <span class="hljs-comment">// b为另一个引用,对象的内容一样</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 放在常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 从常量池中查找</span><br>System.out.println(aa == bb);<span class="hljs-comment">// true</span><br>System.out.println(a == b);<span class="hljs-comment">// false</span><br>System.out.println(a.equals(b));<span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-number">42</span> == <span class="hljs-number">42.0</span>);<span class="hljs-comment">// true</span><br></code></pre></td></tr></tbody></table></figure><p>String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</p><p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</p><p>String 类中的 equals()方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object anObject)</span> {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == anObject) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">anotherString</span> <span class="hljs-operator">=</span> (String)anObject;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> value.length;<br>        <span class="hljs-keyword">if</span> (n == anotherString.value.length) {<br>            <span class="hljs-type">char</span> v1[] = value;<br>            <span class="hljs-type">char</span> v2[] = anotherString.value;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                i++;<br>            }<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object anObject)</span> {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == anObject) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">anotherString</span> <span class="hljs-operator">=</span> (String)anObject;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> value.length;<br>        <span class="hljs-keyword">if</span> (n == anotherString.value.length) {<br>            <span class="hljs-type">char</span> v1[] = value;<br>            <span class="hljs-type">char</span> v2[] = anotherString.value;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                i++;<br>            }<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h2><p>为什么重写 equals() 时必须重写 hashCode() 方法？</p><h3 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode() 介绍"></a>hashCode() 介绍</h3><p>hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p><h3 id="为什么要有-hashCode-？"><a href="#为什么要有-hashCode-？" class="headerlink" title="为什么要有 hashCode() ？"></a>为什么要有 hashCode() ？</h3><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等。</p><p>即：如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</p><h3 id="为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？"><a href="#为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？" class="headerlink" title="为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？"></a>为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</h3><p>因为 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode )。</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><img src="https://s2.loli.net/2021/12/09/mvNc95ky3BWH8Xe.png"></p><p><strong>注意</strong></p><ul><li>Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析。</li><li>这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean。</li><li>基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><h3 id="包装类型的常量池技术"><a href="#包装类型的常量池技术" class="headerlink" title="包装类型的常量池技术"></a>包装类型的常量池技术</h3><p>Java 基本类型的包装类的大部分都实现了常量池技术。</p><p><img src="https://s2.loli.net/2021/12/09/fU2Gvy4t5qxHPeT.png"></p><p>例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number"><code class="language-hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">40</span>);<br>System.out.println(i1==i2);<br></code></pre></td></tr></tbody></table></figure><p>Integer i1=40 这一行代码会发生装箱，也就是说这行代码等价于 Integer i1=Integer.valueOf(40) 。因此，i1 直接使用的是常量池中的对象。而Integer i1 = new Integer(40) 会直接创建新的对象。</p><p>因此输出结果为 false</p><h3 id="自动装拆箱"><a href="#自动装拆箱" class="headerlink" title="自动装拆箱"></a>自动装拆箱</h3><ul><li><strong>装箱：</strong> 将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱：</strong> 将包装类型转换为基本数据类型；</li></ul><p>举例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱</span><br></code></pre></td></tr></tbody></table></figure><ul><li>Integer i = 10 等价于 Integer i = Integer.valueOf(10)</li><li>int n = i 等价于 int n = i.intValue()</li></ul><h2 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h2><h3 id="成员变量、局部变量和静态变量"><a href="#成员变量、局部变量和静态变量" class="headerlink" title="成员变量、局部变量和静态变量"></a>成员变量、局部变量和静态变量</h3><ul><li>从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；</li><li>从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。</li><li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><p>三者的对比图如下：</p><p><img src="https://s2.loli.net/2021/12/09/KlpcAYfnBSuhbWU.png"></p><h3 id="对象实体和对象引用"><a href="#对象实体和对象引用" class="headerlink" title="对象实体和对象引用"></a>对象实体和对象引用</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">Vehicle</span> <span class="hljs-variable">veh1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <br><span class="hljs-comment">//拆分</span><br>Vehicle veh1; <span class="hljs-comment">//对象引用变量</span><br>veh1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <span class="hljs-comment"><code class="language-hljs java"><span class="hljs-type">Vehicle</span> <span class="hljs-variable">veh1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <br><span class="hljs-comment">//拆分</span><br>Vehicle veh1; <span class="hljs-comment">//对象引用变量</span><br>veh1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <span class="hljs-comment">//对象实体</span><br></code></pre></td></tr></tbody></table></figure><p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>特点：</strong></p><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><p><strong>作用：</strong></p><p>构造方法主要作用是完成对类对象的初始化工作</p><p><strong>若一个类没有声明构造方法，该程序能正确执行吗?</strong></p><p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h3 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h3><p>多态的特点：</p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系； </li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定； </li><li>多态不能调用“只在子类存在但在父类不存在”的方法； </li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h3 id="StringBuffer-和-StringBuilder"><a href="#StringBuffer-和-StringBuilder" class="headerlink" title="StringBuffer 和 StringBuilder"></a>StringBuffer 和 StringBuilder</h3><p><strong>可变性</strong></p><p>String 是不可变的</p><p><strong>线程安全性</strong></p><p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<br>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="深拷贝、浅拷贝和引用拷贝"><a href="#深拷贝、浅拷贝和引用拷贝" class="headerlink" title="深拷贝、浅拷贝和引用拷贝"></a>深拷贝、浅拷贝和引用拷贝</h3><p>拷贝分为两大类：引用拷贝和对象拷贝，深拷贝和浅拷贝属于对象拷贝</p><ul><li><p>引用拷贝</p><p>对引用地址的拷贝，说明引用地址一样，指向堆中的对象也是同一个对象。如果对一个对象进行改变，其他对象也会跟着改变。</p></li><li><p>对象拷贝</p><p>指 对某一对象进行拷贝，是创建了一个全新的对象，也就是内存中存在二个不同地址的对象，这二个对象的基本数据类型变量的内容值都是一样的，但<font color="red">所包含的对象变量的地址可能一样可能不一样</font>，浅拷贝与深拷贝的区别就在这里。</p></li></ul><p>浅拷贝：</p><p>当前对象里包含有对象变量，如果<font color="red">复制的对象中的对象变量和原对象里的对象地址值是相同的</font>，即引用拷贝，则称之为浅拷贝。我们也可以称之为部分拷贝，即拷贝的不彻底。</p><p>深拷贝：</p><p>当前对象里包含有对象变量，如果复制的对象中的对象变量和原对象里的对象地址值是不同的，即<font color="red">创建了一个新的对象</font>，则称之为深拷贝。我们也可以称之为完全拷贝，内部进行了彻底拷贝。</p><p>引用拷贝例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">"Taylor"</span>,<span class="hljs-number">26</span>);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">otherteacher</span> <span class="hljs-operator"><code class="language-hljs java"><span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">"Taylor"</span>,<span class="hljs-number">26</span>);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">otherteacher</span> <span class="hljs-operator">=</span> teacher;<br>System.out.println(teacher);<br>System.out.println(otherteacher);<br></code></pre></td></tr></tbody></table></figure><p>输出结果：</p><pre><code>blog.Teacher@355da254 blog.Teacher@355da254</code></pre><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p><p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(try-catch)， <code>Error</code> 是无法处理的(只能尽量避免)。</p><ul><li><p><code>Exception</code>：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</p></li><li><p><code>Error</code>：Error 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p></li></ul><p>注：出现Error错误一般不是由于你编写的代码出现问题，而是由于JVM运行你这段代码出现了问题，比如堆溢出，配置文件出错等，这些你是无法人为的在你代码里可以保证的，必须要额外的去操作，重新配置虚拟机，修改配置文件等等。</p><p>异常类层次结构图：</p><p><img src="https://s2.loli.net/2021/12/10/lG6yZWUqdOTXDL5.png"></p><p><img src="https://s2.loli.net/2021/12/10/bLONmCSnFTlsG93.png"></p><h3 id="受检查异常-checked-exceptions"><a href="#受检查异常-checked-exceptions" class="headerlink" title="受检查异常(checked exceptions)"></a>受检查异常(checked exceptions)</h3><p>编译器要求你必须处置的异常。如某段代码，编译器要求必须对这段代码try…catch，或者throws exception。也就是说，代码还未运行，编译器就会检查该代码，会不会出现异常，要求你对可能出现的异常必须做出相应的处理。</p><p>又被称为非运行时异常</p><p><strong>几种处理方式：</strong></p><ul><li>继续抛出，消极的方法，一直抛到 Java 虚拟机处理</li><li>用try…catch捕获</li></ul><p>例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> IOException<br>   {<br>      <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"B:/myfile.txt"</span>); <br>      <span class="hljs-type">int</span> k; <br> <br>      <span class="hljs-keyword">while</span>(( k = fis.read() ) != -<span class="hljs-number">1</span>) <br>      { <br>   System.out.print((<span class="hljs-type"><code class="language-hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> IOException<br>   {<br>      <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"B:/myfile.txt"</span>); <br>      <span class="hljs-type">int</span> k; <br> <br>      <span class="hljs-keyword">while</span>(( k = fis.read() ) != -<span class="hljs-number">1</span>) <br>      { <br>   System.out.print((<span class="hljs-type">char</span>)k); <br>      } <br>      fis.close(); <br>   }<br>}<br></code></pre></td></tr></tbody></table></figure><p>若要给出关于异常的具体信息，可以采用 try…catch ：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span><br>   {<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>{<br>    fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"B:/myfile.txt"</span>); <br>}<span class="hljs-keyword">catch</span>(FileNotFoundException fnfe){<br>            System.out.println(<span class="hljs-string">"The specified file is not "</span> +<br><span class="hljs-string">"present at the given path"</span>);<br> }<br><span class="hljs-type">int</span> k; <br><span class="hljs-keyword">try</span>{<br>    <span class="hljs-keyword">while</span>(( k = fis.read() ) != -<span class="hljs-number">1</span>) <br>    { <br>System.out.print((<span class="hljs-type">char</span>)k); <br>    } <br>    fis.close(); <br>}<span class="hljs-keyword">catch</span>(IOException ioe){<br>    System.out.println(<span class="hljs-string"><code class="language-hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span><br>   {<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>{<br>    fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"B:/myfile.txt"</span>); <br>}<span class="hljs-keyword">catch</span>(FileNotFoundException fnfe){<br>            System.out.println(<span class="hljs-string">"The specified file is not "</span> +<br><span class="hljs-string">"present at the given path"</span>);<br> }<br><span class="hljs-type">int</span> k; <br><span class="hljs-keyword">try</span>{<br>    <span class="hljs-keyword">while</span>(( k = fis.read() ) != -<span class="hljs-number">1</span>) <br>    { <br>System.out.print((<span class="hljs-type">char</span>)k); <br>    } <br>    fis.close(); <br>}<span class="hljs-keyword">catch</span>(IOException ioe){<br>    System.out.println(<span class="hljs-string">"I/O error occurred: "</span>+ioe);<br> }<br>   }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>如何区分？</strong></p><p>除了RuntimeException与其子类，以及错误（Error），其他的都是检查异常（绝对的大家族）。</p><h3 id="不受检查异常-unchecked-exceptions"><a href="#不受检查异常-unchecked-exceptions" class="headerlink" title="不受检查异常(unchecked exceptions)"></a>不受检查异常(unchecked exceptions)</h3><p>编译器不要求强制处置的异常，虽然有可能出错，但不会在编译时检查。</p><p>如NullPointerException，IndexOutOfBoundsException，VirtualMachineError等，又被称为运行时异常</p><p><strong>处理方式：</strong> 捕获、继续抛出、不处理，通常不处理</p><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><ul><li><p><code>try </code>块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 </p></li><li><p><code>catch </code>块： 用于处理 try 捕获到的异常。 </p></li><li><p><code>finally </code>块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行</p></li></ul><p><strong>在以下三种特殊情况下，<code>finally </code>块不会被执行：</strong></p><ul><li><p>在 try 或 finally块中用了 System.exit(int)退出程序。但是，如果 System.exit(int) 在异常语句之后，finally 还是会被执行 </p></li><li><p>程序所在的线程死亡。 </p></li><li><p>关闭 CPU。</p></li></ul><p><strong>注意：</strong><br>当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">return</span> value * value;<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-keyword">if</span> (value == <span class="hljs-number">2</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> {<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">return</span> value * value;<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-keyword">if</span> (value == <span class="hljs-number">2</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h2><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><ul><li>序列化：将数据结构或对象转换成二进制字节流的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><h3 id="Java-序列化中避免部分字段序列化"><a href="#Java-序列化中避免部分字段序列化" class="headerlink" title="Java 序列化中避免部分字段序列化"></a>Java 序列化中避免部分字段序列化</h3><p>对于不想序列化的变量，使用<code>transient</code>修饰</p><p>注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。 </li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。 </li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h3 id="I-O-流分类"><a href="#I-O-流分类" class="headerlink" title="I/O 流分类"></a>I/O 流分类</h3><p>按操作方式分类结构图：</p><p><img src="https://s2.loli.net/2021/12/10/JndGwQpU615z94S.png"></p><p>按操作对象分类结构图：</p><p><img src="https://s2.loli.net/2021/12/10/g4FIGOQBqwlmdbs.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/14/hello-world/"/>
      <url>/2023/11/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash">$ hexo new <span class="hljs-string"><code class="language-hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo server<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo generate<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre class=" language-hljs bash"><code class="language-hljs bash">$ hexo deploy<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
