<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Redis, Java,k8s,istio,linux,net">
    <meta name="description" content="什么是 RedisRedis 就是一个使用 C 语言开发的高性能非关系型的键值对数据库。与传统数据库不同的是 Redis 的数据是存在内存中的 ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。Redis可">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Redis | ArcticUnicorn</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="ArcticUnicorn" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ArcticUnicorn</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/navigate" class="waves-effect waves-light">
      
      <span>导航</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ArcticUnicorn</div>
        <div class="logo-desc">
            
            本网站为个人兴趣爱好,分享经验,记录学习生活点滴的平台,希望在未来的学习生活中,有所积淀。
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/navigate" class="waves-effect waves-light">
			
				<i class="fas fa-fw fa-link"></i>
			
			导航
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Redis</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">
                                <span class="chip bg-color">数据库</span>
                            </a>
                        
                            <a href="/tags/Redis/">
                                <span class="chip bg-color">Redis</span>
                            </a>
                        
                            <a href="/tags/%E7%BC%93%E5%AD%98/">
                                <span class="chip bg-color">缓存</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-category">
                                数据库
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-11-16
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    15.5k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    54 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis"></a>什么是 Redis</h1><p>Redis 就是一个使用 C 语言开发的高性能非关系型的键值对数据库。与传统数据库不同的是 Redis 的数据是存在内存中的 ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。Redis可以将数据写入磁盘中，保证了数据的安全不丢失，而且Redis的操作是原子性的。</p>
<h1 id="Redis-的应用场景"><a href="#Redis-的应用场景" class="headerlink" title="Redis 的应用场景"></a>Redis 的应用场景</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>合理利用缓存来提升网站的访问速度、降低数据库的压力</p>
<h2 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h2><p>有序集合数据结构能够实现复杂的排行榜应用</p>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>如视频播放量、商品浏览量等，如果直接对数据库操作可能无法应对较高的并发量，Redis 可以用 incr 命令来实现计数功能</p>
<h2 id="分布式会话"><a href="#分布式会话" class="headerlink" title="分布式会话"></a>分布式会话</h2><p>可以搭建以 Redis 等内存数据库为中心的 session 服务，session 不再由容器管理，而是由 session 服务及内存数据库管理</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式技术的一个挑战是对同一个资源的并发访问，并发量大的情况下使用数据库锁来控制并发访问是不理想的，大大影响了数据库性能，因此可以采用 Redis 来实现分布式锁</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>Redis 还有发布/订阅以及阻塞队列的功能，可以充当消息队列使用</p>
<h1 id="Redis-的优缺点"><a href="#Redis-的优缺点" class="headerlink" title="Redis 的优缺点"></a>Redis 的优缺点</h1><p><strong>优点：</strong></p>
<ol>
<li>基于内存操作，内存读写速度快。</li>
<li>单线程的，避免线程切换开销及多线程的竞争问题。单线程是指网络请求使用一个线程来处理，即一个线程处理所有网络请求，Redis 运行时不止有一个线程，比如数据持久化的过程会另起线程。</li>
<li>支持多种数据类型，包括String、Hash、List、Set、ZSet等。</li>
<li>支持持久化。Redis支持RDB和AOF两种持久化机制，持久化功能可以有效地避免数据丢失问题。<blockquote>
<p>像 Redis 一样将数据保存在内存中有一个很大的缺陷，就是一旦断电或者宕机，内存数据库中的内容将会全部丢失。为了弥补这一缺陷，Redis提供了把内存数据持久化到硬盘文件，以及通过备份文件来恢复数据的功能，即Redis持久化机制。</p>
</blockquote>
</li>
<li>支持事务。Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li>
<li>支持主从复制。主节点会自动将数据同步到从节点，可以进行读写分离。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>对结构化查询的支持比较差。</li>
<li>数据库容量受到物理内存的限制，不适合用作海量数据的高性能读写</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li>
</ol>
<h1 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h1><ul>
<li>基于内存：Redis是使用内存存储，没有磁盘IO上的开销。数据存在内存中，读写速度快。</li>
<li>单线程实现（ Redis 6.0以前）：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。</li>
<li>IO多路复用模型：Redis 采用 IO 多路复用技术。Redis 使用单线程来轮询描述符，将数据库的操作都转换成了事件，不在网络I/O上浪费过多的时间。</li>
<li>高效的数据结构：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。</li>
</ul>
<h1 id="缓存数据的处理流程是怎样的"><a href="#缓存数据的处理流程是怎样的" class="headerlink" title="缓存数据的处理流程是怎样的"></a>缓存数据的处理流程是怎样的</h1><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220212180228.png"></p>
<ol>
<li>如果用户请求的数据在缓存中就直接返回。</li>
<li>缓存中不存在的话就看数据库中是否存在。</li>
<li>数据库中存在的话就更新缓存中的数据。</li>
<li>数据库中不存在的话就返回空数据。</li>
</ol>
<h1 id="为什么要用-Redis-缓存"><a href="#为什么要用-Redis-缓存" class="headerlink" title="为什么要用 Redis/缓存"></a>为什么要用 Redis/缓存</h1><p>使用缓存主要是为了提升用户体验以及应对更多的用户。</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220212202245.png"></p>
<p>高性能：</p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p>
<p>这样做的好处就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p>
<p>不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p>高并发：</p>
<p>Redis 缓存之后的 QPS 更高，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，进而也就提高了系统整体的并发。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>
</blockquote>
<h1 id="Redis-的数据类型"><a href="#Redis-的数据类型" class="headerlink" title="Redis 的数据类型"></a>Redis 的数据类型</h1><p>Redis 总共有八种数据结构，五种基本数据类型和三种特殊数据类型</p>
<h2 id="五种基本数据类型"><a href="#五种基本数据类型" class="headerlink" title="五种基本数据类型"></a>五种基本数据类型</h2><ul>
<li>String：字符串类型，可用于存储计数器、粉丝数等</li>
<li>hashmap：key - value 形式</li>
<li>list：列表，在 Redis 中可以把 list 用作栈、队列、阻塞队列。</li>
<li>set：集合，可用于记录点赞、收藏等</li>
<li>sorted set：有序集合，有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序，可用于记录排行榜</li>
</ul>
<h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><ul>
<li>geospatial：该功能可以推算出地理位置信息，两地之间的距离。</li>
<li>hyperloglog：数学上集合的元素个数，比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。</li>
<li>bitmap：通过最小的单位 bit 来进行 0 或者 1 的设置，表示某个元素对应的值或者状态。</li>
</ul>
<h1 id="Redis-单线程模型"><a href="#Redis-单线程模型" class="headerlink" title="Redis 单线程模型"></a>Redis 单线程模型</h1><p>Redis 单线程模型指的是执行 Redis 命令的核心模块是单线程的，并不是整个 Redis 实例就一个线程，Redis 其他模块还有各自模块的线程的。</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220213161415.png"></p>
<blockquote>
<p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p>
</blockquote>
<h2 id="单线程怎么监听大量的客户端连接呢？"><a href="#单线程怎么监听大量的客户端连接呢？" class="headerlink" title="单线程怎么监听大量的客户端连接呢？"></a>单线程怎么监听大量的客户端连接呢？</h2><p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
<p>Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：1. 文件事件; 2. 时间事件。其中需要关注的是文件事件，也就是客户端进行读取写入等操作，涉及一系列网络通信。</p>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
<h2 id="为什么网络处理要引入多线程"><a href="#为什么网络处理要引入多线程" class="headerlink" title="为什么网络处理要引入多线程"></a>为什么网络处理要引入多线程</h2><p>Redis 的瓶颈并不在 CPU，而在内存和网络。网络 IO 的读写在 Redis 整个执行期间占用了大部分的 CPU 时间，如果把网络处理这部分做成多线程处理方式，那对整个 Redis 的性能会有很大的提升。</p>
<p>因此，Redis 6.0 在网络 IO 处理方面使用了多线程，如网络数据的读写和协议解析等，需要注意的是，执行命令的核心模块还是单线程的。</p>
<h1 id="Redis-的持久化机制"><a href="#Redis-的持久化机制" class="headerlink" title="Redis 的持久化机制"></a>Redis 的持久化机制</h1><p>有两种持久化机制：AOF 和 RDB</p>
<h2 id="快照持久化（RDB）"><a href="#快照持久化（RDB）" class="headerlink" title="快照持久化（RDB）"></a>快照持久化（RDB）</h2><p>Redis 可以通过创建快照来获得存储在内存中的数据在某个时间点上的副本。也就是在指定的时间间隔内将内存中的数据集快照写入磁盘，恢复时就是将快照文件直接读入内存内。该方法以紧缩的二进制文件保存 Redis 数据库某一时刻所有数据对象的内存快照，可用于 Redis 的数据备份、转移与恢复。</p>
<p>Redis 会单独创建（fork）一个子进程来进行持久化，其基本过程就是将数据写入到一个临时文件当中，待持久化过程结束后再用这个临时文件替换上次持久化后所保存的文件。</p>
<h3 id="RDB-工作原理"><a href="#RDB-工作原理" class="headerlink" title="RDB 工作原理"></a>RDB 工作原理</h3><p>默认情况下，Redis中有16个数据库，编号从0-15，每个Redis数据库使用一个 redisDb 对象来表示，redisDb 使用 hashtable 存储 K-V 对象。</p>
<p>时间点快照也就是某一时刻Redis内每个DB中每个数据对象的状态，<strong>先假设在这一时刻所有的数据对象不再改变</strong>，我们就可以把数据对象依次读取出来并写入到文件中，以此实现Redis的持久化。然后，当Redis重启时按照规则读取这个文件中的内容，再写入到Redis内存即可恢复至持久化时的状态。</p>
<p>然而，这样的持久化备份会导致短时间内Redis服务不可用，这对于高HA的系统来讲是无法容忍的。所以，RDB持久化的主要实践方式就是利用操作系统提供的fork()函数创建的子进程来获得与父进程一致的内存数据，相当于获取了内存数据副本。fork完成后，父进程该干嘛干嘛，持久化状态的工作交给子进程就行了。</p>
<p>由于fork子进程后，父进程数据一直在变化，子进程并不与父进程同步，RDB持久化必然无法保证实时性；RDB持久化完成后发生断电或宕机，会导致部分数据丢失；备份频率决定了丢失数据量的大小，提高备份频率，意味着fork过程消耗较多的CPU资源，也会导致较大的磁盘I/O。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>优势：</strong> </p>
<ul>
<li>适合大规模的数据恢复，因为整个持久化过程中不需要主进程进行操作，而是用新创建的子进程来完成的，因此性能很高；</li>
<li>对于灾难恢复、数据迁移等情况非常友好，因为 RDB 文件可以转移到任何需要的地方并重新加载；</li>
<li>RDB是一个紧凑压缩的二进制文件，代表Redis在某一个时间点上的数据快照，非常适合用于备份、全量复制等场景。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>RDB方式无法做到实时或秒级持久化。因为持久化过程是通过fork子进程后由子进程完成的，子进程的内存只是在fork操作那一时刻父进程的数据快照，而fork操作后父进程持续对外服务，内部数据时刻变更，子进程的数据不再更新，两者始终存在差异，所以无法做到实时性；</li>
<li>RDB持久化过程中的fork操作，会导致内存占用加倍，而且父进程数据越多，fork过程越长；</li>
<li>Redis请求高并发可能会频繁命中save规则，导致fork操作及持久化备份的频率不可控；</li>
<li>RDB文件有文件格式要求，不同版本的Redis会对文件格式进行调整，存在老版本无法兼容新版本的问题。</li>
</ul>
<h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>由于 RDB 无法保证实时性持久化，这对于缓存丢失零容忍的系统来说是个硬伤，于是就有了AOF。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>AOF的持久化对象是Redis内每一个key的状态，持久化的目的是为了在Reids发生故障重启后能够恢复至重启前或故障前的状态。相比于RDB，AOF采取的策略是按照执行顺序持久化每一条能够引起Redis中对象状态变更的命令，命令是有序的、有选择的。把 aof 文件转移至任何一台 Redis Server，从头到尾按序重放这些命令即可恢复如初。</p>
<p>例如：</p>
<p>首先执行指令 <code>set number 0</code>，然后随机调用 <code>incr number</code>、<code>get number</code> 各5次，最后再执行一次<code>get number</code> ，我们得到的结果肯定是5。</p>
<p>因为在这个过程中，能够引起number状态变更的只有set/incr类型的指令，并且它们执行的先后顺序是已知的，无论执行多少次get都不会影响number的状态。所以，保留所有set/incr命令并持久化至aof文件即可。按照aof的设计原理，aof文件中的内容应该是这样的（这里是假设，实际为RESP协议）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs plaintext"><code class="language-hljs plaintext">set number 0<br>incr number<br>incr number<br>incr number<br>incr number<br>incr number<br></code></pre></td></tr></tbody></table></figure>

<p>考虑实际生产环境的复杂性及操作系统等方面的限制，Redis所要考虑的工作要比这个例子复杂的多.</p>
<h3 id="持久化流程"><a href="#持久化流程" class="headerlink" title="持久化流程"></a>持久化流程</h3><p>从流程上来看，AOF的工作原理可以概括为几个步骤：命令追加（append）、文件写入与同步（fsync）、文件重写（rewrite）、重启加载（load）</p>
<p><strong>命令追加</strong></p>
<p>当 AOF 持久化功能处于打开状态时，Redis 在执行完一个写命令之后，会以协议格式 (也就是RESP，即 Redis 客户端和服务器交互的通信协议) 把被执行的写命令追加到 Redis 服务端维护的 AOF 缓冲区末尾。</p>
<p><strong>文件写入与同步</strong></p>
<p>Redis每次事件轮训结束前（beforeSleep）都会调用函数flushAppendOnlyFile，flushAppendOnlyFile会把AOF缓冲区（aof_buf）中的数据写入内核缓冲区，并且根据appendfsync配置来决定采用何种策略把内核缓冲区中的数据写入磁盘，即调用fsync()。</p>
<p><strong>文件重写</strong></p>
<p>Redis长时间运行，命令不断写入AOF，文件会越来越大，不加控制可能影响宿主机的安全。</p>
<p>为了解决AOF文件体积问题，Redis引入了AOF文件重写功能，它会根据Redis内数据对象的最新状态生成新的AOF文件，新旧文件对应的数据状态一致，但是新文件会具有较小的体积。重写既减少了AOF文件对磁盘空间的占用，又可以提高Redis重启时数据恢复的速度。例如上面的例子可以重写为：</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220213165904.png"></p>
<p><strong>数据加载</strong></p>
<p>Redis启动后通过loadDataFromDisk函数执行数据加载工作。这里需要注意，虽然持久化方式可以选择AOF、RDB或者两者兼用，但是数据加载时必须做出选择，两种方式各自加载一遍就乱套了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>优点</strong></p>
<ul>
<li>AOF持久化有更好的实时性</li>
<li>AOF文件只有append操作，无复杂的seek等文件操作，没有损坏风险。</li>
<li>当AOF文件变大时，Redis可在后台自动重写。</li>
<li>AOF文件以易于理解与解析的方式包含了对Redis中数据的所有操作命令。即使不小心错误的清除了所有数据，只要没有对AOF文件重写，我们就可以通过移除最后一条命令找回所有数据。</li>
<li>AOF已经支持混合持久化，文件大小可以有效控制，并提高了数据加载时的效率。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>对于相同的数据集合，AOF文件通常会比RDB文件大；</li>
<li>在特定的fsync策略下，AOF会比RDB略慢；</li>
<li>在AOF上，Redis曾经遇到一些几乎不可能在RDB上遇到的罕见bug</li>
</ul>
<h1 id="Redis-中的数据过期策略"><a href="#Redis-中的数据过期策略" class="headerlink" title="Redis 中的数据过期策略"></a>Redis 中的数据过期策略</h1><h2 id="Redis-给缓存数据设置过期时间有什么用"><a href="#Redis-给缓存数据设置过期时间有什么用" class="headerlink" title="Redis 给缓存数据设置过期时间有什么用"></a>Redis 给缓存数据设置过期时间有什么用</h2><p>首先肯定是因为内存是有限的，如果缓存中的所有数据都是一直保存的话，那么很容易耗尽内存。同时，由于业务场景就是需要某个数据只在某一时间段内存在，例如短信验证码、用户登录的 token 的有效期都是有限的，如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。因此需要采用 redis 来给缓存数据设置过期时间。</p>
<h2 id="Redis-是如何判断数据是否过期的"><a href="#Redis-是如何判断数据是否过期的" class="headerlink" title="Redis 是如何判断数据是否过期的"></a>Redis 是如何判断数据是否过期的</h2><p>Redis 通过过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<h2 id="过期数据的删除策略"><a href="#过期数据的删除策略" class="headerlink" title="过期数据的删除策略"></a>过期数据的删除策略</h2><p>假设设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？常用的过期数据的删除策略有两个：</p>
<ol>
<li><p>惰性删除：<strong>每次从数据库获取key的时候去检查是否过期</strong>，若过期，则删除，返回null。</p>
<p>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步</p>
<p>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p>
</li>
<li><p>定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作。同时，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</p>
<p>优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用；定期删除过期key</p>
<p>缺点：对内存 CPU 不够友好</p>
</li>
</ol>
<h2 id="Redis-内存淘汰机制"><a href="#Redis-内存淘汰机制" class="headerlink" title="Redis 内存淘汰机制"></a>Redis 内存淘汰机制</h2><p>定期删除和惰性删除仍然可能漏掉了很多过期 key，导致大量过期 key 堆积在内存里，引发内存泄漏，因此可以采用内存淘汰机制来解决这一问题。</p>
<p>共有八种内存淘汰策略：</p>
<p><strong>两种 LRU (最近最少被使用) 策略：</strong></p>
<ul>
<li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key</li>
</ul>
<p><strong>两种 LFU （最近最少使用频次）策略：</strong></p>
<ul>
<li>volatile-lfu：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰</li>
<li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ul>
<blockquote>
<p>LRU 与 LFU 的区别：</p>
<p>假设 LFU 的访问时期设定为 10 分钟，有 1、2、3、4 几个页面，访问顺序依次为 2 1 2 1 2 3 4</p>
<p>若此时内存已满，需要对页面进行淘汰，若按LRU算法，应替换掉页面1。因为页面1是最长时间没有被使用的了，页面2和3都在它后面被使用过；若按LFU算法，应替换掉页面3。因为在这段时间内，页面1被访问了2次，页面2被访问了3次，而页面3只被访问了1次，一段时间内被访问的次数最少。</p>
</blockquote>
<p>剩余的四种策略：</p>
<ul>
<li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li>allkeys-random：从数据集中任意选择数据淘汰</li>
<li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ul>
<h1 id="Redis-bigkey"><a href="#Redis-bigkey" class="headerlink" title="Redis bigkey"></a>Redis bigkey</h1><h2 id="什么是-bigkey？"><a href="#什么是-bigkey？" class="headerlink" title="什么是 bigkey？"></a>什么是 bigkey？</h2><p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。</p>
<h2 id="bigkey-有什么危害？"><a href="#bigkey-有什么危害？" class="headerlink" title="bigkey 有什么危害？"></a>bigkey 有什么危害？</h2><ul>
<li>内存空间不均匀：会不利于集群对内存的统一管理，存在丢失数据的隐患。</li>
<li>超时阻塞：由于Redis单线程的特性，操作bigkey的通常比较耗时，也就意味着阻塞Redis可能性越大，这样会造成客户端阻塞或者引起故障切换，它们通常出现在慢查询中。</li>
<li>网络拥塞：bigkey也就意味着每次获取要产生的网络流量较大，而且一般服务器会采用单机多实例的方式来部署，也就是说一个bigkey可能会对其他实例造成影响，其后果不堪设想。</li>
<li>过期删除：对 bigkey 进行删除时会存在阻塞Redis的可能性</li>
<li>迁移困难</li>
</ul>
<h1 id="如何发现-bigkey？"><a href="#如何发现-bigkey？" class="headerlink" title="如何发现 bigkey？"></a>如何发现 bigkey？</h1><ul>
<li><p>使用 Redis 自带的 –bigkeys 参数来查找。</p>
<p>这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构占用内存最大的 bigkey</p>
</li>
<li><p>分析 RDB 文件</p>
</li>
</ul>
<h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h1><p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： 1. 原子性，2. 隔离性，3. 持久性，4. 一致性。</p>
<blockquote>
<p>原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； </p>
<p>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； </p>
<p>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 </p>
<p>一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。</p>
</blockquote>
<p>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</p>
<p>可以将 Redis 中的事务就理解为 ：Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</p>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><h2 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起针对该数据请求，例如我们数据库的 id 都是 1 开始自增上去的，而用户不断发起针对id值为 -1 的数据或 id 为特别大不存在的数据的请求。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</p>
<h2 id="缓存穿透情况的处理流程是怎样的"><a href="#缓存穿透情况的处理流程是怎样的" class="headerlink" title="缓存穿透情况的处理流程是怎样的"></a>缓存穿透情况的处理流程是怎样的</h2><p>如下图所示，用户的请求最终都要跑到数据库中查询一遍。</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220213185117.png"></p>
<h2 id="有哪些解决办法"><a href="#有哪些解决办法" class="headerlink" title="有哪些解决办法"></a>有哪些解决办法</h2><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<h3 id="缓存无效-key"><a href="#缓存无效-key" class="headerlink" title="缓存无效 key"></a>缓存无效 key</h3><p>如果缓存和数据库都查不到某个 key 的数据，就写一个到 Redis 中去并设置过期时间，这种方式可以解决请求的 key 变化不频繁的情况。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点，比如 1 分钟。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>通过布隆过滤器，我们可以非常方便地判断一个给定数据是否存在于海量数据中。当一个元素进入布隆过滤器时，会进行如下的操作：</p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）；</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</p>
<p>因此，可以用 布隆过滤器 缓解缓存穿透问题，具体做法为：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会进入数据库中查询。</p>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>数据库中有的某条数据，缓存中没有，一般是该缓存突然失效，此时如果有大量用户请求该数据，缓存中没有就会去数据库请求，会引发数据库压力增大，可能被击垮。</p>
<p>针对该问题，一般有以下做法：</p>
<ol>
<li>如果是热点数据，那么可以考虑设置为永不过期</li>
<li>如果数据一定会过期，那么需要在数据是空的时候，设置一个互斥锁，只允许一个请求通过，只让一个请求去数据库拉取数据，取完数据无论如何都要释放锁，否则其他线程会无法获取锁。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getProductDescById</span><span class="hljs-params">(String id)</span> {<br>   <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> redis.get(id);<br>   <span class="hljs-comment">// 缓存为空，过期了</span><br>   <span class="hljs-keyword">if</span>(desc == <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 互斥锁，只有一个请求可以成功</span><br>      <span class="hljs-keyword">if</span>(redis.setnx(lock_id, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>) == <span class="hljs-number">1</span>) {<br>         <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 从数据库取出数据</span><br>            desc = getFromDB(id);<br>            redis.set(id, desc, <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>);<br>         } <span class="hljs-keyword">catch</span>(Exception ex) {<br>            LogHelper.error(ex);<br>         } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 确保最后删除释放锁</span><br>            redis.del(lock_id);<br>            <span class="hljs-keyword">return</span> desc;<br>         }<br>      } <span class="hljs-keyword">else</span> {<br>         <span class="hljs-comment">// 否则休眠200ms，重新尝试获取锁</span><br>         Thread.sleep(<span class="hljs-number">200</span>);<br>         <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getProductDescById</span><span class="hljs-params">(String id)</span> {<br>   <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> redis.get(id);<br>   <span class="hljs-comment">// 缓存为空，过期了</span><br>   <span class="hljs-keyword">if</span>(desc == <span class="hljs-literal">null</span>) {<br>      <span class="hljs-comment">// 互斥锁，只有一个请求可以成功</span><br>      <span class="hljs-keyword">if</span>(redis.setnx(lock_id, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>) == <span class="hljs-number">1</span>) {<br>         <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 从数据库取出数据</span><br>            desc = getFromDB(id);<br>            redis.set(id, desc, <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>);<br>         } <span class="hljs-keyword">catch</span>(Exception ex) {<br>            LogHelper.error(ex);<br>         } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 确保最后删除释放锁</span><br>            redis.del(lock_id);<br>            <span class="hljs-keyword">return</span> desc;<br>         }<br>      } <span class="hljs-keyword">else</span> {<br>         <span class="hljs-comment">// 否则休眠200ms，重新尝试获取锁</span><br>         Thread.sleep(<span class="hljs-number">200</span>);<br>         <span class="hljs-keyword">return</span> getProductDescById(id);<br>      }<br>   }<br>}<br></code></pre></td></tr></tbody></table></figure>

<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h2><p>缓存雪崩描述的就是这样一个简单的场景：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</p>
<p>例如：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li>热点数据可以考虑永不过期</li>
<li>缓存过期时间除非业务要求十分严格，否则可以考虑设置为波动的随机值，例如理论要求10分钟，那么可以加一个1到3的随机值，让过期时间在 7~13 分钟内波动，从而防止在同一个时间的大规模过期</li>
<li>如果所有的热点数据都在同一台 Redis 服务器上也是非常危险的，因此可以考虑将热点数据打散分到不同的机房中</li>
<li>考虑双缓冲方式，数据库数据同步到缓存 A 与 B，A 设置过期时间，B 不设置过期时间，当 A 为空的时候去读取 B，同时异步更新缓存。</li>
</ol>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间，比如随机设置缓存的失效时间</li>
<li>缓存永不失效</li>
</ol>
<h1 id="在实际项目中使用缓存有遇到什么问题？"><a href="#在实际项目中使用缓存有遇到什么问题？" class="headerlink" title="在实际项目中使用缓存有遇到什么问题？"></a>在实际项目中使用缓存有遇到什么问题？</h1><p>缓存和数据库数据一致性问题：分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。</p>
<h1 id="如何保证缓存和数据库数据的一致性"><a href="#如何保证缓存和数据库数据的一致性" class="headerlink" title="如何保证缓存和数据库数据的一致性"></a>如何保证缓存和数据库数据的一致性</h1><h2 id="如何提高缓存利用率"><a href="#如何提高缓存利用率" class="headerlink" title="如何提高缓存利用率"></a>如何提高缓存利用率</h2><p>缓存中只保留最近访问的「热数据」。具体的方法为：</p>
<ol>
<li>写请求依旧只写数据库</li>
<li>读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存</li>
<li>同时，写入缓存中的数据，都设置失效时间</li>
</ol>
<p>这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「热数据」，缓存利用率得以最大化。</p>
<h2 id="如何保持数据一致性"><a href="#如何保持数据一致性" class="headerlink" title="如何保持数据一致性"></a>如何保持数据一致性</h2><p>可以采取更新 DB，然后直接删除 cache 的方式，如果更新数据库成功，而删除缓存这一步失败的情况的话，存在两种解决方案：</p>
<ol>
<li>缓存失效时间变短（不推荐，治标不治本） ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li>增加 cache 更新重试机制（常用）：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
<h1 id="Redis-与-DB-之间如何保持一致性"><a href="#Redis-与-DB-之间如何保持一致性" class="headerlink" title="Redis 与 DB 之间如何保持一致性"></a>Redis 与 DB 之间如何保持一致性</h1><p>更新缓存的方案主要有四种：Cache aside，Read through，Write through，Write behind caching</p>
<h2 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h2><ul>
<li>失效：应用程序先从 cache 读取数据，若没有得到，则从数据库中取数据，成功后，放入缓存</li>
<li>命中：应用程序从缓存取数据，取到后返回</li>
<li>更新：先把数据放入数据库，成功后，使缓存失效</li>
</ul>
<p>因此，该操作是 <strong>先更新数据库，再使缓存失效</strong></p>
<p>为什么不是写完数据库后直接更新缓存呢？主要是怕两个并发的写操作导致脏数据。</p>
<p>该方法仍然有可能存在问题：假设对数据库有一个读操作，且没有命中缓存，该操作去数据库读取数据。此时来了一个写操作，写完数据库后，让缓存失效，此时读操作又把老的数据放入缓存，导致了缓存的脏数据。</p>
<p>但是该种操作实际出现的概率可能非常低，因为实际上写操作比读操作慢得多，还要锁表，因此读操作必须在写操作之前进入数据库，又要在写操作之后更新缓存，概率很小。</p>
<h2 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h2><p>该模式是把更新数据库的操作交由缓存代理，也就是应用认为后端就是一个单一的存储，而存储自己维护自己的缓存</p>
<h3 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read Through"></a>Read Through</h3><p>在查询操作中更新缓存，也就是说，当缓存失效时，cache aside 是由调用方负责将数据加载入缓存，而 read through 则是利用缓存服务自己来完成加载，对于应用方来说是透明的。</p>
<h3 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h3><p>更新数据时发生，当有数据更新时，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由缓存自己更新数据库。</p>
<h3 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h3><p>更新数据时，只更新缓存不更新数据库，缓存最后会异步地批量更新数据库。但是数据不是强一致性的，还会导致丢失。</p>
<h1 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>没有采用 C 语言传统的字符串表示（即空字符结尾的字符数组），而是创建了 SDS 抽象类型。该类型包括以下优点</p>
<ol>
<li><p>常数复杂度获取字符串长度</p>
</li>
<li><p>杜绝缓存区溢出</p>
<p>在进行修改前先判断 SDS 空间是否满足修改所需的要求，若不满足则自动执行空间扩展</p>
</li>
<li><p>减少修改字符串带来的内存重分配次数</p>
<p>实现了 空间预分配 与 惰性空间释放 两种策略</p>
<p>空间预分配指的是在对字符串进行空间扩展时，扩展的内存比需要的多，从而减少字符串增长所需的内存重分配次数</p>
<p>惰性空间释放是指，缩短字符串时，不立即使用内存重新分配来回收缩短后的内存空间</p>
</li>
<li><p>二进制安全</p>
<p>C 字符串以空字符作为结束标志，对于二进制文件，也可能包含空字符，导致 C 字符串无法正常存取，而 SDS 则杜绝了这一问题</p>
</li>
<li><p>兼容部分 C 字符串函数</p>
<p>SDS 虽然不以空字符判断结尾，但是仍然以空字符结尾，因此 C 的 API 仍然可用</p>
</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>由于 C 没有实现链表，因此 Redis 实现了自己的链表结构，特点包括：</p>
<ul>
<li>双端</li>
<li>无欢</li>
<li>带表头与表尾指针，获取头部与尾部的复杂度为 O(1)</li>
<li>带长度计数器</li>
<li>多态：能够保存不同类型的值</li>
</ul>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>同样实现了自己的字典</p>
<p>采用链地址法解决哈希冲突</p>
<p>当哈希表进行扩容和收缩时，采用 Rehash (重新散列)</p>
<p>如果扩展则基于原哈希表创建一个大小等于二倍原大小的哈希表，如果收缩则创建原大小一半的哈希表，并重新计算索引值，迁徙键值对，释放原哈希表的内存空间</p>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>采用跳表实现</p>
<p>跳表类似于增加了索引的链表，通过增加多级索引减少了搜索次数</p>
<h2 id="与平衡树、哈希表的比较"><a href="#与平衡树、哈希表的比较" class="headerlink" title="与平衡树、哈希表的比较"></a>与平衡树、哈希表的比较</h2><p>首先哈希表不是有序排列的，不适宜进行范围查找</p>
<p>在进行范围查找时，平衡树操作更复杂，同时插入与删除操作会导致平衡树节点的调整，复杂度较高</p>
<p>跳表的查找时间复杂度为 O(log n)， 最坏复杂度为O(n)</p>
<h1 id="基于-Redis-实现分布式锁"><a href="#基于-Redis-实现分布式锁" class="headerlink" title="基于 Redis 实现分布式锁"></a>基于 Redis 实现分布式锁</h1><h2 id="使用-setnx-实现分布式锁"><a href="#使用-setnx-实现分布式锁" class="headerlink" title="使用 setnx 实现分布式锁"></a>使用 setnx 实现分布式锁</h2><p>使用 Redis 的 SETNX 命令能够保证只有一次能写入成功，但是该方法可能会带来问题：如果仅仅使用 SETNX 命令，当某个节点抢占到锁，如果此时该节点宕机，那么这个锁就不会被释放，导致出现死锁。</p>
<p>为了解决这个问题，可以采用 SETNX + EXPIRE 共同实现分布式锁的策略</p>
<h2 id="使用-SETNX-和-EXPIRE-实现分布式锁"><a href="#使用-SETNX-和-EXPIRE-实现分布式锁" class="headerlink" title="使用 SETNX 和 EXPIRE 实现分布式锁"></a>使用 SETNX 和 EXPIRE 实现分布式锁</h2><p>在使用 SETNX 获取锁之后，可以通过 EXPIRE 为锁加一个过期时间，利用缓存失效策略对锁进行超时清除。</p>
<p>然而，在 Redis 中，SETNX 和 EXPIRE 这两条命令都不具有原子性，如果一个线程在执行完 SETNX 之后突然崩溃，导致锁没有设置过期时间，那么这个锁就会一直存在，无法被其他线程获取。</p>
<h2 id="使用-SETNX-value值设置为-系统时间-过期时间"><a href="#使用-SETNX-value值设置为-系统时间-过期时间" class="headerlink" title="使用 SETNX + value值设置为 系统时间+过期时间"></a>使用 SETNX + value值设置为 系统时间+过期时间</h2><p>为了解决 SETNX 和 EXPIRE 发生异常导致锁得不到释放的情况，还可以将过期时间放入 SETNX 的 value 值中，如果加锁失败，则直接将 value 值取出进行校验。</p>
<p>该方案的优点在于，移除了采用 EXPIRE 设置过期时间的操作，而是将过期时间放入 SETNX 的 value 值中。</p>
<p>然而该方案也存在别的缺点，一方面是该锁没有保存锁持有者的唯一标识，可能会被其他的客户端释放；一方面是加锁成功的锁过期时间可能会被别的客户端所覆盖</p>
<h2 id="使用-Lua-脚本"><a href="#使用-Lua-脚本" class="headerlink" title="使用 Lua 脚本"></a>使用 Lua 脚本</h2><p>使用 Lua 脚本能够解决上述的原子性问题，但是 setnx 锁最大的缺点是它加锁时只作用于一个 Redis 节点上，即使 Redis 通过 哨兵 模式保证了高可用，如果 master 节点发生了主从切换，那么就会出现锁丢失的情况。有时候新选出来的 master 节点可以重新获取同样的锁，导致出现一把锁被拿两次的场景。</p>
<h2 id="使用-SET-的扩展命令"><a href="#使用-SET-的扩展命令" class="headerlink" title="使用 SET 的扩展命令"></a>使用 SET 的扩展命令</h2><p>SET EX PX NX 命令也是原子性的</p>
<p>其中，NX 表示只有当 key 不存在时才能设置成功，保证了只有第一个客户端请求才能获得锁，其他客户端请求只能等其释放锁才能获取</p>
<p>EX seconds 设定了 key 的过期时间</p>
<p>PX milliseconds 设定了 key 的过期时间，单位为毫秒</p>
<p>XX 仅当 key 存在时设置值</p>
<p>仍然可能存在的问题：</p>
<ul>
<li>在业务执行完之前，锁过期释放了</li>
<li>锁可能被别的线程误删：线程 a 执行完后，去释放锁，但是此时的锁可能是线程 b 持有的，即线程 a 释放锁时，线程 b 进来占有了锁，那么线程 a 就错误地把 b 的锁释放了</li>
</ul>
<h2 id="SET-EX-PX-NX-校验唯一随机值，再删除"><a href="#SET-EX-PX-NX-校验唯一随机值，再删除" class="headerlink" title="SET EX PX NX + 校验唯一随机值，再删除"></a>SET EX PX NX + 校验唯一随机值，再删除</h2><p>为了解决锁可能被别的线程误删的问题，可以给 value 设置一个随机数来标记当前线程，在删除时进行校验。</p>
<p>为了保证判断是不是当前线程加的锁和释放锁这两步是一个原子操作，一般采用 Lua 脚本来执行命令。</p>
<h2 id="Redisson-框架"><a href="#Redisson-框架" class="headerlink" title="Redisson 框架"></a>Redisson 框架</h2><p>为了解决业务没执行完锁就过期释放的问题，可以采用开源框架 Redisson。这个框架在线程 A 加锁成功后，会启动一个 watch dog 后台线程，该线程会每隔 10 秒检查一下，如果该线程还持有锁，那么就会不断延长锁的过期时间，从而解决该问题</p>
<h2 id="多机实现的分布式锁-Redlock-Redisson"><a href="#多机实现的分布式锁-Redlock-Redisson" class="headerlink" title="多机实现的分布式锁 Redlock + Redisson"></a>多机实现的分布式锁 Redlock + Redisson</h2><p>由于 Redis 通常是集群部署的，在集群部署时，分布式锁可能会出现一个问题：如果线程 A 在 Redis 的 master 节点上拿到了锁，但是加锁的 key 还没有同步到 slave 节点，恰好此时 master 宕机，一个 slave 节点就会升级为 master 节点，线程 B 就能够获得该 key 的锁，相当于 A、B 两个线程同时获得了锁，失去了安全性</p>
<p>为了解决上述问题，Redis 的作者提出了一种高级的分布式锁算法 Redlock，其核心思想为：</p>
<p>设置多个 Redis master 部署，保证其不会同时宕机，并且这些 master 是完全相互独立的，相互之间不存在数据同步、主从复制或其他集群协调机制</p>
<p>假设有 5 个 master 节点，在这些节点上运行 Redis 实例，RedLock 的实现步骤为：</p>
<ul>
<li>获取当前 Unix 时间，单位毫秒</li>
<li>依次尝试向 5 个实例，使用相同的 key 和具有唯一性的 value(例如 UUID + threadId)获取锁，客户端会设置一个网络连接和响应超时时间，并且该时间需要小于锁的失效时间(假设锁自动失效时间为 10s，则超时时间设置为 5-50ms 之间)，如果超时则跳过该 master 节点，尽快去尝试下一个节点。这样可以防止服务端 Redis 宕机的情况下依然等待锁</li>
<li>客户端使用当前时间减去开始获取锁的时间，得到获取锁所消耗的时间。当且仅当超过一半的 master 节点都获得锁，并且使用的时间小于锁失效时间时，才算获取锁成功</li>
<li>获取锁之后，key 的真正有效时间也发生了改变，需要减去获取锁所消耗的时间</li>
<li>若获取锁失败，还需要在所有 master 上解锁，即使某些 Redis 实例根本没有加锁，这是为了防止某些节点获取到锁但是客户端没有得到响应，而导致接下来的一段时间都无法获取锁。</li>
</ul>
<h1 id="Redis-快的原因"><a href="#Redis-快的原因" class="headerlink" title="Redis 快的原因"></a>Redis 快的原因</h1><p>首先，Redis是一个单线程应用，所说的单线程指的是 Redis 使用单个线程处理客户端的请求。</p>
<p>虽然Redis是单线程的应用，但是即便不通过部署多个 Redis 实例和集群的方式来提升系统吞吐， 从官网给出的数据可以看出，Redis处理速度依然非常快。</p>
<p>Redis性能非常高的原因主要有以下几点：</p>
<ul>
<li>内存存储：Redis是使用内存(in-memeroy)存储,没有磁盘IO上的开销</li>
<li>单线程实现：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销</li>
<li>非阻塞IO：Redis使用多路复用IO技术，在poll，epool，kqueue选择最优IO实现</li>
<li>优化的数据结构：Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能</li>
</ul>
<p>接下来将主要介绍非阻塞IO和优化的数据结构两部分</p>
<h1 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h1><h2 id="什么是-IO-多路复用"><a href="#什么是-IO-多路复用" class="headerlink" title="什么是 IO 多路复用"></a>什么是 IO 多路复用</h2><p><strong>多进程</strong></p>
<p>首先从多进程说起，对于常见的并发情况，假如一个线程不能处理，那么增加多个线程不就可以同时处理多个客户端连接了么？多线程这种方式的确可以解决了服务器在同一时间能处理多个客户端连接请求的问题，但是仍存在一些缺点：</p>
<ul>
<li>进程之间需要进行上下文切换，效率较低</li>
<li>进程创建的数量随着连接请求的增加而增加，数量越多，开销越大</li>
<li>进程与进程之间的地址空间是私有、独立的，使得进程之间的数据共享变得困难</li>
</ul>
<p><strong>多线程</strong></p>
<p>线程是运行在进程上下文的逻辑流，一个进程可以包含多个线程，多个线程运行在同一进程上下文中，因此可共享这个进程地址空间的所有内容，解决了进程与进程之间通信难的问题。</p>
<p>同时，由于一个线程的上下文要比一个进程的上下文小得多，所以线程的上下文切换，要比进程的上下文切换效率高得多。</p>
<p><strong>IO 多路复用</strong></p>
<ul>
<li>多路：多个客户端连接（连接就是套接字描述符）</li>
<li>复用：使用单进程就能够实现同时处理多个客户端的连接</li>
</ul>
<p>因此简单理解 IO 多路复用就是：一个服务端进程可以同时处理多个套接字描述符。如果通过增加进程和线程的数量来并发处理多个套接字，免不了上下文切换的开销，而 IO 多路复用只需要一个进程就能够处理多个套接字，从而解决了上下文切换的问题。</p>
<p>其发展可以分 select-&gt;poll-&gt;epoll 三个阶段来描述。</p>
<h2 id="如何简单理解-select-poll-epoll-呢？"><a href="#如何简单理解-select-poll-epoll-呢？" class="headerlink" title="如何简单理解 select/poll/epoll 呢？"></a>如何简单理解 select/poll/epoll 呢？</h2><blockquote>
<p>举栗说明：</p>
<p>领导分配员工开发任务，有些员工还没完成。如果领导要每个员工的工作都要验收 check，那在未完成的员工那里，只能阻塞等待，等待他完成之后，再去 check 下一位员工的任务，造成性能问题。</p>
</blockquote>
<p><strong>那如何解决这个问题呢？</strong></p>
<p><strong>select</strong></p>
<blockquote>
<p>举栗说明：</p>
<p>领导找个 Team Leader（后文简称 TL），负责代自己 check 每位员工的开发任务。TL 的做法是：遍历问各个员工“完成了么？”，完成的待 CR check 无误后合并到 Git 分支，对于其他未完成的，休息一会儿后再去遍历….</p>
</blockquote>
<p>这样存在什么问题呢？</p>
<ul>
<li>这个 TL 存在能力短板问题，最多只能管理 1024 个员工</li>
<li>很多员工的任务没有完成，而且短时间内也完不成的话，TL 还是会不停的去遍历问询，影响效率。</li>
</ul>
<p>这个 TL 就是 select 函数，select 函数监视的文件描述符分 3 类，分别是 writefds、readfds、和 exceptfds。调用后 select 函数会阻塞，直到有描述符就绪（有数据可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 select 函数返回后，可以通过遍历 fdset，来找到就绪的描述符。</p>
<p>select 具有良好的跨平台支持，其缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024。</p>
<p><strong>poll</strong></p>
<blockquote>
<p>举栗说明：</p>
<p>换一个能力更强的 New Team Leader（后文简称 NTL），可以管理更多的员工，这个 NTL 可以理解为 poll。</p>
</blockquote>
<p>poll 改变了文件描述符集合的描述方式，使用了 pollfd 结构而不是 select 的 fd_set 结构，使得 poll 支持的文件描述符集合限制远大于 select 的 1024。</p>
<p><strong>epoll</strong></p>
<blockquote>
<p>举栗说明：</p>
<p>在上一步 poll 方式的 NTL 基础上，改进一下 NTL 的办事方法：遍历一次所有员工，如果任务没有完成，告诉员工待完成之后，其应该做 xx 操作（制定一些列的流程规范）。这样 NTL 只需要定期 check 指定的关键节点就好了。这就是 epoll。</p>
</blockquote>
<p>epoll 是 Linux 内核为处理大批量文件描述符而作了改进的 poll，是 Linux 下多路复用 IO 接口 select/poll 的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p>
<p><strong>总结</strong></p>
<ul>
<li>select 就是轮询，在 Linux 上限制个数一般为 1024 个</li>
<li>poll 解决了 select 的个数限制，但是依然是轮询</li>
<li>epoll 解决了个数的限制，同时解决了轮询的方式</li>
</ul>
<h2 id="IO-多路复用在-Redis-中的应用"><a href="#IO-多路复用在-Redis-中的应用" class="headerlink" title="IO 多路复用在 Redis 中的应用"></a>IO 多路复用在 Redis 中的应用</h2><p>Redis 服务器是一个事件驱动程序， 服务器处理的事件分为时间事件和文件事件两类。</p>
<ul>
<li>文件事件：Redis 主进程中，主要处理客户端的连接请求与响应；</li>
<li>时间事件：fork 出的子进程中，处理如 AOF 持久化任务等。</li>
</ul>
<p>尽管 Redis 的文件事件是单进程、单线程模型，但是却保持着优秀的吞吐量，IO 多路复用起到了主要作用。</p>
<p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。IO 多路复用程序负责监听多个套接字并向文件事件分派器传送那些产生了事件的套接字，文件事件分派器接收 IO 多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。其具体流程如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220223145130.png"></p>
<p>Redis 的 IO 多路复用程序的所有功能都是通过包装常见的 select、poll、evport 和 kqueue 这些 IO 多路复用函数库来实现的，每个 IO 多路复用函数库在 Redis 源码中都有对应的一个单独的文件。</p>
<p>Redis 为每个 IO 多路复用函数库都实现了相同的 API，所以 IO 多路复用程序的底层实现是可以互换的。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220223145323.png"></p>
<p>Redis 把所有连接与读写事件、还有我们没提到的时间事件一起集中管理，并对底层 IO 多路复用机制进行了封装，最终实现了单进程能够处理多个连接以及读写事件。这就是 IO 多路复用在 redis 中的应用。</p>
<h1 id="丰富高效的数据结构"><a href="#丰富高效的数据结构" class="headerlink" title="丰富高效的数据结构"></a>丰富高效的数据结构</h1><p>Redis 提供了丰富的数据结构，并且不同场景下提供不同实现。其共有 5 种基本的数据结构，它们分别是：string(字符串)、list(列表)、hash(字典)、set(集合) 和 zset(有序集合)。</p>
<h2 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h2><p>Redis 中的字符串是一种 动态字符串，这意味着使用者可以修改，它的底层实现有点类似于 Java 中的 ArrayList，有一个字符数组。从源码中可以看到 Redis 底层对于字符串的定义为 SDS，即 Simple Dynamic String 结构。</p>
<p>String 是 Redis 最简单最常用的数据结构，也是 Memcached 唯一的数据结构。在平时的开发中，String 可以说是使用最频繁的了。</p>
<p>底层实现：</p>
<ul>
<li>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。</li>
<li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw。</li>
<li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</li>
</ul>
<p>该数据结构可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储 512M</p>
<p>应用场景：</p>
<ul>
<li>缓存功能：string 最常用的就是缓存功能，会将一些更新不频繁但是查询频繁的数据缓存起来，以此来减轻 DB 的压力。</li>
<li>计数器：可以用来计数，通过 incr 操作，如统计网站的访问量、文章访问量等。</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Redis 的列表相当于 Java 语言中的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p>
<p>底层实现：</p>
<ul>
<li>列表对象的编码可以是 ziplist 或者 linkedlist；</li>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节并且保存的元素数量小于 512 个，使用 ziplist 编码；否则使用 linkedlist。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>消息队列：Redis 的 list 是有序的列表结构，可以实现阻塞队列，使用左进右出的方式。Lpush 用来生产 从左侧插入数据，Brpop 用来消费，用来从右侧弹出消费数据。</li>
<li>数据的分页展示： lrange 命令需要两个索引来获取数据，这个就可以用来实现分页，可以在代码中计算两个索引值，然后来 redis 中取数据。</li>
<li>可以用来实现粉丝列表以及最新消息排行等功能。</li>
</ul>
<h2 id="字典-Hash"><a href="#字典-Hash" class="headerlink" title="字典 Hash"></a>字典 Hash</h2><p>Redis 中的字典相当于 Java 中的 HashMap，内部实现也差不多类似，都是通过 “数组 + 链表” 的链地址法来解决部分 哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。</p>
<p>底层实现：</p>
<ul>
<li>哈希对象的编码可以是 ziplist 或者 hashtable；</li>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节并且保存的键值对数量小于 512 个，使用ziplist 编码；否则使用hashtable。</li>
</ul>
<p>实际上 Redis 字典结构的内部包含两个 hashtable，通常情况下只有一个 hashtable 是有值的，但是在字典扩容缩容时，需要分配新的 hashtable，然后进行 渐进式搬迁</p>
<p><strong>渐进式 rehash</strong></p>
<p>大字典的扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新的数组下面，这是一个 O(n) 级别的操作，作为单线程的 Redis 很难承受这样耗时的过程，所以 Redis 使用 渐进式 rehash 小步搬迁：</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220223153026.png"></p>
<p>渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，如上图所示，查询时会同时查询两个 hash 结构，然后在后续的定时任务以及 hash 操作指令中，循序渐进的把旧字典的内容迁移到新字典中。当搬迁完成了，就会使用新的 hash 结构取而代之。</p>
<p><strong>扩缩容的条件</strong></p>
<p>正常情况下，当 hash 表中 <strong>元素的个数等于第一维数组的长度时</strong>，就会开始扩容，扩容的新数组是 <strong>原数组大小的 2 倍</strong>。不过如果 Redis 正在做 bgsave(持久化命令)，为了减少内存，Redis 尽量不去扩容，但是如果 hash 表非常满了，达到了第一维数组长度的 5 倍了，这个时候就会 强制扩容。</p>
<p>当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 元素个数低于数组长度的 10%，缩容不会考虑 Redis 是否在做 bgsave。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li>Hash 更适合存储结构化的数据，比如 Java 中的对象；其实 Java 中的对象也可以用 string 进行存储，只需要将 对象 序列化成 json 串就可以，但是如果这个对象的某个属性更新比较频繁的话，那么每次就需要重新将整个对象序列化存储，这样消耗开销比较大。可如果用 hash 来存储 对象的每个属性，那么每次只需要更新要更新的属性就可以。</li>
<li>购物车场景：可以以用户的id为key，商品的id 为存储的field，商品数量为键值对的value，这样就构成了购物车的三个要素。</li>
</ul>
<h2 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 Set"></a>集合 Set</h2><p>Redis 的集合相当于 Java 语言中的 HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。</p>
<p>底层实现：</p>
<ul>
<li>集合对象的编码可以是 intset 或者 hashtable；</li>
<li>集合对象保存的所有元素都是整数值并且保存的元素数量不超过 512 个，使用intset 编码；否则使用hashtable。</li>
</ul>
<p>应用场景：</p>
<ul>
<li>标签：可以将博客网站每个人的标签用 set 集合存储，然后还按每个标签将用户进行归并；</li>
<li>存储好友/粉丝：set 具有去重功能；还可以利用set并集功能得到共同好友之类的功能。</li>
</ul>
<h2 id="有序列表-SortedSet-（zset）"><a href="#有序列表-SortedSet-（zset）" class="headerlink" title="有序列表 SortedSet （zset）"></a>有序列表 SortedSet （zset）</h2><p>这可能是 Redis 最具特色的一个数据结构了，它类似于 Java 中 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。</p>
<p>基本概念：</p>
<p>有序集合和散列一样，都用于存储键值对：其中有序集合的每个键称为成员（member），都是独一无二的，而有序集合的每个值称为分值（score），都必须是浮点数，可以根据分数进行排序。有序集合是Redis里面唯一既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构。和Redis的其他结构一样，用户可以对有序集合执行添加、移除和获取等操作。</p>
<p><strong>底层实现：</strong></p>
<p>该结构的内部实现用的是一种叫做 「跳跃表」 的数据结构，由于比较复杂，所以在这里仅仅简单提一下原理：</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220223154103.png"></p>
<p>想象你是一家创业公司的老板，刚开始只有几个人，大家都平起平坐。后来随着公司的发展，人数越来越多，团队沟通成本逐渐增加，渐渐地引入了组长制，对团队进行划分，于是有一些人又是员工又有组长的身份。</p>
<p>再后来，公司规模进一步扩大，公司需要再进入一个层级：部门。于是每个部门又会从组长中推举一位选出部长。</p>
<p>跳跃表就类似于这样的机制，最下面一层所有的元素都会串起来，都是员工，然后每隔几个元素就会挑选出一个代表，再把这几个代表使用另外一级指针串起来。然后再在这些代表里面挑出二级代表，再串起来。最终形成了一个金字塔的结构。</p>
<p>应用场景：</p>
<ul>
<li>排行榜：有序集合最常用的场景。如新闻网站对热点新闻排序，比如根据点击量、点赞量等；</li>
<li>带权重的消息队列：重要的消息 score 大一些，普通消息 score 小一些，可以实现优先级高的任务先执行。</li>
</ul>
<p>除了上述的五种基本数据结构外，Redis 还有三种高级数据结构，分别为 HyperLogLog、GEO、Bitmap和 BloomFilter</p>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<blockquote>
<p>基数，可以理解为一个集合（这里的集合允许存在重复元素）中不重复元素的个数。例如集合{1,2,3,1,2}，它有5个元素，但它的基数/Distinct数为3。</p>
</blockquote>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>应用场景：</p>
<ul>
<li>可以用来统计网站的登陆人数以及其他指标</li>
</ul>
<h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><p>主要用来存储地理位置信息，并对存储的信息进行操作。</p>
<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>BitMap，即位图，也就是 byte 数组，用二进制表示，只有 0 和 1 两个数字，底层使用SDS存储。</p>
<p><strong>使用场景</strong></p>
<ul>
<li>日活跃用户：如果是日活跃用户的话只需要创建一个Bitmap即可，每个用户根据ID对应Bitmap中的一位，当某个用户满足活跃用户条件后，就在Bitmap中把标识此用户的位置为1。假设有1000W用户，那么只需要 1000W/8/1024/1024 差不多1.2M的空间，简直完美</li>
<li>布隆过滤器：根据hash算法确定key要映射到哪些bit上(一般为多个,越多冲突越小)；setbit 将对应的bit全置为1；查询时同样先hash,如果对应的映射不是都为1则说明该key一定不存在，都为1则说明可能存在。</li>
</ul>
<p>由于具备了如此丰富高效的数据结构，Redis 对于特定 key 的操作过程就可以很容易的实现，也因此成就了 Redis 的高效：</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220223160058.png"></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">ArcticUnicorn</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2023/11/16/redis/">http://example.com/2023/11/16/redis/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">ArcticUnicorn</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">
                                    <span class="chip bg-color">数据库</span>
                                </a>
                            
                                <a href="/tags/Redis/">
                                    <span class="chip bg-color">Redis</span>
                                </a>
                            
                                <a href="/tags/%E7%BC%93%E5%AD%98/">
                                    <span class="chip bg-color">缓存</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/11/16/rabbitmq/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="RabbitMQ">
                        
                        <span class="card-title">RabbitMQ</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-11-16
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="post-category">
                                    中间件
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Rabbit-MQ/">
                        <span class="chip bg-color">Rabbit MQ</span>
                    </a>
                    
                    <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">
                        <span class="chip bg-color">消息中间件</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/11/16/mysql-shu-ju-ku/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="MySQL数据库">
                        
                        <span class="card-title">MySQL数据库</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-11-16
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-category">
                                    数据库
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MySQL/">
                        <span class="chip bg-color">MySQL</span>
                    </a>
                    
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">
                        <span class="chip bg-color">数据库</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: ArcticUnicorn<br />'
            + '文章作者: 北极企鹅<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
	    <span id="calcSiteTime"></span> <br>
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2023</span>
            
            <a href="/about" target="_blank">北极企鹅</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">111.6k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2022";
                        var startMonth = "10";
                        var startDate = "25";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/ArcticUnicorn" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:18940979051@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1480142036" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1480142036" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="yao1m13835365174" class="tooltipped" target="_blank" data-tooltip="微信联系我:  yao1m13835365174"  data-position="top" data-delay="50">
        <i class="fab fa-weixin"></i>
    </a>



    <a href="https://weibo.com/u/5802281586" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/5802281586" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    
   

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>

</html>
