<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="计算机网络基础, Java,k8s,istio,linux,net">
    <meta name="description" content="计算机网络的分层参考模型
自上而下介绍各层的作用：
应用层应用层 (application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>计算机网络基础 | ArcticUnicorn</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="ArcticUnicorn" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ArcticUnicorn</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/navigate" class="waves-effect waves-light">
      
      <span>导航</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ArcticUnicorn</div>
        <div class="logo-desc">
            
            本网站为个人兴趣爱好,分享经验,记录学习生活点滴的平台,希望在未来的学习生活中,有所积淀。
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/navigate" class="waves-effect waves-light">
			
				<i class="fas fa-fw fa-link"></i>
			
			导航
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/21.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">计算机网络基础</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
                                <span class="chip bg-color">计算机基础</span>
                            </a>
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                <span class="chip bg-color">计算机网络</span>
                            </a>
                        
                            <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">
                                <span class="chip bg-color">网络协议</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                计算机基础
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-11-16
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    18.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    65 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="计算机网络的分层参考模型"><a href="#计算机网络的分层参考模型" class="headerlink" title="计算机网络的分层参考模型"></a>计算机网络的分层参考模型</h1><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215151852.png"></p>
<p>自上而下介绍各层的作用：</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层 (application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。</p>
<blockquote>
<p>域名系统：可以将域名和 IP 地址相互映射的一个分布式数据库</p>
<p>HTTP 协议：所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>
</blockquote>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>在物理层上所传送的数据单位是比特。</p>
<p>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异， 使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215154503.png"></p>
<h1 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h1><h2 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h2><p>为了准确地把数据送到目标处，TCP 协议采用了三次握手机制，其基本流程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215154714.png"></p>
<ul>
<li>客户端发送带有 SYN 标志的数据包到服务端——一次握手</li>
<li>服务端发送带有 SYN/ACK 标志的数据包给客户端——二次握手</li>
<li>客户端发送带有 ACK 标志的数据包给服务端——三次握手</li>
</ul>
<p>详细流程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215155907.png"></p>
<p>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</p>
<ul>
<li>TCP服务器进程先创建 <strong>传输控制块TCB</strong>，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>
<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文。报文首部中的同步位 SYN=1，同时选择一个初始序列号 seq=x，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。<strong>TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</strong></li>
<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该置 ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。<strong>这个报文也不能携带数据，但是同样要消耗一个序号。</strong></li>
<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。<strong>TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</strong></li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ul>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>三次握手的目的是建立可靠的通信信道，使通信双方确认自己与对方的发送与接收是正常的。</p>
<p>第一次握手：客户端什么都不能确认；服务端确认了对方发送正常，自己接收正常</p>
<p>第二次握手：客户端确认了：自己发送、接收正常，对方发送、接收正常；服务端确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：客户端确认了：自己发送、接收正常，对方发送、接收正常；服务端确认了：自己发送、接收正常，对方发送、接收正常</p>
<h3 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？"></a>为什么TCP客户端最后还要发送一次确认呢？</h3><p>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p>
<p>假如使用两次握手连接，假设这样的一个场景：<strong>客户端发送了第一个请求连接并且没有丢失，只是在网络结点中滞留的时间太长了。</strong> 由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接，完成了一次正常的通信。</p>
<p>然而此时，此前滞留的那一次请求连接的网络通畅了，到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h3 id="第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN？</h3><p>传回的 ACK 是为了向客户端确认服务端已经收到了客户端所发送的信号，表明从客户端到服务端的通信是正常的。而 SYN 则是为了建立并确认从服务端到客户端的通信。</p>
<blockquote>
<p>SYN 同步序列编号：是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h2 id="TCP-的四次挥手"><a href="#TCP-的四次挥手" class="headerlink" title="TCP 的四次挥手"></a>TCP 的四次挥手</h2><p>数据传输完毕后，通信双方都可释放连接。最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态，然后客户端主动关闭，服务器被动关闭。</p>
<ul>
<li>客户端进程发出连接释放报文，并且停止发送数据。FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。<strong>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</strong></li>
<li>服务器收到连接释放报文，发出确认报文。ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器方向的通信链路就释放了，这时候处于半关闭状态，即：客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。<strong>这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</strong></li>
<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（<strong>在这之前还需要接受服务器发送的最后的数据</strong>）</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文。FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。<strong>注意此时TCP连接还没有释放，必须经过 2 ∗ MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</strong></li>
<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。<strong>可以看到，服务器结束TCP连接的时间要比客户端早一些。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215162846.png"></p>
<h3 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h3><ul>
<li>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失。站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次。而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</li>
<li>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li>
</ul>
<h3 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p>
<p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必已经将全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接。因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办</h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h1 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h1><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信）。</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h1 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h1><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。（也就是所谓的，TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ 协议：</strong> 每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h2 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h2><p>即自动请求重传协议，是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
<h3 id="停止等待-ARQ-协议"><a href="#停止等待-ARQ-协议" class="headerlink" title="停止等待 ARQ 协议"></a>停止等待 ARQ 协议</h3><p>停止等待协议的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p>该方法的主要优点就是简单，但是缺点也非常明显，由于等待时间长，会使得信道利用率低。</p>
<h3 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p>该方法与停止等待协议相比，提高了信道利用率，并且容易实现。然而缺点就是不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<blockquote>
<p>例如，发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
</blockquote>
<h3 id="重传类型"><a href="#重传类型" class="headerlink" title="重传类型"></a>重传类型</h3><p><strong>出现差错情况（超时重传）:</strong> 停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ 。</strong> 另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>确认丢失和确认迟到：</strong> </p>
<ul>
<li><strong>确认丢失 ：</strong> 确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 重新发送确认消息。</li>
<li><strong>确认迟到：</strong> 确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>
</ul>
<h2 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h2><p>TCP 利用滑动窗口实现流量控制。滑动窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<p>假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215180509.png"></p>
<p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫累计确认或者累计应答。</p>
<h3 id="窗口的大小"><a href="#窗口的大小" class="headerlink" title="窗口的大小"></a>窗口的大小</h3><p>TCP 头里有一个字段叫 Window，也就是窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。因此，滑动窗口的大小通常是由接收方决定的。</p>
<h3 id="接收窗口和发送窗口的大小是相等的吗？"><a href="#接收窗口和发送窗口的大小是相等的吗？" class="headerlink" title="接收窗口和发送窗口的大小是相等的吗？"></a>接收窗口和发送窗口的大小是相等的吗？</h3><p>并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。</p>
<p>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>
<h3 id="什么是流量控制？"><a href="#什么是流量控制？" class="headerlink" title="什么是流量控制？"></a>什么是流量控制？</h3><p>发送方不能无脑发数据给接收方，要考虑接收方处理能力。如果一直无脑发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</p>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫<strong>拥塞</strong>。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p>
<p>拥塞控制与流量控制的区别在于，拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<h2 id="什么是拥塞窗口"><a href="#什么是拥塞窗口" class="headerlink" title="什么是拥塞窗口"></a>什么是拥塞窗口</h2><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>拥塞窗口 cwnd 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，cwnd 就会增大；</li>
<li>但网络中出现了拥塞，cwnd 就减少。</li>
</ul>
<h2 id="拥塞控制有哪些控制算法？"><a href="#拥塞控制有哪些控制算法？" class="headerlink" title="拥塞控制有哪些控制算法？"></a>拥塞控制有哪些控制算法？</h2><p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。</p>
<h3 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h3><p>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</p>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</p>
<h3 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h3><p>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。然而当有多个数据信息包在某一段很短的时间内丢失时，该算法就不能很有效地工作。</p>
<h1 id="DNS-原理"><a href="#DNS-原理" class="headerlink" title="DNS 原理"></a>DNS 原理</h1><p>DNS 即域名系统，其是用于实现域名和 IP 地址相互映射的一个分布式数据库。其基本解析流程为：</p>
<ol>
<li><p>客户端输入域名，即由浏览器发起一个 DNS 解析请求，浏览器会首先在自己的缓存中查找 URL 对应的 IP 地址，如果缓存中没有，会进入下一步</p>
</li>
<li><p>通过计算机本地的 Host 文件配置，可以设置 URL 和 IP 地址之间的映射关系，因此会查找本地的 Host 文件，看是否有 IP 地址的缓存</p>
</li>
<li><p>如果仍然没有获得 IP 地址，会请求本地 DNS 服务器，通过本地运营商获取 URL 和 IP 的映射关系。由于本地 DNS 物理距离较近、性能较好，因此很快返回域名解析结果。</p>
</li>
<li><p>如果本地缓存服务器中找不到结果，则会首先向根服务器查询，根服务器中记录各个顶级域所在服务器的位置，例如向根服务器请求 .cn 时，根服务器会返回 .cn 服务器的位置信息</p>
</li>
<li><p>返回顶级域名服务器地址后，访问对应的服务器，并且返回 Name Server 服务器地址。所谓的 Name Server 就算网站注册的域名服务器，上面保存了 URL 和 对应的 IP 信息。</p>
</li>
<li><p>Name Server 会把指定域名的 A 记录或者 CNAME 返回给本地服务器，并且设置一个 TTL</p>
<p>A（Address）记录用来指定主机名对应的 IP 地址记录，CNAME 即别名记录，TTL 即 time to live，即过期时间</p>
</li>
<li><p>如果获取的是 A 记录，则可以直接访问，如果获取到的是 CNAME，那么会将其传给 GTM Server</p>
<p>GTM 即全局流量管理，传给 GTM 是希望通过其负载均衡机制，帮助用户找到最适合自己的服务器 IP 地址。</p>
</li>
<li><p>获得 IP 地址，进行访问。</p>
</li>
</ol>
<h1 id="在浏览器中输入-url-地址-显示主页的过程"><a href="#在浏览器中输入-url-地址-显示主页的过程" class="headerlink" title="在浏览器中输入 url 地址 ->> 显示主页的过程"></a>在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程</h1><p>总体来说分为以下几个过程:</p>
<ol>
<li>输入地址</li>
<li>浏览器查找域名的 IP 地址</li>
<li>浏览器向 web 服务器发送一个 HTTP 请求</li>
<li>服务器的永久重定向响应</li>
<li>服务器处理请求</li>
<li>服务器返回一个 HTTP 响应</li>
<li>浏览器显示 HTML</li>
<li>浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</li>
</ol>
<h2 id="输入地址"><a href="#输入地址" class="headerlink" title="输入地址"></a>输入地址</h2><p>当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google 的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p>
<h2 id="浏览器查找域名的-IP-地址"><a href="#浏览器查找域名的-IP-地址" class="headerlink" title="浏览器查找域名的 IP 地址"></a>浏览器查找域名的 IP 地址</h2><ol>
<li>查看本地硬盘的 hosts 文件：请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</li>
<li>查询本地DNS服务器：如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</li>
<li>本地服务器查询缓存：查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</li>
<li>查询根DNS服务器：如果根 DNS 服务器没有记录具体的域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。</li>
<li>查询域服务器：本地DNS服务器继续向域服务器发出请求，域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</li>
<li>向域名解析服务器发出请求：最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215222710.png"></p>
<h2 id="浏览器向-web-服务器发送一个-HTTP-请求"><a href="#浏览器向-web-服务器发送一个-HTTP-请求" class="headerlink" title="浏览器向 web 服务器发送一个 HTTP 请求"></a>浏览器向 web 服务器发送一个 HTTP 请求</h2><p>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有 httpd,nginx 等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。　</p>
<p>建立了TCP连接之后，发起一个http请求。一般的浏览器只能发起 GET 或者 POST 请求。客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：</p>
<ul>
<li>请求方法 URI 协议/版本</li>
<li>请求头(Request Header)</li>
<li>请求正文</li>
</ul>
<h2 id="服务器的永久重定向响应"><a href="#服务器的永久重定向响应" class="headerlink" title="服务器的永久重定向响应"></a>服务器的永久重定向响应</h2><p>服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问<a target="_blank" rel="noopener" href="http://www.google.com/%E8%80%8C%E9%9D%9Ehttp://google.com/%E3%80%82">http://www.google.com/而非http://google.com/。</a></p>
<blockquote>
<p>301 和 302 状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。</p>
</blockquote>
<p>当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。</p>
<h2 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h2><p>后端服务器从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。</p>
<p>一些大一点的网站会将请求发送到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。</p>
<p>此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215230219.png"></p>
<p>通过 Nginx 的反向代理，我们就能够到达web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等</p>
<blockquote>
<p>客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。</p>
</blockquote>
<h2 id="服务器返回一个-HTTP-响应"><a href="#服务器返回一个-HTTP-响应" class="headerlink" title="服务器返回一个 HTTP 响应"></a>服务器返回一个 HTTP 响应</h2><p>经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p>
<ul>
<li>状态行</li>
<li>响应头</li>
<li>响应正文</li>
</ul>
<h2 id="浏览器显示-HTML"><a href="#浏览器显示-HTML" class="headerlink" title="浏览器显示 HTML"></a>浏览器显示 HTML</h2><p>在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，在此只介绍 webkit 的渲染过程，这个过程包括：</p>
<p>解析 html 以构建 dom 树 -&gt; 构建 render 树 -&gt; 布局 render 树 -&gt; 绘制 render 树</p>
<p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。</p>
<p>DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为 reflow；当盒模型的位置，大小以及其他属性，如颜色，字体，等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。</p>
<p>页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</p>
<p>当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。</p>
<blockquote>
<p>JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我们平时的代码中，js是放在html文档末尾的。</p>
</blockquote>
<p>JS的解析是由浏览器中的JS解析引擎完成的，JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。</p>
<h2 id="浏览器发送请求获取嵌入在-HTML-中的资源"><a href="#浏览器发送请求获取嵌入在-HTML-中的资源" class="headerlink" title="浏览器发送请求获取嵌入在 HTML 中的资源"></a>浏览器发送请求获取嵌入在 HTML 中的资源</h2><p>其实这个步骤可以并列在上一步中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。</p>
<h2 id="整个过程使用到的协议"><a href="#整个过程使用到的协议" class="headerlink" title="整个过程使用到的协议"></a>整个过程使用到的协议</h2><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215231218.png"></p>
<h1 id="HTTP-的状态码"><a href="#HTTP-的状态码" class="headerlink" title="HTTP 的状态码"></a>HTTP 的状态码</h1><p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220215231307.png"></p>
<h1 id="HTTP-的长连接与短连接"><a href="#HTTP-的长连接与短连接" class="headerlink" title="HTTP 的长连接与短连接"></a>HTTP 的长连接与短连接</h1><p>在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。</p>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p>
<h1 id="HTTP-是不保存状态的协议-那应该如何保存用户状态"><a href="#HTTP-是不保存状态的协议-那应该如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议, 那应该如何保存用户状态?"></a>HTTP 是不保存状态的协议, 那应该如何保存用户状态?</h1><p>HTTP 协议自身不对请求和响应之间的通信状态进行保存，因此提出了 Session 机制来解决这一问题。Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<h1 id="Cookie-的作用是什么-和-Session-有什么区别？"><a href="#Cookie-的作用是什么-和-Session-有什么区别？" class="headerlink" title="Cookie 的作用是什么? 和 Session 有什么区别？"></a>Cookie 的作用是什么? 和 Session 有什么区别？</h1><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p>Cookie 一般用来保存用户信息，例如已登录过的用户信息、单点登录功能的实现等等；Session 的主要作用就是通过服务端记录用户的状态。 </p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<h1 id="HTTP-1-0-和-HTTP-1-1-的主要区别是什么？"><a href="#HTTP-1-0-和-HTTP-1-1-的主要区别是什么？" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 的主要区别是什么？"></a>HTTP 1.0 和 HTTP 1.1 的主要区别是什么？</h1><ol>
<li>长连接：在 HTTP 1.0 中默认采用短连接，而 HTTP 1.1 中默认采用长连接。HTTP/1.1 的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>
<li>错误状态响应码：在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li>缓存处理</li>
<li>带宽优化及网络连接的使用：HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能；HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<h1 id="URI-与-URL-的主要区别是什么？"><a href="#URI-与-URL-的主要区别是什么？" class="headerlink" title="URI 与 URL 的主要区别是什么？"></a>URI 与 URL 的主要区别是什么？</h1><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。</p>
<h1 id="HTTP-与-HTTPS-的主要区别是什么？"><a href="#HTTP-与-HTTPS-的主要区别是什么？" class="headerlink" title="HTTP 与 HTTPS 的主要区别是什么？"></a>HTTP 与 HTTPS 的主要区别是什么？</h1><ol>
<li>端口：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li>
<li>安全性和资源消耗： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
</ol>
<blockquote>
<p>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等；</p>
<p>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。</p>
</blockquote>
<h1 id="GET-和-POST-的区别、HTTP请求的方法"><a href="#GET-和-POST-的区别、HTTP请求的方法" class="headerlink" title="GET 和 POST 的区别、HTTP请求的方法"></a>GET 和 POST 的区别、HTTP请求的方法</h1><p>GET 方法请求一个制定资源的表示形式，使用 GET 的请求应该只用于获取数据</p>
<p>POST 方法会向指定资源提交数据进行处理请求（例如提交表单或上传文件），该请求会导致新资源的建立、已有资源的修改</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li>GET 在浏览器回退时是无害的，而 POST 则会再次提交请求</li>
<li>GET 请求会被缓存，而 POST 请求不会，除非手动设置</li>
<li>GET 请求可被收藏为书签，POST 不能</li>
<li>GET 请求参数会被保存在历史记录中，POST 不能</li>
<li>GET 请求只能用 URL 编码，请求会直接暴露在 URL 上，POST 支持多种编码方式，请求放在请求体中</li>
</ol>
<h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><ol>
<li>GET</li>
<li>POST</li>
<li>HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
</ol>
<p>HTTP 1.1 新增了几种：</p>
<ol>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
<li>PATCH</li>
</ol>
<h1 id="有哪些有状态协议"><a href="#有哪些有状态协议" class="headerlink" title="有哪些有状态协议"></a>有哪些有状态协议</h1><p>很多应用层协议都是有状态的，例如 BGP 路由协议、OSPF 路由协议、TFTP 文件传输协议</p>
<h1 id="HTTP-1-0-1-1-2-0-3-0"><a href="#HTTP-1-0-1-1-2-0-3-0" class="headerlink" title="HTTP 1.0/1.1/2.0/3.0"></a>HTTP 1.0/1.1/2.0/3.0</h1><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><p>无状态的应用层协议，浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接(无连接)，服务器不跟踪也每个客户单，也不记录过去的请求(无状态)。</p>
<p>这种无状态性可以借助cookie/session机制来做身份认证和状态记录。</p>
<p>存在的问题：</p>
<ol>
<li><p>无法复用连接</p>
<p>每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。</p>
</li>
<li><p>队头阻塞</p>
<p>由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</p>
</li>
</ol>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><p>特性包括长连接、管道化</p>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP1.1增加Connection字段，通过设置Keep-Alive保持HTTP连接不断开。避免每次客户端与服务器请求都要重复建立释放建立TCP连接。提高了网络的利用率。</p>
<h3 id="管道化"><a href="#管道化" class="headerlink" title="管道化"></a>管道化</h3><p>长连接使得管道化成为可能，将先进先出队列由客户端转移到服务端</p>
<p>允许打开多个 TCP 会话，才算实现真正的并行传输</p>
<h3 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h3><p>加入了缓存处理机制，支持断点传输，并增加了 Host 字段，使得一个服务器得以创建多个 Web 站点</p>
<h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>HTTP2.0 在应用层和传输层之间增加了一个二进制分层帧，在二进制分帧层上，http2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装。这一做法突破了 HTTP 1.x 的性能限制，改进传输性能，实现了低延迟和高吞吐量。</p>
<h3 id="多路复用-连接共享"><a href="#多路复用-连接共享" class="headerlink" title="多路复用 / 连接共享"></a>多路复用 / 连接共享</h3><p>所有HTTP2.0通信都在一个TCP链接上完成，这个链接可以承载任意流量的双向数据流。</p>
<p>每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符(Stream_id)重新封装。</p>
<p>http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。实现了真正的并行传输。</p>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>在HTTP1.X中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500-8000字节的负荷。</p>
<p>比如cookie，默认情况下，浏览器会在每次请求的时候，把cookie附在header上面发给服务器。</p>
<p>HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header_files表，既避免重复header的传输，又减少了需要传输的大小。</p>
<p>高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。</p>
<h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><p>把http消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个31比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级。</p>
<p>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。</p>
<p>分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p>
<ul>
<li><p>优先级最高：主要的html</p>
</li>
<li><p>优先级高：CSS文件</p>
</li>
<li><p>优先级中：js文件</p>
</li>
<li><p>优先级低：图片</p>
</li>
</ul>
<h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>服务器除了最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确的需求。</p>
<h2 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP 3.0"></a>HTTP 3.0</h2><p>即 QUIC 协议，是一个使用UDP来替代TCP的协议</p>
<h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h3><p>缓存当前会话的上下文，下次恢复会话的时候，只需要将之前的缓存传递给服务器，验证通过，就可以进行传输了。</p>
<p>RTT：往返时延，0-RTT建连指的是：</p>
<p>传输层0-RTT就能建立连接</p>
<p>加密层0-RTT就能建立加密连接</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>基于UDP，一个连接上的多个stream之间没有依赖，即使丢包，只需要重发丢失的包即可，不需要重传整个连接。</p>
<h3 id="更好的移动端表现"><a href="#更好的移动端表现" class="headerlink" title="更好的移动端表现"></a>更好的移动端表现</h3><p>QUIC在移动端的表现比TCP好，因为TCP是基于IP识别连接，而QUIC是通过ID识别链接。 无论网络环境如何变化，只要ID不便，就能迅速重新连上。</p>
<h3 id="加密认证的根文"><a href="#加密认证的根文" class="headerlink" title="加密认证的根文"></a>加密认证的根文</h3><p>TCP协议头没有经过任何加密和认证，在传输过程中很容易被中间网络设备篡改、注入和窃听。</p>
<p>QUIC除了个别报文，比如PUBLIC_RESET和CHLO，所有报文头部都是经过认证的，报文Body都是经过加密的。</p>
<p>所以只要对 QUIC 做任何更改，接收端都能及时发现，有效地降低了安全风险。</p>
<h3 id="向前纠错机制"><a href="#向前纠错机制" class="headerlink" title="向前纠错机制"></a>向前纠错机制</h3><p>每个数据包除了它本身的内容之外还包括了其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。</p>
<p>向前纠错牺牲了每个数据包可以发送数据的上限，但是带来的提升大于丢包导致的数据重传，因为数据重传将会消耗更多的时间(包括确认数据包丢失，请求重传，等待新数据包等步骤的时间消耗)。</p>
<h1 id="为什么四次挥手等待-2-MSL"><a href="#为什么四次挥手等待-2-MSL" class="headerlink" title="为什么四次挥手等待 2 MSL"></a>为什么四次挥手等待 2 MSL</h1><p>MSL，Maximum Segment Lifetime，报文最大生存时间，指的是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>之所以等待 2 MSL，是因为在发送了第三次挥手之后，网络中仍然有可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。</p>
<p>比如，三次挥手方没有收到断开连接的最后的 ACK 报文，就会再次发送 FIN 报文，另一方接收到 FIN之后，会再次重发 ACK 报文。</p>
<p>四次挥手方发送 ACK 报文后，报文会在一个 MSL 后失效，如果失效了，那么三次挥手方会重发 FIN 报文，这个报文同样会在一个 MSL 后失效。这样一来一回恰好是两个 MSL，也就是说这两个 MSL 内，如果没有故障，三次挥手方必然会收到 ACK，因此等 2 个 MSL 是为了防止 ACK 消息丢失，三次挥手方再次发送的 FIN 消息没有收到。</p>
<p>因此，2MSL 时长其实是相当于至少允许报文丢失一次</p>
<p>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。</p>
<h1 id="301-和-302-状态码的区别"><a href="#301-和-302-状态码的区别" class="headerlink" title="301 和 302 状态码的区别"></a>301 和 302 状态码的区别</h1><p>301 适合永久重定向，代表所请求的资源已被永久定位到新位置，比较常用的场景是域名跳转。例如对 <a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a> 的访问会跳转到 <a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a></p>
<p>302 是临时重定向，即请求的资源现在临时从不同的 URL 响应请求。适合用来做临时跳转，比如未登录的用户访问用户中心会自动跳转到登录、访问 404 页面会重新定向到首页</p>
<p>总之，302 重定向只是暂时重定向，浏览器会抓取新内容并保留旧内容</p>
<p>301重定向是永久重定向，浏览器抓取新内容的同时将旧网址替换为了重定向后的网址</p>
<h1 id="HTTP、TCP、IP-三种协议中，接收端如何判断已接收完对端发送来的数据？"><a href="#HTTP、TCP、IP-三种协议中，接收端如何判断已接收完对端发送来的数据？" class="headerlink" title="HTTP、TCP、IP 三种协议中，接收端如何判断已接收完对端发送来的数据？"></a>HTTP、TCP、IP 三种协议中，接收端如何判断已接收完对端发送来的数据？</h1><ul>
<li>HTTP 协议的服务端响应报文含有 Content-Length 字段，明确的报文的长度，客户端能够根据该字段进行判断</li>
<li>TCP 协议需要接收方回传确认号。如果双方各自向对方请求下一个数据包，却没有响应对方的请求，那么说明数据已经传完了。有时数据发送方发送完毕，会发出中断连接请求，对方也能够得知已经发送完毕了</li>
<li>IP 协议是无连接协议，不会考虑对方是否发送完毕，如果IP数据报被分片发送，那么只有最后一个分片的 “还有分片” 字段 flag 置为0，之前的都为1</li>
</ul>
<h1 id="HTTP-状态码故障排除"><a href="#HTTP-状态码故障排除" class="headerlink" title="HTTP 状态码故障排除"></a>HTTP 状态码故障排除</h1><h2 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h2><h3 id="500"><a href="#500" class="headerlink" title="500"></a>500</h3><p>500 表示服务器端错误的响应状态码，代表所请求的服务器遇到意外情况，阻止其执行请求。可能是服务器端程序或配置发生了致命错误，需要对服务器进行检查。</p>
<p>这个状态码是一个通用状态码，对于该类错误，需要访问更详细的请求信息来确定错误</p>
<h3 id="501"><a href="#501" class="headerlink" title="501"></a>501</h3><p>表示所请求的方法不被服务器锁支持，无法被处理，服务器必须支持的方法只有 GET 与 HEAD</p>
<h3 id="502"><a href="#502" class="headerlink" title="502"></a>502</h3><p>502 BAD GATEWAY 表示作为网关或代理的服务器，从上游服务器中接收到的响应是无效的</p>
<p>说白了就是，网站突然有大量请求进来，服务器无法及时处理，出现了502，需要进行重启。如果重启后依旧发生 502，则可能是数据库出现死锁导致超时，需要重启数据库或杀死死锁的 SQL 进程</p>
<p>可能导致的原因：上游服务器处理超时、配置错误、负载高导致处理请求慢、数据库发生死锁、服务未启动等</p>
<h3 id="503"><a href="#503" class="headerlink" title="503"></a>503</h3><p>源服务器存在性能问题，可能是源服务器没有足够的容量支持请求速率</p>
<p>可能是收到 DDoS 攻击，造成系统带宽和资源超载、可能系统在进行维护、可能存在防火墙配置错误，例如在传递网络时，防火墙可能将来自 CDN 的请求识别为攻击并阻止它们</p>
<h3 id="504"><a href="#504" class="headerlink" title="504"></a>504</h3><p>网关超时，一般和 Nginx 的配置有关，可能 Nginx 设置了超时时间，如果在超时时间内没有收到响应，则会给客户端返回 504</p>
<h2 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h2><h3 id="400"><a href="#400" class="headerlink" title="400"></a>400</h3><p>主要有两种形式：bad request 为请求错误，invalid hostname 为域名不存在</p>
<p>Bad request 是由于明显的客户端错误，例如格式错误的请求语法，请求大小太大，无效的请求消息或者欺骗性的路由请求等，对于这类请求服务器不会处理</p>
<p>常见的原因有：</p>
<ol>
<li>前端提交数据的字段名称或类型与后端的实体类不一致，导致无法封装，例如需要 int 传回了 String</li>
<li>前端提交到后台的数据应该是 json 类型，而前端没有将对象转化为字符串类型</li>
</ol>
<p>解决方案：</p>
<ol>
<li>对照字段名称，确保类型一致性</li>
<li>使用 Stringify 将前端传递的对象转化为字符串</li>
</ol>
<p>还有可能是走代理用的 HTTP 协议，但是目标地址是 HTTPS</p>
<h3 id="401"><a href="#401" class="headerlink" title="401"></a>401</h3><p>请求授权失败，可能是没有验证，例如需要账号密码但是没有输入，或者没有权限</p>
<h3 id="403"><a href="#403" class="headerlink" title="403"></a>403</h3><p>服务器已经理解该请求，但是拒绝执行，可能是由于以下的几种原因</p>
<p>原因：</p>
<ul>
<li>IP 被列入黑名单</li>
<li>一定时间内过多访问此网站，被防火墙拒绝</li>
<li>网络域名解析到了空间，但是空间没有绑定此域名</li>
<li>网页脚本文件在当前目录下没有执行权限</li>
<li>以 HTTP 方式访问需要 SSL 连接的网址</li>
<li>身份验证失败</li>
<li>DNS 解析错误</li>
<li>服务器繁忙</li>
</ul>
<p>解决方法：</p>
<ol>
<li>重建 DNS 缓存</li>
<li>修改文件夹安全属性</li>
</ol>
<h3 id="404"><a href="#404" class="headerlink" title="404"></a>404</h3><p>请求失败，所请求的资源在服务器上未找到</p>
<p>可能是部署的路径不正确，排查 xml 中配置文件路径是否写错，并确保 Tomcat 服务器正常开启</p>
<h2 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h2><h3 id="300"><a href="#300" class="headerlink" title="300"></a>300</h3><p>请求的资源可在多处获得</p>
<h3 id="301-302"><a href="#301-302" class="headerlink" title="301 &amp; 302"></a>301 &amp; 302</h3><p>代表客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，即重定向</p>
<p>301 代表永久重定向，说明资源已经不复存在，需要用新的 URL 进行访问</p>
<p>302 代表临时重定向，暂时用另一个 URL 进行访问</p>
<p>301 和 302 都会在响应头使用字段 Location，指明后续要跳转的 URL</p>
<h1 id="301-和-302-的区别"><a href="#301-和-302-的区别" class="headerlink" title="301 和 302 的区别"></a>301 和 302 的区别</h1><ul>
<li>302 虽然是重定向，但鉴于是临时的，所以浏览器自己的 URL 缓存不会改变，依然是原路径。在 302 重定向结束之后，只需要删除响应的重定向相关代码即可</li>
<li>301 是永久的，所以浏览器会更改自身的 URL 缓存，将旧路径换为新路径</li>
</ul>
<h2 id="302-的风险"><a href="#302-的风险" class="headerlink" title="302 的风险"></a>302 的风险</h2><ol>
<li>URL 劫持</li>
<li>网络降权</li>
</ol>
<h1 id="HTTP、TCP、IP-三种协议中，接收端如何判断已接收完对端发送来的数据？-1"><a href="#HTTP、TCP、IP-三种协议中，接收端如何判断已接收完对端发送来的数据？-1" class="headerlink" title="HTTP、TCP、IP 三种协议中，接收端如何判断已接收完对端发送来的数据？"></a>HTTP、TCP、IP 三种协议中，接收端如何判断已接收完对端发送来的数据？</h1><ul>
<li>HTTP 协议的服务端响应报文含有 Content-Length 字段，明确的报文的长度，客户端能够根据该字段进行判断</li>
<li>TCP 协议需要接收方回传确认号。如果双方各自向对方请求下一个数据包，却没有响应对方的请求，那么说明数据已经传完了。有时数据发送方发送完毕，会发出中断连接请求，对方也能够得知已经发送完毕了</li>
<li>IP 协议是无连接协议，不会考虑对方是否发送完毕，如果IP数据报被分片发送，那么只有最后一个分片的 “还有分片” 字段 flag 置为0，之前的都为1</li>
</ul>
<h1 id="HTTP-header-有哪些？"><a href="#HTTP-header-有哪些？" class="headerlink" title="HTTP header 有哪些？"></a>HTTP header 有哪些？</h1><h2 id="Request-的头部信息"><a href="#Request-的头部信息" class="headerlink" title="Request 的头部信息"></a>Request 的头部信息</h2><ol>
<li>HTTP 请求方式，包括 GET（发送请求）、POST、PUT（向服务器发生数据并存储在服务器内部）、HEAD（检查对象是否存在）、DELETE（删除文件）、TRACE（跟踪到服务器的路径）、OPTIONS（查询服务器性能）</li>
<li>HOST 请求的服务器域名地址</li>
<li>User=Agent 客户端运行的浏览器详细信息</li>
<li>Accept 指定客户端能够接收的内容类型</li>
<li>Keep-alive 此 HTTP 连接的时间</li>
<li>cookie</li>
</ol>
<h2 id="Response-的头部信息"><a href="#Response-的头部信息" class="headerlink" title="Response 的头部信息"></a>Response 的头部信息</h2><p>Response 中第一行叫状态行，由 HTTP 协议的版本号、状态码、状态消息 三部分组成</p>
<ol>
<li>Content-Length：表示服务器返回消息的长度</li>
<li>Content-type：返回数据的类型和字符编码格式</li>
<li>Date：当前时间</li>
</ol>
<h1 id="HTTPS-的通信过程"><a href="#HTTPS-的通信过程" class="headerlink" title="HTTPS 的通信过程"></a>HTTPS 的通信过程</h1><ol>
<li><p>客户端发起 HTTPS 请求</p>
<p>用户在浏览器输入网址，连接至服务器的 443 端口</p>
</li>
<li><p>服务端配置</p>
<p>采用 HTTPS 协议的服务器必须有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才能够继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书也就是一对公钥和私钥</p>
</li>
<li><p>传送服务器的证书给客户端</p>
<p>证书里其实就是公钥，并且包含了很多信息，如证书的颁发机构、过期时间等</p>
</li>
<li><p>客户端解析验证服务器证书</p>
<p>这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构、过期时间等。如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书中公钥对该随机值进行非对称加密。</p>
</li>
<li><p>客户端将加密信息传送服务器</p>
<p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值进行加密解密了。</p>
</li>
<li><p>服务端解密信息</p>
<p>服务端将客户端发送过来的加密信息用服务器私钥解密后，得到客户端传送的随机值</p>
</li>
<li><p>服务端加密信息并发送信息</p>
<p>服务器将数据利用随机值进行对称加密，再发送给客户端</p>
</li>
<li><p>客户端接收并解密信息</p>
<p>客户端用之前生成的随机值解密服务端信息，获取解密后的内容</p>
</li>
</ol>
<h1 id="HTTPS-加密原理"><a href="#HTTPS-加密原理" class="headerlink" title="HTTPS 加密原理"></a>HTTPS 加密原理</h1><h2 id="什么是对称加密？"><a href="#什么是对称加密？" class="headerlink" title="什么是对称加密？"></a>什么是对称加密？</h2><p>即发送与接收方使用同一个密钥，它可以加密一段信息，也能够对这段信息进行解密，类似于日常生活中的钥匙</p>
<h2 id="为什么不仅仅用对称加密？"><a href="#为什么不仅仅用对称加密？" class="headerlink" title="为什么不仅仅用对称加密？"></a>为什么不仅仅用对称加密？</h2><p>最大的问题是怎么保证这个密钥让传输双方知道，并且不被别人知道。这除非是浏览器保存了世界上所有网站的密钥，而这是不现实的</p>
<h2 id="什么是非对称加密？"><a href="#什么是非对称加密？" class="headerlink" title="什么是非对称加密？"></a>什么是非对称加密？</h2><p>有两把密钥，一把公钥一把私钥，用公钥加密的内容必须用私钥才能解开，反之，私钥加密的内容只有公钥能够解开。</p>
<h2 id="为什么不仅仅用非对称加密？"><a href="#为什么不仅仅用非对称加密？" class="headerlink" title="为什么不仅仅用非对称加密？"></a>为什么不仅仅用非对称加密？</h2><p>如果仅仅用非对称加密，那么服务器需要先把公钥明文发给客户端，之后客户端向服务器传数据前都用该公钥加密后再传，这条数据的安全就能够保证了。因为只有服务器有相应的私钥解开这条数据。</p>
<p>但是，服务器给浏览器发送的数据就无法保证安全。如果服务器用自己的私钥加密数据传给客户端，那么客户端用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被劫持了，那么就失去了安全性。</p>
<h2 id="非对称加密-对称加密-？"><a href="#非对称加密-对称加密-？" class="headerlink" title="非对称加密 + 对称加密 ？"></a>非对称加密 + 对称加密 ？</h2><ol>
<li>某网站拥有用于非对称加密的公钥 A、私钥 A1</li>
<li>浏览器向网站服务器请求，服务器将公钥 A 明文传输给浏览器</li>
<li>浏览器随机生成一个用于对称加密的密钥 X，用公钥 A 加密后传给服务器</li>
<li>服务器拿到后用私钥 A1 解密得到密钥 X</li>
<li>双方都拥有了密钥 X，之后的数据传输就用 X 即可</li>
</ol>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>如果在数据传输过程中，中间人劫持了数据，此时其确实无法得知密钥 X。然而，这个中间人是可能劫持到公钥 A，并对其进行保存，将公钥 A 替换成自己伪造的公钥 B 的。在后续浏览器用该公钥 B 加密 X 后传给服务器，中间人是能够劫持该数据，并用私钥 B1 对其进行解密的。之后，中间人再将其用公钥 A 加密后传给服务器。这样，中间人就获得了 X，而双方不会发现异常。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>为了保证浏览器收到的公钥就是该网站的公钥，网站在使用 HTTPS 之前，需要向 CA 机构申请一份数字证书。数字证书中含有证书持有者信息、公钥信息等。服务器将证书传递给浏览器，浏览器可以从证书中获取公钥。</p>
<h2 id="如何防止数字证书被篡改？"><a href="#如何防止数字证书被篡改？" class="headerlink" title="如何防止数字证书被篡改？"></a>如何防止数字证书被篡改？</h2><p>将证书原本的内容生成一份签名，对比证书内容和签名是否一致就能够判断是否被篡改。</p>
<p>数字签名的制作过程：</p>
<ol>
<li>CA 机构拥有非对称加密的私钥与公钥</li>
<li>CA 机构对证书明文数据 T 进行 hash</li>
<li>对 hash 后的值用私钥进行加密，得到数字签名 S</li>
</ol>
<p>浏览器验证：</p>
<ol>
<li>拿到证书，得到明文 T，签名 S</li>
<li>用 CA 机构的公钥（由于是浏览器信任的机构，因此浏览器保有公钥）对 S 解密，得到 S1</li>
<li>用证书指明的 hash 算法对明文 T 进行 hash 得到 T1</li>
<li>此时 S1 = T1，除非证书被篡改。因此对比 S1 是否等于 T1 就能够判断证书是否可信</li>
</ol>
<h2 id="为什么说-CA-机构的公钥是可信的"><a href="#为什么说-CA-机构的公钥是可信的" class="headerlink" title="为什么说 CA 机构的公钥是可信的"></a>为什么说 CA 机构的公钥是可信的</h2><p>操作系统、浏览器本身会预装一些根证书，其中就会有 CA 机构的根证书，从而拿到可信的公钥。</p>
<p>证书间的认证也可以不止一层，可以构成信任链。</p>
<h2 id="中间人有可能篡改该证书吗？"><a href="#中间人有可能篡改该证书吗？" class="headerlink" title="中间人有可能篡改该证书吗？"></a>中间人有可能篡改该证书吗？</h2><p>假设中间人篡改了证书原文，但是他没有 CA 机构的私钥，所以无法得知加密后的签名，无法篡改签名，浏览器就能够发现证书内容与签名不一致。</p>
<h2 id="中间人有可能掉包证书吗？"><a href="#中间人有可能掉包证书吗？" class="headerlink" title="中间人有可能掉包证书吗？"></a>中间人有可能掉包证书吗？</h2><p>证书中包含了网站的信息，只需要对比就能发现是否掉包</p>
<h2 id="为什么制作数字签名需要一次-hash"><a href="#为什么制作数字签名需要一次-hash" class="headerlink" title="为什么制作数字签名需要一次 hash"></a>为什么制作数字签名需要一次 hash</h2><p>非对称加密效率较差，证书信息较长，通过 hash 后能够获得固定长度信息，例如用 md5 算法 hash 后固定得到 128 位的值</p>
<h2 id="每次进行-HTTP-请求，都必须在-SSL-TLS-进行握手传输密钥吗"><a href="#每次进行-HTTP-请求，都必须在-SSL-TLS-进行握手传输密钥吗" class="headerlink" title="每次进行 HTTP 请求，都必须在 SSL/TLS 进行握手传输密钥吗"></a>每次进行 HTTP 请求，都必须在 SSL/TLS 进行握手传输密钥吗</h2><p>服务器会为每个客户端维护一个 session ID，在 TLS 握手阶段传给浏览器，浏览器生成好密钥传给服务器后，该密钥就被存入了相应的 session ID 之下，从而避免了密钥的重复传输</p>
<h1 id="HTTP-的问题"><a href="#HTTP-的问题" class="headerlink" title="HTTP 的问题"></a>HTTP 的问题</h1><p>HTTP发展到1.1存在的问题：</p>
<ul>
<li>队头阻塞问题：队头阻塞(Head Of Line Blocking)，每个TCP同时只能处理一个HTTP请求，浏览器遵循FIFO原则，如果上一个没返回后续请求会被阻塞。</li>
<li>多个TCP连接：HTTP 1.1 版本的请求并发依赖于建立多个TCP连接，建立TCP连接的成本很高，还会存在慢启动的问题。为了避免网络拥堵，占用过多的CPU和内存。因此，不同的浏览器会限制TCP连接的数量。</li>
<li>请求头冗余：HTTP/1.X 版本的请求头采用文本格式，首部未压缩，而且每一个请求都会带上cookie、user-agent等完全相同的首部。</li>
<li>客户端需要主动建立请求</li>
</ul>
<h1 id="HTTP-2-0-和-HTTP-1-0-的区别"><a href="#HTTP-2-0-和-HTTP-1-0-的区别" class="headerlink" title="HTTP 2.0 和 HTTP 1.0 的区别"></a>HTTP 2.0 和 HTTP 1.0 的区别</h1><p>HTTP 2.0的实现是基于SPDY协议的一些标准来实现的。HTTP 2.0提供了：二进制分帧、首部压缩、多路复用、请求优先级、服务器推送等优化。HTTP/2 的目的是通过支持请求与响应的多路复用来较少延迟，通过压缩HTTPS首部字段将协议开销降低，同时增加请求优先级和服务器端推送的支持。</p>
<h2 id="什么是-SPYD-协议"><a href="#什么是-SPYD-协议" class="headerlink" title="什么是 SPYD 协议"></a>什么是 SPYD 协议</h2><p>SPDY是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。协议的核心思想是尽量减少TCP连接数。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。</p>
<p>互联网工程任务组(IETF)对谷歌提出的SPDY协议进行了标准化，于 2015 年 5 月推出了**类似于 SPDY 协议的 HTTP 2.0 协议标准(简称HTTP/2)**。谷歌因此宣布放弃对SPDY协议的支持，转而支持HTTP/2。</p>
<p>下面详细了解一下HTTP 2.0提供的新特性。</p>
<h2 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h2><p>在保证HTTP1.x不受到影响的情况下，HTTP 2.0是怎样突破HTTP 1.1的性能限制，改进传输性能，实现低延迟高吞吐量的呢?关键之一就是在应用层(HTTP)和传输层(TCP)之间增加一个二进制分帧层。HTTP/2性能提升的核心就在于二进制分帧层。HTTP/2是二进制协议，他采用二进制格式传输数据而不是1.x的文本格式。</p>
<p>HTTP 1.1在应用层以纯文本的形式进行通信，而HTTP 2.0将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。同时，客户端和服务端都需要引入新的二进制编码和解码的机制。如下图所示，HTTP 2.0并没有改变HTTP 1.x的语义，只是在应用层使用二进制分帧方式传输。</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220225160527.png"></p>
<p>上图很清晰地表达了HTTP/1.1的响应和2.0的区别。1.1响应是文本格式，而2.0把响应划分成了两个帧，图中的HEADERS（首部）和DATA（消息负载） 是帧的类型。也就是说一条HTTP响应，划分成了两个帧来传输，并且采用二进制来编码。</p>
<p>关于二进制分帧，有三个相关概念：帧、消息和流。</p>
<ul>
<li>帧：HTTP 2.0通信的最小单位</li>
<li>消息：比帧大的通讯单位，是指逻辑上的HTTP消息(请求/响应)，一系列数据帧组成了一个完整的消息。</li>
<li>流：比消息大的通讯单位，是TCP连接中的一个虚拟通道，可以承载双向的消息。</li>
</ul>
<h2 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h2><p>上面提到的 HTTP/1.1 的线头阻塞和多个 TCP 连接的问题，HTTP/2的多路复用能够完美解决。HTTP2让所有的通信都在一个TCP连接上完成，真正实现了请求的并发。</p>
<p><img src="https://raw.githubusercontent.com/zodical416/picto/master/20220225161239.png"></p>
<p>多路复用允许同时通过一个TCP连接发起多重的请求-响应消息。消息由帧构成，每帧数据上都标识属于哪个流(StreamID)，对方接收时根据流ID拼接每个流所有帧的数据，组成一块完整的数据。这就是HTTP/2的多路复用。</p>
<p>流的概念实现了单连接上多请求-响应并行，HTTP/2建立一个TCP连接，一个连接上面可以有任意多个流（stream），消息分割成一个或多个帧在流里面传输。帧传输过去以后，再进行重组，形成一个完整的请求或响应。</p>
<blockquote>
<p>请求太多时，浏览器或服务器还是会受不了，这超出了它的处理能力。流控制帮我们解决了这个问题，流控制会管理数据的传输，允许接收者停止或减少发送的数据量，免得接收方不堪重负。所以请求太多时，还是会存在排队等待的问题，因为不管是客户端或服务器端，能同时处理请求或响应都是有限的。</p>
</blockquote>
<h2 id="头部压缩-1"><a href="#头部压缩-1" class="headerlink" title="头部压缩"></a>头部压缩</h2><p>HTTP/1.1并不支持HTTP首部压缩，为此SPDY和HTTP/2应运而生， SPDY使用的是通用的算法，而HTTP/2则使用了专门为首部压缩而设计的算法 (HPACK算法)。</p>
<p>HTTP协议是无状态的，每次请求都必须附上所有信息(描述资源属性)，重传数据达到几百甚至几千字节。所以，请求头字段很多都是重复的，比如Cookie，一样的内容每次请求都必须附带，会浪费很多带宽，也影响速度。</p>
<p>其实，对于相同的头部，只需发送一次即可。HTTP/2对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。</p>
<h2 id="服务器端推送"><a href="#服务器端推送" class="headerlink" title="服务器端推送"></a>服务器端推送</h2><p>服务器端推送使得服务器可以预测客户端需要的资源，主动推送到客户端。客户端发送一个请求，服务器根据客户端的请求，提前返回多个响应，这样客户端就不用发起后续请求。也就是说，在HTTP/2中，服务器可以对客户端的一个请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。</p>
<h2 id="请求优先级-1"><a href="#请求优先级-1" class="headerlink" title="请求优先级"></a>请求优先级</h2><p>把HTTP消息分为很多独立帧之后，就可以通过<strong>优化这些帧的交错和传输顺序</strong>进一步优化性能。HTTP/2中每个Stream都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题。</p>
<h2 id="应用层的重置连接"><a href="#应用层的重置连接" class="headerlink" title="应用层的重置连接"></a>应用层的重置连接</h2><p>对于 HTTP/1 来说，是通过设置 tcp segment 中的 reset flag 来通知对端关闭连接的。这种方式会直接断开连接，下次再发请求就必须重新建立连接。HTTP/2 引入 RST_STREAM 类型的 frame，可以在不断开连接的前提下取消某个 request 的 stream ，表现更好。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>TCP协议是通过 sliding window 算法来做流量控制的。发送方有一个 sending window，接收方有一个 receive window。HTTP/2的流量控制类似receive window，数据接收方通知对方字节的 flow window 大小，表明还能接收的数据量。只有Data类型的frame才有流量控制功能。</p>
<p>通过上述方式，可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">ArcticUnicorn</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2023/11/16/ji-suan-ji-wang-luo-ji-chu/">http://example.com/2023/11/16/ji-suan-ji-wang-luo-ji-chu/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">ArcticUnicorn</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
                                    <span class="chip bg-color">计算机基础</span>
                                </a>
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                    <span class="chip bg-color">计算机网络</span>
                                </a>
                            
                                <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">
                                    <span class="chip bg-color">网络协议</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/11/16/cao-zuo-xi-tong-ji-chu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="操作系统基础">
                        
                        <span class="card-title">操作系统基础</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-11-16
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                    计算机基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
                        <span class="chip bg-color">计算机基础</span>
                    </a>
                    
                    <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/11/16/rabbitmq/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="RabbitMQ">
                        
                        <span class="card-title">RabbitMQ</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-11-16
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="post-category">
                                    中间件
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Rabbit-MQ/">
                        <span class="chip bg-color">Rabbit MQ</span>
                    </a>
                    
                    <a href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">
                        <span class="chip bg-color">消息中间件</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: ArcticUnicorn<br />'
            + '文章作者: 北极企鹅<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
	    <span id="calcSiteTime"></span> <br>
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2023</span>
            
            <a href="/about" target="_blank">北极企鹅</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">127.1k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2022";
                        var startMonth = "10";
                        var startDate = "25";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/ArcticUnicorn" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:18940979051@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1480142036" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1480142036" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="yao1m13835365174" class="tooltipped" target="_blank" data-tooltip="微信联系我:  yao1m13835365174"  data-position="top" data-delay="50">
        <i class="fab fa-weixin"></i>
    </a>



    <a href="https://weibo.com/u/5802281586" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/5802281586" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    
   

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>

</html>
